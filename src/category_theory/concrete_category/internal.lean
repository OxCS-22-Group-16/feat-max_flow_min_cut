import category_theory.concrete_category.operations
import category_theory.internal_operation

universes v‚ÇÅ v‚ÇÇ v‚ÇÉ u‚ÇÅ u‚ÇÇ u‚ÇÉ

noncomputable theory

namespace category_theory

open category opposite limits

@[simp] lemma nat_trans.hcomp_id {C‚ÇÅ C‚ÇÇ C‚ÇÉ : Type*} [category C‚ÇÅ] [category C‚ÇÇ] [category C‚ÇÉ]
  (F : C‚ÇÅ ‚•§ C‚ÇÇ) (G : C‚ÇÇ ‚•§ C‚ÇÉ) : (ùüô F) ‚ó´ (ùüô G) = ùüô (F ‚ãô G) := by tidy

namespace concrete_category

variables (A : Type u‚ÇÇ) [category.{v‚ÇÇ} A] [concrete_category.{v‚ÇÅ} A]
  (A' : Type u‚ÇÉ) [category.{v‚ÇÉ} A'] [concrete_category.{v‚ÇÅ} A']
  (C : Type u‚ÇÅ) [category.{v‚ÇÅ} C]

/-- The category of internal `A`-objects in the category `C`. -/
structure internal :=
(obj : C)
(presheaf : C·µí·µñ ‚•§ A)
(iso : yoneda.obj obj ‚âÖ presheaf ‚ãô forget A)

instance : category (internal A C) := induced_category.category (Œª X, X.presheaf)

namespace internal

@[simps]
def presheaf_functor : internal A C ‚•§ (C·µí·µñ ‚•§ A) := induced_functor _

@[simps]
def type_presheaf_functor : internal A C ‚•§ (C·µí·µñ ‚•§ Type v‚ÇÅ) :=
presheaf_functor A C ‚ãô (whiskering_right C·µí·µñ A (Type v‚ÇÅ)).obj (forget A)

def obj_functor : internal A C ‚•§ C :=
{ obj := Œª X, X.obj,
  map := Œª X Y f, yoneda.preimage ((X.iso.hom ‚â´ (f ‚ó´ (ùüô (forget A))) ‚â´ Y.iso.inv)),
  map_id' := Œª X, yoneda.map_injective begin
    erw [functor.image_preimage, nat_trans.hcomp_id, id_comp, X.iso.hom_inv_id,
      yoneda.map_id],
  end,
  map_comp' := Œª X Y Z f g, yoneda.map_injective begin
    simp only [functor.image_preimage, yoneda.map_comp, assoc, Y.iso.inv_hom_id_assoc],
    ext x : 2,
    simp only [nat_trans.comp_app, nat_trans.hcomp_id_app],
    erw [nat_trans.comp_app, functor.map_comp, assoc],
  end }

variables {A C} {Y Y' : C} (R : internal A C)

def presheaf_type := (type_presheaf_functor A C).obj R

lemma iso_hom_naturality (x : Y ‚ü∂ R.obj) (f : Y' ‚ü∂ Y) :
  R.iso.hom.app (op Y') (f ‚â´ x) = R.presheaf_type.map f.op (R.iso.hom.app (op Y) x) :=
congr_fun (R.iso.hom.naturality f.op) x

lemma iso_inv_naturality (x : R.presheaf_type.obj (op Y)) (f : Y' ‚ü∂ Y) :
  R.iso.inv.app (op Y') (R.presheaf_type.map f.op x) = f ‚â´ R.iso.inv.app (op Y) x :=
congr_fun (R.iso.inv.naturality f.op) x

@[simp]
def hom.to_internal_yoneda_operation‚ÇÅ {X‚ÇÅ X‚ÇÇ : internal A C} (f : X‚ÇÅ ‚ü∂ X‚ÇÇ) :
  internal_yoneda_operation‚ÇÅ_gen X‚ÇÅ.obj X‚ÇÇ.obj :=
  X‚ÇÅ.iso.hom ‚â´ (internal.type_presheaf_functor A C).map f ‚â´ X‚ÇÇ.iso.inv

@[simp]
lemma hom.to_internal_yoneda_operation‚ÇÅ_id (X : internal A C) :
  hom.to_internal_yoneda_operation‚ÇÅ (ùüô X) = ùüô _ :=
by { dsimp, erw [functor.map_id, id_comp, X.iso.hom_inv_id], }

@[simp]
lemma hom.to_internal_yoneda_operation‚ÇÅ_comp {X‚ÇÅ X‚ÇÇ X‚ÇÉ : internal A C} (f : X‚ÇÅ ‚ü∂ X‚ÇÇ) (g : X‚ÇÇ ‚ü∂ X‚ÇÉ) :
  hom.to_internal_yoneda_operation‚ÇÅ (f ‚â´ g) =
    hom.to_internal_yoneda_operation‚ÇÅ f ‚â´ hom.to_internal_yoneda_operation‚ÇÅ g :=
by { dsimp, simp only [functor.map_comp, assoc, X‚ÇÇ.iso.inv_hom_id_assoc], }

variables (A C)

@[protected]
def forget‚ÇÇ [has_forget‚ÇÇ A A'] : internal A C ‚•§ internal A' C :=
{ obj := Œª R,
  { obj := R.obj,
    presheaf := R.presheaf ‚ãô forget‚ÇÇ A A',
    iso := R.iso ‚â™‚â´ iso_whisker_left _ (eq_to_iso has_forget‚ÇÇ.forget_comp.symm) ‚â™‚â´
      (functor.associator _ _ _).symm, },
  map := Œª R‚ÇÅ R‚ÇÇ f, whisker_right f (forget‚ÇÇ A A'),
  map_id' := Œª R, begin
    ext Y,
    dsimp,
    erw [nat_trans.id_app, nat_trans.id_app, functor.map_id],
    refl,
  end,
  map_comp' := Œª R‚ÇÅ R‚ÇÇ R‚ÇÉ f g, begin
    ext Y,
    dsimp [whisker_right],
    erw [nat_trans.comp_app, nat_trans.comp_app, functor.map_comp],
  end, }

example : ‚Ñï := 43

variables {A C}

@[protected]
def Ab (R : internal A C) [has_forget‚ÇÇ A Ab.{v‚ÇÅ}] : internal Ab.{v‚ÇÅ} C :=
(internal.forget‚ÇÇ A Ab.{v‚ÇÅ} C).obj R

end internal

variables {A C}

open operations

namespace operation‚ÇÄ

variables (oper oper' : operation‚ÇÄ A) (R : internal A C)

def on_internal_presheaf (Y : C) : R.presheaf_type.obj (op Y) :=
oper.app (R.presheaf.obj (op Y)) punit.star

lemma on_internal_presheaf_naturality {Y Y' : C} (f : Y' ‚ü∂ Y) :
  oper.on_internal_presheaf R Y' = R.presheaf_type.map f.op (oper.on_internal_presheaf R Y) :=
congr_fun (oper.naturality (R.presheaf.map f.op)) punit.star

@[simp]
def to_internal_yoneda_operation‚ÇÄ_app (Y : C) : Y ‚ü∂ R.obj :=
R.iso.inv.app (op Y) (oper.on_internal_presheaf R Y)

lemma to_internal_yoneda_operation‚ÇÄ_app_naturality {Y Y' : C} (f : Y' ‚ü∂ Y) :
f ‚â´ oper.to_internal_yoneda_operation‚ÇÄ_app R Y = oper.to_internal_yoneda_operation‚ÇÄ_app R Y' :=
begin
  dsimp only [to_internal_yoneda_operation‚ÇÄ_app],
  rw [‚Üê R.iso_inv_naturality, oper.on_internal_presheaf_naturality R f],
end

@[simps]
def to_internal_yoneda_operation‚ÇÄ : internal_yoneda_operation‚ÇÄ R.obj :=
{ app := Œª X s, oper.to_internal_yoneda_operation‚ÇÄ_app R X.unop,
  naturality' := Œª X Y f, begin
    ext x,
    dsimp at x,
    have eq : x = punit.star := subsingleton.elim _ _,
    subst eq,
    exact (oper.to_internal_yoneda_operation‚ÇÄ_app_naturality R f.unop).symm,
  end }

end operation‚ÇÄ

namespace operation‚ÇÅ

variables (oper oper' : operation‚ÇÅ A) {R : internal A C}

variables {Y Y' : C}

@[protected]
def on_internal_presheaf
  (x : R.presheaf_type.obj (op Y)) : R.presheaf_type.obj (op Y) :=
oper.app (R.presheaf.obj (op Y)) x

lemma on_internal_presheaf_naturality (x : R.presheaf_type.obj (op Y)) (f : Y' ‚ü∂ Y) :
    oper.on_internal_presheaf (R.presheaf_type.map f.op x)  =
  R.presheaf_type.map f.op (oper.on_internal_presheaf x) :=
congr_fun (oper.naturality (R.presheaf.map f.op)) x

@[simp]
def to_internal_yoneda_operation‚ÇÅ_app (x : Y ‚ü∂ R.obj) : Y ‚ü∂ R.obj :=
R.iso.inv.app _ (oper.on_internal_presheaf (R.iso.hom.app (op Y) x))

lemma to_internal_yoneda_operation‚ÇÅ_app_naturality (x : Y ‚ü∂ R.obj) (f : Y' ‚ü∂ Y) :
  f ‚â´ oper.to_internal_yoneda_operation‚ÇÅ_app x = oper.to_internal_yoneda_operation‚ÇÅ_app (f ‚â´ x) :=
begin
  dsimp only [to_internal_yoneda_operation‚ÇÅ_app],
  simp only [R.iso_hom_naturality, on_internal_presheaf_naturality, R.iso_inv_naturality],
end

variable (R)

@[simps]
def to_internal_yoneda_operation‚ÇÅ : internal_yoneda_operation‚ÇÅ R.obj :=
{ app := Œª X x, oper.to_internal_yoneda_operation‚ÇÅ_app x,
  naturality' := Œª X Y f, begin
    ext x,
    symmetry,
    apply to_internal_yoneda_operation‚ÇÅ_app_naturality,
  end, }

end operation‚ÇÅ

namespace operation‚ÇÇ

variables (oper : operation‚ÇÇ A) {R : internal A C}

variables {Y Y' : C}

@[protected]
def on_internal_presheaf
  (x y : R.presheaf_type.obj (op Y)) : R.presheaf_type.obj (op Y) :=
oper.app (R.presheaf.obj (op Y)) ‚ü®x,y‚ü©

lemma on_internal_presheaf_naturality (x y : R.presheaf_type.obj (op Y)) (f : Y' ‚ü∂ Y) :
    oper.on_internal_presheaf (R.presheaf_type.map f.op x) (R.presheaf_type.map f.op y) =
  R.presheaf_type.map f.op (oper.on_internal_presheaf x y) :=
congr_fun (oper.naturality (R.presheaf.map f.op)) ‚ü®x,y‚ü©

@[simp]
def to_internal_yoneda_operation‚ÇÇ_app (x y : Y ‚ü∂ R.obj) : Y ‚ü∂ R.obj :=
R.iso.inv.app _ (oper.on_internal_presheaf (R.iso.hom.app (op Y) x) (R.iso.hom.app (op Y) y))

lemma to_internal_yoneda_operation‚ÇÇ_app_naturality (x y : Y ‚ü∂ R.obj) (f : Y' ‚ü∂ Y) :
  f ‚â´ oper.to_internal_yoneda_operation‚ÇÇ_app x y = oper.to_internal_yoneda_operation‚ÇÇ_app (f ‚â´ x) (f ‚â´ y) :=
begin
  dsimp only [to_internal_yoneda_operation‚ÇÇ_app],
  simp only [R.iso_hom_naturality, on_internal_presheaf_naturality, R.iso_inv_naturality],
end

variable (R)

@[simps]
def to_internal_yoneda_operation‚ÇÇ :
  concat‚ÇÇ (yoneda.obj R.obj) (yoneda.obj R.obj) ‚ü∂ yoneda.obj R.obj :=
{ app := Œª X x, oper.to_internal_yoneda_operation‚ÇÇ_app x.1 x.2,
  naturality' := Œª X Y f, begin
    ext x,
    symmetry,
    apply to_internal_yoneda_operation‚ÇÇ_app_naturality,
  end, }

lemma to_internal_yoneda_operation‚ÇÇ_comm (oper_comm : oper.comm) :
  (oper.to_internal_yoneda_operation‚ÇÇ R) =
    lift‚ÇÇ pr‚ÇÇ pr‚ÇÅ ‚â´ (oper.to_internal_yoneda_operation‚ÇÇ R) :=
begin
  dsimp at oper_comm,
  conv_lhs { rw oper_comm, },
  refl,
end

lemma to_internal_yoneda_operation‚ÇÇ_zero_add (zero : operation‚ÇÄ A)
  (oper_zero : oper.zero_add zero) :
  lift‚ÇÇ (to_functor_const_punit ‚â´ zero.to_internal_yoneda_operation‚ÇÄ R) (ùüô _) ‚â´
    oper.to_internal_yoneda_operation‚ÇÇ R = ùüô _ :=
begin
  convert _root_.congr_arg (Œª (m : operation‚ÇÅ A), m.to_internal_yoneda_operation‚ÇÅ R) oper_zero,
  { ext X x,
    dsimp at x ‚ä¢,
    simp only [functor_to_types.inv_hom_id_app_apply],
    congr },
  { ext X x,
    dsimp [operation‚ÇÅ.on_internal_presheaf] at x ‚ä¢,
    simp, },
end

lemma to_internal_yoneda_operation‚ÇÇ_add_left_neg (zero : operation‚ÇÄ A) (neg : operation‚ÇÅ A)
  (oper_left_neg : oper.add_left_neg zero neg) :
  lift‚ÇÇ (neg.to_internal_yoneda_operation‚ÇÅ R) (ùüô _) ‚â´ oper.to_internal_yoneda_operation‚ÇÇ R =
    to_functor_const_punit ‚â´ zero.to_internal_yoneda_operation‚ÇÄ R :=
begin
  convert _root_.congr_arg (Œª (m : operation‚ÇÅ A), m.to_internal_yoneda_operation‚ÇÅ R) oper_left_neg,
  ext X x,
  dsimp [operation‚ÇÅ.on_internal_presheaf, operation‚ÇÄ.on_internal_presheaf,
    operation‚ÇÇ.on_internal_presheaf],
  simp only [functor_to_types.inv_hom_id_app_apply],
end

end operation‚ÇÇ

namespace operation‚ÇÉ

variables (oper : operation‚ÇÉ A) {R : internal A C} {Y Y' : C}

@[protected]
def on_internal_presheaf
  (x y z : R.presheaf_type.obj (op Y)) : R.presheaf_type.obj (op Y) :=
oper.app (R.presheaf.obj (op Y)) ‚ü®x, y, z‚ü©

lemma on_internal_presheaf_naturality (x y z : R.presheaf_type.obj (op Y)) (f : Y' ‚ü∂ Y) :
    oper.on_internal_presheaf (R.presheaf_type.map f.op x) (R.presheaf_type.map f.op y)
      (R.presheaf_type.map f.op z) =
  R.presheaf_type.map f.op (oper.on_internal_presheaf x y z) :=
congr_fun (oper.naturality (R.presheaf.map f.op)) ‚ü®x, y, z‚ü©

@[simp]
def to_internal_yoneda_operation‚ÇÉ_app (x y z : Y ‚ü∂ R.obj) : Y ‚ü∂ R.obj :=
R.iso.inv.app _ (oper.on_internal_presheaf (R.iso.hom.app (op Y) x) (R.iso.hom.app (op Y) y)
  (R.iso.hom.app (op Y) z))

lemma to_internal_yoneda_operation‚ÇÉ_app_naturality (x y z : Y ‚ü∂ R.obj) (f : Y' ‚ü∂ Y) :
  f ‚â´ oper.to_internal_yoneda_operation‚ÇÉ_app x y z = oper.to_internal_yoneda_operation‚ÇÉ_app (f ‚â´ x) (f ‚â´ y) (f ‚â´ z) :=
begin
  dsimp only [to_internal_yoneda_operation‚ÇÉ_app],
  simp only [R.iso_hom_naturality, on_internal_presheaf_naturality, R.iso_inv_naturality],
end

variable (R)

@[simps]
def to_internal_yoneda_operation‚ÇÉ :
  concat‚ÇÉ (yoneda.obj R.obj) (yoneda.obj R.obj) (yoneda.obj R.obj) ‚ü∂ yoneda.obj R.obj :=
{ app := Œª X x, oper.to_internal_yoneda_operation‚ÇÉ_app x.1 x.2.1 x.2.2,
  naturality' := Œª X Y f, begin
    ext x,
    symmetry,
    apply to_internal_yoneda_operation‚ÇÉ_app_naturality,
  end, }

end operation‚ÇÉ

namespace operation‚ÇÇ

variables (oper : operation‚ÇÇ A) (R : internal A C)

lemma to_internal_yoneda_operation‚ÇÇ_assoc (oper_assoc : oper.assoc) :
  lift‚ÇÇ (pr‚ÇÅ‚ÇÇ_‚ÇÉ ‚â´ oper.to_internal_yoneda_operation‚ÇÇ R) pr‚ÇÉ_‚ÇÉ ‚â´ oper.to_internal_yoneda_operation‚ÇÇ R =
    lift‚ÇÇ pr‚ÇÅ_‚ÇÉ (pr‚ÇÇ‚ÇÉ_‚ÇÉ ‚â´ oper.to_internal_yoneda_operation‚ÇÇ R) ‚â´ (oper.to_internal_yoneda_operation‚ÇÇ R) :=
begin
  convert _root_.congr_arg (Œª (m : operation‚ÇÉ A), m.to_internal_yoneda_operation‚ÇÉ R) oper_assoc;
  { ext X x,
    dsimp,
    simpa only [functor_to_types.inv_hom_id_app_apply], },
end

lemma to_internal_yoneda_operation‚ÇÇ_right_distrib (mul : operation‚ÇÇ A) (add : operation‚ÇÇ A)
  (R : internal A C) (h : mul.right_distrib add) :
  internal_yoneda_operation‚ÇÇ_gen.right_distrib (mul.to_internal_yoneda_operation‚ÇÇ R)
    (add.to_internal_yoneda_operation‚ÇÇ R) (add.to_internal_yoneda_operation‚ÇÇ R) :=
begin
  have h' := _root_.congr_arg (Œª (m : operation‚ÇÉ A), m.to_internal_yoneda_operation‚ÇÉ R) h,
  dsimp at h ‚ä¢,
  convert h';
  { ext X x,
    dsimp,
    simpa, },
end

lemma to_internal_yoneda_operation‚ÇÇ_left_distrib (mul : operation‚ÇÇ A) (add : operation‚ÇÇ A)
  (R : internal A C) (h : mul.left_distrib add) :
  internal_yoneda_operation‚ÇÇ_gen.left_distrib (mul.to_internal_yoneda_operation‚ÇÇ R)
    (add.to_internal_yoneda_operation‚ÇÇ R) (add.to_internal_yoneda_operation‚ÇÇ R) :=
begin
  have h' := _root_.congr_arg (Œª (m : operation‚ÇÉ A), m.to_internal_yoneda_operation‚ÇÉ R) h,
  dsimp at h ‚ä¢,
  convert h';
  { ext X x,
    dsimp,
    simpa, },
end

end operation‚ÇÇ

end concrete_category

open concrete_category concrete_category.operations

variables {A‚ÇÅ A‚ÇÇ A‚ÇÉ A‚ÇÑ C : Type*} [category A‚ÇÅ] [category A‚ÇÇ] [category A‚ÇÉ] [category A‚ÇÑ]
  [category.{v‚ÇÅ} C] [concrete_category.{v‚ÇÅ} A‚ÇÅ] [concrete_category.{v‚ÇÅ} A‚ÇÇ]
  [concrete_category.{v‚ÇÅ} A‚ÇÉ] [concrete_category.{v‚ÇÅ} A‚ÇÑ]
  {M‚ÇÅ : internal A‚ÇÅ C} {M‚ÇÇ : internal A‚ÇÇ C} {M‚ÇÉ : internal A‚ÇÉ C} {M‚ÇÑ : internal A‚ÇÑ C}

namespace internal_yoneda_operation‚ÇÄ

@[simp]
def to_presheaf (c : internal_yoneda_operation‚ÇÄ M‚ÇÅ.obj) (Y : C·µí·µñ) :=
  (c ‚â´ M‚ÇÅ.iso.hom).app Y punit.star

lemma to_presheaf_map (c : internal_yoneda_operation‚ÇÄ M‚ÇÅ.obj) {Y Y' : C·µí·µñ} (f : Y ‚ü∂ Y') :
  (M‚ÇÅ.presheaf ‚ãô forget A‚ÇÅ).map f (c.to_presheaf Y) = c.to_presheaf Y' :=
congr_fun ((c ‚â´ M‚ÇÅ.iso.hom).naturality f).symm punit.star

end internal_yoneda_operation‚ÇÄ

namespace internal_yoneda_operation‚ÇÅ_gen

variables (oper : internal_yoneda_operation‚ÇÅ_gen M‚ÇÅ.obj M‚ÇÇ.obj) {Y Y' : C·µí·µñ}

@[simps]
def on_internal_presheaf : M‚ÇÅ.presheaf_type ‚ü∂ M‚ÇÇ.presheaf_type :=
M‚ÇÅ.iso.inv ‚â´ oper ‚â´ M‚ÇÇ.iso.hom

end internal_yoneda_operation‚ÇÅ_gen

namespace internal_yoneda_operation‚ÇÇ_gen

variables (oper : internal_yoneda_operation‚ÇÇ_gen M‚ÇÅ.obj M‚ÇÇ.obj M‚ÇÉ.obj) {Y Y' : C·µí·µñ}

def on_internal_presheaf : concat‚ÇÇ M‚ÇÅ.presheaf_type M‚ÇÇ.presheaf_type ‚ü∂ M‚ÇÉ.presheaf_type :=
lift‚ÇÇ (pr‚ÇÅ ‚â´ M‚ÇÅ.iso.inv) (pr‚ÇÇ ‚â´ M‚ÇÇ.iso.inv) ‚â´ oper ‚â´ M‚ÇÉ.iso.hom

@[simp]
def on_internal_presheaf_curry
  (x‚ÇÅ : M‚ÇÅ.presheaf_type.obj Y) (x‚ÇÇ : M‚ÇÇ.presheaf_type.obj Y) :
  M‚ÇÉ.presheaf_type.obj Y :=
M‚ÇÉ.iso.hom.app _ (oper.app _ ‚ü®M‚ÇÅ.iso.inv.app _ x‚ÇÅ, M‚ÇÇ.iso.inv.app _ x‚ÇÇ‚ü©)

@[simp]
lemma on_internal_presheaf_app
  (x‚ÇÅ : M‚ÇÅ.presheaf_type.obj Y) (x‚ÇÇ : M‚ÇÇ.presheaf_type.obj Y) :
  oper.on_internal_presheaf.app Y ‚ü®x‚ÇÅ, x‚ÇÇ‚ü© = oper.on_internal_presheaf_curry x‚ÇÅ x‚ÇÇ := rfl

def on_internal_presheaf_curry_naturality
  (f : Y ‚ü∂ Y') (x‚ÇÅ : M‚ÇÅ.presheaf_type.obj Y) (x‚ÇÇ : M‚ÇÇ.presheaf_type.obj Y) :
  M‚ÇÉ.presheaf_type.map f (oper.on_internal_presheaf_curry x‚ÇÅ x‚ÇÇ) =
  oper.on_internal_presheaf_curry (M‚ÇÅ.presheaf_type.map f x‚ÇÅ)
    (M‚ÇÇ.presheaf_type.map f x‚ÇÇ) :=
congr_fun (oper.on_internal_presheaf.naturality f).symm ‚ü®x‚ÇÅ, x‚ÇÇ‚ü©

end internal_yoneda_operation‚ÇÇ_gen

namespace internal_yoneda_operation‚ÇÉ_gen

variables (oper : internal_yoneda_operation‚ÇÉ_gen M‚ÇÅ.obj M‚ÇÇ.obj M‚ÇÉ.obj M‚ÇÑ.obj)

def on_internal_presheaf : concat‚ÇÉ M‚ÇÅ.presheaf_type M‚ÇÇ.presheaf_type M‚ÇÉ.presheaf_type ‚ü∂ M‚ÇÑ.presheaf_type :=
lift‚ÇÉ (pr‚ÇÅ_‚ÇÉ ‚â´ M‚ÇÅ.iso.inv) (pr‚ÇÇ_‚ÇÉ ‚â´ M‚ÇÇ.iso.inv) (pr‚ÇÉ_‚ÇÉ ‚â´ M‚ÇÉ.iso.inv) ‚â´ oper ‚â´ M‚ÇÑ.iso.hom

end internal_yoneda_operation‚ÇÉ_gen

end category_theory
