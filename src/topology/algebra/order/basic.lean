/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Mario Carneiro, Yury Kudryashov
-/
import data.set.pointwise.interval
import topology.algebra.group.basic
import topology.order.basic

/-!
# Theory of topology on ordered spaces

## Main definitions

The order topology on an ordered space is the topology generated by all open intervals (or
equivalently by those of the form `(-‚àû, a)` and `(b, +‚àû)`). We define it as `preorder.topology Œ±`.
However, we do *not* register it as an instance (as many existing ordered types already have
topologies, which would be equal but not definitionally equal to `preorder.topology Œ±`). Instead,
we introduce a class `order_topology Œ±` (which is a `Prop`, also known as a mixin) saying that on
the type `Œ±` having already a topological space structure and a preorder structure, the topological
structure is equal to the order topology.

We also introduce another (mixin) class `order_closed_topology Œ±` saying that the set of points
`(x, y)` with `x ‚â§ y` is closed in the product space. This is automatically satisfied on a linear
order with the order topology.

We prove many basic properties of such topologies.

## Main statements

This file contains the proofs of the following facts. For exact requirements
(`order_closed_topology` vs `order_topology`, `preorder` vs `partial_order` vs `linear_order` etc)
see their statements.

### Open / closed sets

* `is_open_lt` : if `f` and `g` are continuous functions, then `{x | f x < g x}` is open;
* `is_open_Iio`, `is_open_Ioi`, `is_open_Ioo` : open intervals are open;
* `is_closed_le` : if `f` and `g` are continuous functions, then `{x | f x ‚â§ g x}` is closed;
* `is_closed_Iic`, `is_closed_Ici`, `is_closed_Icc` : closed intervals are closed;
* `frontier_le_subset_eq`, `frontier_lt_subset_eq` : frontiers of both `{x | f x ‚â§ g x}`
  and `{x | f x < g x}` are included by `{x | f x = g x}`;
* `exists_Ioc_subset_of_mem_nhds`, `exists_Ico_subset_of_mem_nhds` : if `x < y`, then any
  neighborhood of `x` includes an interval `[x, z)` for some `z ‚àà (x, y]`, and any neighborhood
  of `y` includes an interval `(z, y]` for some `z ‚àà [x, y)`.

### Convergence and inequalities

* `le_of_tendsto_of_tendsto` : if `f` converges to `a`, `g` converges to `b`, and eventually
  `f x ‚â§ g x`, then `a ‚â§ b`
* `le_of_tendsto`, `ge_of_tendsto` : if `f` converges to `a` and eventually `f x ‚â§ b`
  (resp., `b ‚â§ f x`), then `a ‚â§ b` (resp., `b ‚â§ a); we also provide primed versions
  that assume the inequalities to hold for all `x`.

### Min, max, `Sup` and `Inf`

* `continuous.min`, `continuous.max`: pointwise `min`/`max` of two continuous functions is
  continuous.
* `tendsto.min`, `tendsto.max` : if `f` tends to `a` and `g` tends to `b`, then their pointwise
  `min`/`max` tend to `min a b` and `max a b`, respectively.
* `tendsto_of_tendsto_of_tendsto_of_le_of_le` : theorem known as squeeze theorem,
  sandwich theorem, theorem of Carabinieri, and two policemen (and a drunk) theorem; if `g` and `h`
  both converge to `a`, and eventually `g x ‚â§ f x ‚â§ h x`, then `f` converges to `a`.

## Implementation notes

We do _not_ register the order topology as an instance on a preorder (or even on a linear order).
Indeed, on many such spaces, a topology has already been constructed in a different way (think
of the discrete spaces `‚Ñï` or `‚Ñ§`, or `‚Ñù` that could inherit a topology as the completion of `‚Ñö`),
and is in general not defeq to the one generated by the intervals. We make it available as a
definition `preorder.topology Œ±` though, that can be registered as an instance when necessary, or
for specific types.
-/

open set filter topological_space
open function
open order_dual (to_dual of_dual)
open_locale topological_space classical filter

universes u v w
variables {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w}

section order_closed_topology
variables [topological_space Œ±] [linear_order Œ±] [order_closed_topology Œ±] [has_one Œ±]
  [topological_space Œ≤] {a b : Œ±}

/-- A continuous function with compact support is bounded below. -/
@[to_additive /-" A continuous function with compact support is bounded below. "-/]
lemma continuous.bdd_below_range_of_has_compact_mul_support {f : Œ≤ ‚Üí Œ±}
  (hf : continuous f) (h : has_compact_mul_support f) : bdd_below (range f) :=
(h.is_compact_range hf).bdd_below

/-- A continuous function with compact support is bounded above. -/
@[to_additive /-" A continuous function with compact support is bounded above. "-/]
lemma continuous.bdd_above_range_of_has_compact_mul_support
  {f : Œ≤ ‚Üí Œ±} (hf : continuous f) (h : has_compact_mul_support f) :
  bdd_above (range f) :=
@continuous.bdd_below_range_of_has_compact_mul_support Œ±·µí·µà _ _ _ _ _ _ _ hf h

end order_closed_topology

section order_topology
section linear_ordered_add_comm_group
variables [topological_space Œ±] [linear_ordered_add_comm_group Œ±] [order_topology Œ±]
variables {l : filter Œ≤} {f g : Œ≤ ‚Üí Œ±}

lemma nhds_eq_infi_abs_sub (a : Œ±) : ùìù a = (‚®Ör>0, ùìü {b | |a - b| < r}) :=
begin
  simp only [le_antisymm_iff, nhds_eq_order, le_inf_iff, le_infi_iff, le_principal_iff, mem_Ioi,
    mem_Iio, abs_sub_lt_iff, @sub_lt_iff_lt_add _ _ _ _ _ _ a, @sub_lt_comm _ _ _ _ a, set_of_and],
  refine ‚ü®_, _, _‚ü©,
  { intros Œµ Œµ0,
    exact inter_mem_inf
      (mem_infi_of_mem (a - Œµ) $ mem_infi_of_mem (sub_lt_self a Œµ0) (mem_principal_self _))
      (mem_infi_of_mem (Œµ + a) $ mem_infi_of_mem (by simpa) (mem_principal_self _)) },
  { intros b hb,
    exact mem_infi_of_mem (a - b) (mem_infi_of_mem (sub_pos.2 hb) (by simp [Ioi])) },
  { intros b hb,
    exact mem_infi_of_mem (b - a) (mem_infi_of_mem (sub_pos.2 hb) (by simp [Iio])) }
end

lemma order_topology_of_nhds_abs {Œ± : Type*} [topological_space Œ±] [linear_ordered_add_comm_group Œ±]
  (h_nhds : ‚àÄa:Œ±, ùìù a = (‚®Ör>0, ùìü {b | |a - b| < r})) : order_topology Œ± :=
begin
  refine ‚ü®eq_of_nhds_eq_nhds $ Œª a, _‚ü©,
  rw [h_nhds],
  letI := preorder.topology Œ±, letI : order_topology Œ± := ‚ü®rfl‚ü©,
  exact (nhds_eq_infi_abs_sub a).symm
end

lemma linear_ordered_add_comm_group.tendsto_nhds {x : filter Œ≤} {a : Œ±} :
  tendsto f x (ùìù a) ‚Üî ‚àÄ Œµ > (0 : Œ±), ‚àÄ·∂† b in x, |f b - a| < Œµ :=
by simp [nhds_eq_infi_abs_sub, abs_sub_comm a]

lemma eventually_abs_sub_lt (a : Œ±) {Œµ : Œ±} (hŒµ : 0 < Œµ) : ‚àÄ·∂† x in ùìù a, |x - a| < Œµ :=
(nhds_eq_infi_abs_sub a).symm ‚ñ∏ mem_infi_of_mem Œµ
  (mem_infi_of_mem hŒµ $ by simp only [abs_sub_comm, mem_principal_self])

@[priority 100] -- see Note [lower instance priority]
instance linear_ordered_add_comm_group.topological_add_group : topological_add_group Œ± :=
{ continuous_add :=
    begin
      refine continuous_iff_continuous_at.2 _,
      rintro ‚ü®a, b‚ü©,
      refine linear_ordered_add_comm_group.tendsto_nhds.2 (Œª Œµ Œµ0, _),
      rcases dense_or_discrete 0 Œµ with (‚ü®Œ¥, Œ¥0, Œ¥Œµ‚ü©|‚ü®h‚ÇÅ, h‚ÇÇ‚ü©),
      { -- If there exists `Œ¥ ‚àà (0, Œµ)`, then we choose `Œ¥`-nhd of `a` and `(Œµ-Œ¥)`-nhd of `b`
        filter_upwards [(eventually_abs_sub_lt a Œ¥0).prod_nhds
          (eventually_abs_sub_lt b (sub_pos.2 Œ¥Œµ))],
        rintros ‚ü®x, y‚ü© ‚ü®hx : |x - a| < Œ¥, hy : |y - b| < Œµ - Œ¥‚ü©,
        rw [add_sub_add_comm],
        calc |x - a + (y - b)| ‚â§ |x - a| + |y - b| : abs_add _ _
        ... < Œ¥ + (Œµ - Œ¥) : add_lt_add hx hy
        ... = Œµ : add_sub_cancel'_right _ _ },
      { -- Otherwise `Œµ`-nhd of each point `a` is `{a}`
        have hŒµ : ‚àÄ {x y}, |x - y| < Œµ ‚Üí x = y,
        { intros x y h,
          simpa [sub_eq_zero] using h‚ÇÇ _ h },
        filter_upwards [(eventually_abs_sub_lt a Œµ0).prod_nhds (eventually_abs_sub_lt b Œµ0)],
        rintros ‚ü®x, y‚ü© ‚ü®hx : |x - a| < Œµ, hy : |y - b| < Œµ‚ü©,
        simpa [hŒµ hx, hŒµ hy] }
    end,
  continuous_neg := continuous_iff_continuous_at.2 $ Œª a,
    linear_ordered_add_comm_group.tendsto_nhds.2 $ Œª Œµ Œµ0,
      (eventually_abs_sub_lt a Œµ0).mono $ Œª x hx, by rwa [neg_sub_neg, abs_sub_comm] }

@[continuity]
lemma continuous_abs : continuous (abs : Œ± ‚Üí Œ±) := continuous_id.max continuous_neg

lemma filter.tendsto.abs {f : Œ≤ ‚Üí Œ±} {a : Œ±} {l : filter Œ≤} (h : tendsto f l (ùìù a)) :
  tendsto (Œª x, |f x|) l (ùìù (|a|)) :=
(continuous_abs.tendsto _).comp h

lemma tendsto_zero_iff_abs_tendsto_zero (f : Œ≤ ‚Üí Œ±) {l : filter Œ≤} :
  tendsto f l (ùìù 0) ‚Üî tendsto (abs ‚àò f) l (ùìù 0) :=
begin
  refine ‚ü®Œª h, (abs_zero : |(0 : Œ±)| = 0) ‚ñ∏ h.abs, Œª h, _‚ü©,
  have : tendsto (Œª a, -|f a|) l (ùìù 0) := (neg_zero : -(0 : Œ±) = 0) ‚ñ∏ h.neg,
  exact tendsto_of_tendsto_of_tendsto_of_le_of_le this h
    (Œª x, neg_abs_le_self $ f x) (Œª x, le_abs_self $ f x),
end

lemma nhds_basis_Ioo_pos [no_min_order Œ±] [no_max_order Œ±] (a : Œ±) :
  (ùìù a).has_basis (Œª Œµ : Œ±, (0 : Œ±) < Œµ) (Œª Œµ, Ioo (a-Œµ) (a+Œµ)) :=
‚ü®begin
  refine Œª t, (nhds_basis_Ioo a).mem_iff.trans ‚ü®_, _‚ü©,
  { rintros ‚ü®‚ü®l, u‚ü©, ‚ü®hl : l < a, hu : a < u‚ü©, h' : Ioo l u ‚äÜ t‚ü©,
    refine ‚ü®min (a-l) (u-a), by apply lt_min; rwa sub_pos, _‚ü©,
    rintros x ‚ü®hx, hx'‚ü©,
    apply h',
    rw [sub_lt_comm, lt_min_iff, sub_lt_sub_iff_left] at hx,
    rw [‚Üê sub_lt_iff_lt_add', lt_min_iff, sub_lt_sub_iff_right] at hx',
    exact ‚ü®hx.1, hx'.2‚ü© },
  { rintros ‚ü®Œµ, Œµ_pos, h‚ü©,
    exact ‚ü®(a-Œµ, a+Œµ), by simp [Œµ_pos], h‚ü© },
end‚ü©

lemma nhds_basis_abs_sub_lt [no_min_order Œ±] [no_max_order Œ±] (a : Œ±) :
  (ùìù a).has_basis (Œª Œµ : Œ±, (0 : Œ±) < Œµ) (Œª Œµ, {b | |b - a| < Œµ}) :=
begin
  convert nhds_basis_Ioo_pos a,
  { ext Œµ,
    change |x - a| < Œµ ‚Üî a - Œµ < x ‚àß x < a + Œµ,
    simp [abs_lt, sub_lt_iff_lt_add, add_comm Œµ a, add_comm x Œµ] }
end

variable (Œ±)

lemma nhds_basis_zero_abs_sub_lt [no_min_order Œ±] [no_max_order Œ±] :
  (ùìù (0 : Œ±)).has_basis (Œª Œµ : Œ±, (0 : Œ±) < Œµ) (Œª Œµ, {b | |b| < Œµ}) :=
by simpa using nhds_basis_abs_sub_lt (0 : Œ±)

variable {Œ±}

/-- If `a` is positive we can form a basis from only nonnegative `Ioo` intervals -/
lemma nhds_basis_Ioo_pos_of_pos [no_min_order Œ±] [no_max_order Œ±]
  {a : Œ±} (ha : 0 < a) :
  (ùìù a).has_basis (Œª Œµ : Œ±, (0 : Œ±) < Œµ ‚àß Œµ ‚â§ a) (Œª Œµ, Ioo (a-Œµ) (a+Œµ)) :=
‚ü® Œª t, (nhds_basis_Ioo_pos a).mem_iff.trans
  ‚ü®Œª h, let ‚ü®i, hi, hit‚ü© := h in
    ‚ü®min i a, ‚ü®lt_min hi ha, min_le_right i a‚ü©, trans (Ioo_subset_Ioo
    (sub_le_sub_left (min_le_left i a) a) (add_le_add_left (min_le_left i a) a)) hit‚ü©,
  Œª h, let ‚ü®i, hi, hit‚ü© := h in ‚ü®i, hi.1, hit‚ü© ‚ü© ‚ü©

section

variables [topological_space Œ≤] {b : Œ≤} {a : Œ±} {s : set Œ≤}

lemma continuous.abs (h : continuous f) : continuous (Œª x, |f x|) := continuous_abs.comp h

lemma continuous_at.abs (h : continuous_at f b) : continuous_at (Œª x, |f x|) b := h.abs

lemma continuous_within_at.abs (h : continuous_within_at f s b) :
  continuous_within_at (Œª x, |f x|) s b := h.abs

lemma continuous_on.abs (h : continuous_on f s) : continuous_on (Œª x, |f x|) s :=
Œª x hx, (h x hx).abs

lemma tendsto_abs_nhds_within_zero : tendsto (abs : Œ± ‚Üí Œ±) (ùìù[‚â†] 0) (ùìù[>] 0) :=
(continuous_abs.tendsto' (0 : Œ±) 0 abs_zero).inf $ tendsto_principal_principal.2 $ Œª x, abs_pos.2

end

/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to `C`
and `g` tends to `at_top` then `f + g` tends to `at_top`. -/
lemma filter.tendsto.add_at_top {C : Œ±} (hf : tendsto f l (ùìù C)) (hg : tendsto g l at_top) :
  tendsto (Œª x, f x + g x) l at_top :=
begin
  nontriviality Œ±,
  obtain ‚ü®C', hC'‚ü© : ‚àÉ C', C' < C := exists_lt C,
  refine tendsto_at_top_add_left_of_le' _ C' _ hg,
  exact (hf.eventually (lt_mem_nhds hC')).mono (Œª x, le_of_lt)
end

/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to `C`
and `g` tends to `at_bot` then `f + g` tends to `at_bot`. -/
lemma filter.tendsto.add_at_bot {C : Œ±} (hf : tendsto f l (ùìù C)) (hg : tendsto g l at_bot) :
  tendsto (Œª x, f x + g x) l at_bot :=
@filter.tendsto.add_at_top Œ±·µí·µà _ _ _ _ _ _ _ _ hf hg

/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to
`at_top` and `g` tends to `C` then `f + g` tends to `at_top`. -/
lemma filter.tendsto.at_top_add {C : Œ±} (hf : tendsto f l at_top) (hg : tendsto g l (ùìù C)) :
  tendsto (Œª x, f x + g x) l at_top :=
by { conv in (_ + _) { rw add_comm }, exact hg.add_at_top hf }

/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to
`at_bot` and `g` tends to `C` then `f + g` tends to `at_bot`. -/
lemma filter.tendsto.at_bot_add {C : Œ±} (hf : tendsto f l at_bot) (hg : tendsto g l (ùìù C)) :
  tendsto (Œª x, f x + g x) l at_bot :=
by { conv in (_ + _) { rw add_comm }, exact hg.add_at_bot hf }

lemma eventually_nhds_within_pos_mem_Ioo {Œµ : Œ±} (h : 0 < Œµ) :
  ‚àÄ·∂† x in ùìù[>] 0, x ‚àà Ioo 0 Œµ :=
begin
  rw [eventually_iff, mem_nhds_within],
  exact ‚ü®Ioo (-Œµ) Œµ, is_open_Ioo, by simp [h], Œª x hx, ‚ü®hx.2, hx.1.2‚ü©‚ü©,
end

lemma eventually_nhds_within_pos_mem_Ioc {Œµ : Œ±} (h : 0 < Œµ) :
  ‚àÄ·∂† x in ùìù[>] 0, x ‚àà Ioc 0 Œµ :=
(eventually_nhds_within_pos_mem_Ioo h).mono Ioo_subset_Ioc_self

end linear_ordered_add_comm_group
end order_topology
