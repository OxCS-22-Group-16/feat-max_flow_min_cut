/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl
-/
import algebra.big_operators.intervals
import algebra.big_operators.nat_antidiagonal
import logic.encodable.lattice
import topology.algebra.mul_action
import topology.algebra.order.monotone_convergence
import topology.instances.real

/-!
# Infinite sum/product over a topological monoid

This sum is known as unconditionally convergent, as it sums to the same value under all possible
permutations. For Euclidean spaces (finite dimensional Banach spaces) this is equivalent to absolute
convergence.

Note: There are summable sequences which are not unconditionally convergent! The other way holds
generally, see `has_sum.tendsto_sum_nat`.

## Main declarations

* `has_prod`: Predicate for an infinite product to unconditionally converge to a given value.
* `has_sum`: Predicate for an infinite series to unconditionally converge to a given value.
* `prodable`: Predicate for an infinite product to unconditionally converge to some value.
* `summable`: Predicate for an infinite series to unconditionally converge to some value.
* `tprod`: The value an infinite product converges to, if such value exists. Else, defaults to `1`.
* `tsum`: The value an infinite series converges to, if such value exists. Else, defaults to `0`.

## References

* Bourbaki: General Topology (1995), Chapter 3 ¬ß5 (Infinite sums in commutative groups)

-/

noncomputable theory
open finset filter function classical
open_locale topology classical big_operators nnreal

variables {Œ± Œ±' Œ≤ Œ≥ Œ¥ G G' : Type*}

section has_prod
variables [comm_monoid Œ±] [topological_space Œ±]

/-- Infinite product on a topological monoid

The `at_top` filter on `finset Œ≤` is the limit of all finite sets towards the entire type. So we
take the product of bigger and bigger sets. This product operation is invariant under reordering. In
particular, the function `‚Ñï ‚Üí ‚Ñù` sending `n` to `e ^ ((-1)^n / (n + 1))` does not have a product for
this definition, but a series which is absolutely convergent will have the correct product.

This is based on Mario Carneiro's
[infinite sum `df-tsms` in Metamath](http://us.metamath.org/mpeuni/df-tsms.html).

For the definition or many statements, `Œ±` does not need to be a topological monoid. We only add
this assumption later, for the lemmas where it is relevant. -/
@[to_additive "Infinite sum on a topological monoid

The `at_top` filter on `finset Œ≤` is the limit of all finite sets towards the entire type. So we sum
up bigger and bigger sets. This sum operation is invariant under reordering. In particular,
the function `‚Ñï ‚Üí ‚Ñù` sending `n` to `(-1)^n / (n+1)` does not have a
sum for this definition, but a series which is absolutely convergent will have the correct sum.

This is based on Mario Carneiro's
[infinite sum `df-tsms` in Metamath](http://us.metamath.org/mpeuni/df-tsms.html).

For the definition or many statements, `Œ±` does not need to be a topological monoid. We only add
this assumption later, for the lemmas where it is relevant."]
def has_prod (f : Œ≤ ‚Üí Œ±) (a : Œ±) : Prop := tendsto (Œª s, ‚àè b in s, f b) at_top (ùìù a)

/-- `summable f` means that `f` has some (infinite) sum. Use `tsum` to get the value. -/
@[to_additive "`summable f` means that `f` has some (infinite) sum. Use `tsum` to get the value."]
def prodable (f : Œ≤ ‚Üí Œ±) : Prop := ‚àÉ a, has_prod f a

/-- `‚àè' i, f i` is the product of `f` it exists, or `1` otherwise. -/
@[to_additive "`‚àë' i, f i` is the sum of `f` it exists, or `0` otherwise.", irreducible]
def tprod (f : Œ≤ ‚Üí Œ±) := if h : prodable f then classical.some h else 1

-- see Note [operator precedence of big operators]
notation `‚àë'` binders `, ` r:(scoped:67 f, tsum f) := r
notation `‚àè'` binders `, ` r:(scoped:67 f, tprod f) := r

variables {f g : Œ≤ ‚Üí Œ±} {a a' a‚ÇÅ a‚ÇÇ b : Œ±} {s : finset Œ≤}

@[to_additive summable.has_sum]
lemma prodable.has_prod (ha : prodable f) : has_prod f (‚àè' b, f b) :=
by simp [ha, tprod]; exact some_spec ha

@[to_additive has_sum.summable]
protected lemma has_prod.prodable (h : has_prod f a) : prodable f := ‚ü®a, h‚ü©

/-- The constant one function has product `1`. -/
@[to_additive "The constant zero function has sum `0`."]
lemma has_prod_one : has_prod (Œª b, 1 : Œ≤ ‚Üí Œ±) 1 := by simp [has_prod, tendsto_const_nhds]

@[to_additive] lemma has_prod_empty [is_empty Œ≤] : has_prod f 1 := by convert has_prod_one

@[to_additive] lemma prodable_one : prodable (Œª b, 1 : Œ≤ ‚Üí Œ±) := has_prod_one.prodable

@[to_additive] lemma prodable_empty [is_empty Œ≤] : prodable f := has_prod_empty.prodable

@[to_additive] lemma tprod_eq_one_of_not_prodable (h : ¬¨ prodable f) : ‚àè' b, f b = 1 :=
by simp [tprod, h]

@[to_additive] lemma prodable_congr (hfg : ‚àÄ b, f b = g b) : prodable f ‚Üî prodable g :=
iff_of_eq (congr_arg prodable $ funext hfg)

@[to_additive] lemma prodable.congr (hf : prodable f) (hfg : ‚àÄ b, f b = g b) : prodable g :=
(prodable_congr hfg).mp hf

@[to_additive] lemma has_prod.has_prod_of_prod_eq {g : Œ≥ ‚Üí Œ±}
  (h_eq : ‚àÄ u, ‚àÉ v, ‚àÄ v', v ‚äÜ v' ‚Üí ‚àÉ u', u ‚äÜ u' ‚àß ‚àè x in u', g x = ‚àè b in v', f b)
  (hf : has_prod g a) :
  has_prod f a :=
le_trans (map_at_top_finset_prod_le_of_prod_eq h_eq) hf

@[to_additive] lemma has_prod_iff_has_prod {g : Œ≥ ‚Üí Œ±}
  (h‚ÇÅ : ‚àÄ u, ‚àÉ v, ‚àÄ v', v ‚äÜ v' ‚Üí ‚àÉ u', u ‚äÜ u' ‚àß ‚àè x in u', g x = ‚àè b in v', f b)
  (h‚ÇÇ : ‚àÄ v, ‚àÉ u, ‚àÄ u', u ‚äÜ u' ‚Üí ‚àÉ v', v ‚äÜ v' ‚àß ‚àè b in v', f b = ‚àè x in u', g x) :
  has_prod f a ‚Üî has_prod g a :=
‚ü®has_prod.has_prod_of_prod_eq h‚ÇÇ, has_prod.has_prod_of_prod_eq h‚ÇÅ‚ü©

@[to_additive] lemma function.injective.has_prod_iff {g : Œ≥ ‚Üí Œ≤} (hg : injective g)
  (hf : ‚àÄ x ‚àâ set.range g, f x = 1) :
  has_prod (f ‚àò g) a ‚Üî has_prod f a :=
by simp only [has_prod, tendsto, hg.map_at_top_finset_prod_eq hf]

@[to_additive] lemma function.injective.prodable_iff {g : Œ≥ ‚Üí Œ≤} (hg : injective g)
  (hf : ‚àÄ x ‚àâ set.range g, f x = 1) :
  prodable (f ‚àò g) ‚Üî prodable f :=
exists_congr $ Œª _, hg.has_prod_iff hf

@[to_additive]
lemma has_prod_subtype_iff_of_mul_support_subset {s : set Œ≤} (hf : mul_support f ‚äÜ s) :
  has_prod (f ‚àò coe : s ‚Üí Œ±) a ‚Üî has_prod f a :=
subtype.coe_injective.has_prod_iff $ by simpa using mul_support_subset_iff'.1 hf

@[to_additive] lemma has_prod_subtype_iff_mul_indicator {s : set Œ≤} :
  has_prod (f ‚àò coe : s ‚Üí Œ±) a ‚Üî has_prod (s.mul_indicator f) a :=
by rw [‚Üê set.mul_indicator_range_comp, subtype.range_coe,
  has_prod_subtype_iff_of_mul_support_subset set.mul_support_mul_indicator_subset]

@[to_additive] lemma prodable_subtype_iff_mul_indicator {s : set Œ≤} :
  prodable (f ‚àò coe : s ‚Üí Œ±) ‚Üî prodable (s.mul_indicator f) :=
exists_congr $ Œª _, has_prod_subtype_iff_mul_indicator

@[simp, to_additive]
lemma has_prod_subtype_support : has_prod (f ‚àò coe : mul_support f ‚Üí Œ±) a ‚Üî has_prod f a :=
has_prod_subtype_iff_of_mul_support_subset $ set.subset.refl _

@[to_additive] lemma has_prod_fintype [fintype Œ≤] (f : Œ≤ ‚Üí Œ±) : has_prod f (‚àè b, f b) :=
order_top.tendsto_at_top_nhds _

@[to_additive] protected lemma finset.has_prod (s : finset Œ≤) (f : Œ≤ ‚Üí Œ±) :
  has_prod (f ‚àò coe : (‚Üës : set Œ≤) ‚Üí Œ±) (‚àè b in s, f b) :=
by { rw ‚Üê prod_attach, exact has_prod_fintype _ }

@[to_additive] protected lemma finset.prodable (s : finset Œ≤) (f : Œ≤ ‚Üí Œ±) :
  prodable (f ‚àò coe : (‚Üës : set Œ≤) ‚Üí Œ±) :=
(s.has_prod f).prodable

@[to_additive] protected lemma set.finite.prodable {s : set Œ≤} (hs : s.finite) (f : Œ≤ ‚Üí Œ±) :
  prodable (f ‚àò coe : s ‚Üí Œ±) :=
by convert hs.to_finset.prodable f; simp only [hs.coe_to_finset]

/-- If a function `f` vanishes outside of a finite set `s`, then it `has_prod` `‚àè b in s, f b`. -/
@[to_additive
"If a function `f` vanishes outside of a finite set `s`, then it `has_sum` `‚àë b in s, f b`."]
lemma has_prod_prod_of_ne_finset_one (hf : ‚àÄ b ‚àâ s, f b = 1) : has_prod f (‚àè b in s, f b) :=
(has_prod_subtype_iff_of_mul_support_subset $ mul_support_subset_iff'.2 hf).1 $ s.has_prod f

@[to_additive] lemma prodable_of_ne_finset_one (hf : ‚àÄ b ‚àâ s, f b = 1) : prodable f :=
(has_prod_prod_of_ne_finset_one hf).prodable

@[to_additive] lemma has_prod_single (b : Œ≤) (hf : ‚àÄ b' ‚â† b, f b' = 1) : has_prod f (f b) :=
suffices has_prod f (‚àè b' in {b}, f b'),
  by simpa using this,
has_prod_prod_of_ne_finset_one $ by simpa [hf]

@[to_additive] lemma has_prod_ite_eq (b : Œ≤) [decidable_pred (= b)] (a : Œ±) :
  has_prod (Œª b', if b' = b then a else 1) a :=
begin
  convert has_prod_single b _,
  { exact (if_pos rfl).symm },
  { exact Œª b' hb', if_neg hb' }
end

@[to_additive] lemma has_prod_pi_mul_single [decidable_eq Œ≤] (b : Œ≤) (a : Œ±) :
  has_prod (pi.mul_single b a) a :=
show has_prod (Œª x, pi.mul_single b a x) a,
  by simpa only [pi.mul_single_apply] using has_prod_ite_eq b a

@[to_additive] lemma equiv.has_prod_iff (e : Œ≥ ‚âÉ Œ≤) : has_prod (f ‚àò e) a ‚Üî has_prod f a :=
e.injective.has_prod_iff $ by simp

@[to_additive] lemma function.injective.has_prod_range_iff {g : Œ≥ ‚Üí Œ≤} (hg : injective g) :
  has_prod (Œª x : set.range g, f x) a ‚Üî has_prod (f ‚àò g) a :=
(equiv.of_injective g hg).has_prod_iff.symm

@[to_additive] lemma equiv.prodable_iff (e : Œ≥ ‚âÉ Œ≤) : prodable (f ‚àò e) ‚Üî prodable f :=
exists_congr $ Œª a, e.has_prod_iff

@[to_additive summable.prod_symm]
lemma prodable.prod_symm {f : Œ≤ √ó Œ≥ ‚Üí Œ±} (hf : prodable f) : prodable (Œª p : Œ≥ √ó Œ≤, f p.swap) :=
(equiv.prod_comm Œ≥ Œ≤).prodable_iff.2 hf

@[to_additive] lemma equiv.has_prod_iff_of_support {g : Œ≥ ‚Üí Œ±} (e : mul_support f ‚âÉ mul_support g)
  (he : ‚àÄ x : mul_support f, g (e x) = f x) :
  has_prod f a ‚Üî has_prod g a :=
have (g ‚àò coe) ‚àò e = f ‚àò coe, from funext he,
by rw [‚Üê has_prod_subtype_support, ‚Üê this, e.has_prod_iff, has_prod_subtype_support]

@[to_additive] lemma has_prod_iff_has_prod_of_ne_one_bij {g : Œ≥ ‚Üí Œ±} (i : mul_support g ‚Üí Œ≤)
  (hi : ‚àÄ ‚¶Éx y‚¶Ñ, i x = i y ‚Üí (x : Œ≥) = y)
  (hf : mul_support f ‚äÜ set.range i) (hfg : ‚àÄ x, f (i x) = g x) :
  has_prod f a ‚Üî has_prod g a :=
iff.symm $ equiv.has_prod_iff_of_support
  (equiv.of_bijective (Œª x, ‚ü®i x, Œª hx, x.coe_prop $ hfg x ‚ñ∏ hx‚ü©)
    ‚ü®Œª x y h, subtype.ext $ hi $ subtype.ext_iff.1 h,
      Œª y, (hf y.coe_prop).imp $ Œª x hx, subtype.ext hx‚ü©)
  hfg

@[to_additive] lemma equiv.prodable_iff_of_mul_support {g : Œ≥ ‚Üí Œ±}
  (e : mul_support f ‚âÉ mul_support g) (he : ‚àÄ x : mul_support f, g (e x) = f x) :
  prodable f ‚Üî prodable g :=
exists_congr $ Œª _, e.has_prod_iff_of_support he

@[to_additive] protected lemma has_prod.map [comm_monoid Œ≥] [topological_space Œ≥]
  (hf : has_prod f a) [monoid_hom_class G Œ± Œ≥] (g : G) (hg : continuous g) :
  has_prod (g ‚àò f) (g a) :=
have g ‚àò (Œª s, ‚àè b in s, f b) = (Œª s, ‚àè b in s, g (f b)),
  from funext $ map_prod g _,
show tendsto (Œª s, ‚àè b in s, g (f b)) at_top (ùìù (g a)),
  from this ‚ñ∏ (hg.tendsto a).comp hf

@[to_additive] protected lemma prodable.map [comm_monoid Œ≥] [topological_space Œ≥]
  (hf : prodable f) [monoid_hom_class G Œ± Œ≥] (g : G) (hg : continuous g) :
  prodable (g ‚àò f) :=
(hf.has_prod.map g hg).prodable

@[to_additive] protected lemma prodable.map_iff_of_left_inverse [comm_monoid Œ≥]
  [topological_space Œ≥] [monoid_hom_class G Œ± Œ≥] [monoid_hom_class G' Œ≥ Œ±] (g : G) (g' : G')
  (hg : continuous g) (hg' : continuous g') (hinv : function.left_inverse g' g) :
  prodable (g ‚àò f) ‚Üî prodable f :=
‚ü®Œª h, by simpa only [‚Üêfunction.comp.assoc g', hinv.id] using h.map _ hg', Œª h, h.map _ hg‚ü©

/-- A special case of `prodable.map_iff_of_left_inverse` for convenience -/
@[to_additive "A special case of `summable.map_iff_of_left_inverse` for convenience"]
protected lemma prodable.map_iff_of_equiv [comm_monoid Œ≥] [topological_space Œ≥]
  [mul_equiv_class G Œ± Œ≥] (g : G) (hg : continuous g)
  (hg' : continuous (mul_equiv_class.inv g : Œ≥ ‚Üí Œ±)) :
  prodable (g ‚àò f) ‚Üî prodable f :=
prodable.map_iff_of_left_inverse g (g : Œ± ‚âÉ* Œ≥).symm hg hg' (mul_equiv_class.left_inv g)

/-- If `f : ‚Ñï ‚Üí Œ±` has product `a`, then the partial prods `‚àè_{i=1}^{n-1} f i` converge to `a`. -/
@[to_additive
"If `f : ‚Ñï ‚Üí Œ±` has sum `a`, then the partial sums `‚àë_{i=1}^{n-1} f i` converge to `a`."]
lemma has_prod.tendsto_prod_nat {f : ‚Ñï ‚Üí Œ±} (h : has_prod f a) :
  tendsto (Œª n, ‚àè i in range n, f i) at_top (ùìù a) :=
h.comp tendsto_finset_range

@[to_additive] lemma has_prod.unique [t2_space Œ±] : has_prod f a‚ÇÅ ‚Üí has_prod f a‚ÇÇ ‚Üí a‚ÇÅ = a‚ÇÇ :=
tendsto_nhds_unique

@[to_additive] lemma prodable.has_prod_iff_tendsto_nat [t2_space Œ±] {f : ‚Ñï ‚Üí Œ±} (hf : prodable f) :
  has_prod f a ‚Üî tendsto (Œª n, ‚àè i in range n, f i) at_top (ùìù a) :=
begin
  refine ‚ü®Œª h, h.tendsto_prod_nat, Œª h, _‚ü©,
  rw tendsto_nhds_unique h hf.has_prod.tendsto_prod_nat,
  exact hf.has_prod
end

@[to_additive] lemma function.surjective.prodable_iff_of_has_prod_iff [comm_monoid Œ±']
  [topological_space Œ±'] {e : Œ±' ‚Üí Œ±} (hes : surjective e) {g : Œ≥ ‚Üí Œ±'}
  (he : ‚àÄ {a}, has_prod f (e a) ‚Üî has_prod g a) :
  prodable f ‚Üî prodable g :=
hes.exists.trans $ exists_congr $ @he

variables [has_continuous_mul Œ±]

@[to_additive] lemma has_prod.mul (hf : has_prod f a) (hg : has_prod g b) :
  has_prod (Œª b, f b * g b) (a * b) :=
by simp only [has_prod, prod_mul_distrib]; exact hf.mul hg

@[to_additive] lemma prodable.mul (hf : prodable f) (hg : prodable g) :
  prodable (Œª b, f b * g b) :=
(hf.has_prod.mul hg.has_prod).prodable

@[to_additive] lemma has_prod_prod {f : Œ≥ ‚Üí Œ≤ ‚Üí Œ±} {a : Œ≥ ‚Üí Œ±} {s : finset Œ≥} :
  (‚àÄ i ‚àà s, has_prod (f i) (a i)) ‚Üí has_prod (Œª b, ‚àè i in s, f i b) (‚àè i in s, a i) :=
finset.induction_on s (by simp only [has_prod_one, prod_empty, forall_true_iff])
  (by simp only [has_prod.mul, prod_insert, mem_insert, forall_eq_or_imp,
        forall_2_true_iff, not_false_iff, forall_true_iff] {contextual := tt})

@[to_additive] lemma prodable_prod {f : Œ≥ ‚Üí Œ≤ ‚Üí Œ±} {s : finset Œ≥} (hf : ‚àÄ i ‚àà s, prodable (f i)) :
  prodable (Œª b, ‚àè i in s, f i b) :=
(has_prod_prod $ assume i hi, (hf i hi).has_prod).prodable

@[to_additive] lemma has_prod.mul_disjoint {s t : set Œ≤} (hs : disjoint s t)
  (ha : has_prod (f ‚àò coe : s ‚Üí Œ±) a) (hb : has_prod (f ‚àò coe : t ‚Üí Œ±) b) :
  has_prod (f ‚àò coe : s ‚à™ t ‚Üí Œ±) (a * b) :=
begin
  rw has_prod_subtype_iff_mul_indicator at *,
  rw set.mul_indicator_union_of_disjoint hs,
  exact ha.mul hb,
end

@[to_additive] lemma has_prod_prod_disjoint {Œπ} (s : finset Œπ) {t : Œπ ‚Üí set Œ≤} {a : Œπ ‚Üí Œ±}
  (hs : (s : set Œπ).pairwise (disjoint on t))
  (hf : ‚àÄ i ‚àà s, has_prod (f ‚àò coe : t i ‚Üí Œ±) (a i)) :
  has_prod (f ‚àò coe : (‚ãÉ i ‚àà s, t i) ‚Üí Œ±) (‚àè i in s, a i) :=
begin
  simp_rw has_prod_subtype_iff_mul_indicator at *,
  rw set.mul_indicator_finset_bUnion _ _ hs,
  exact has_prod_prod hf,
end

@[to_additive] lemma has_prod.mul_is_compl {s t : set Œ≤} (hs : is_compl s t)
  (ha : has_prod (f ‚àò coe : s ‚Üí Œ±) a) (hb : has_prod (f ‚àò coe : t ‚Üí Œ±) b) :
  has_prod f (a * b) :=
by simpa [‚Üê hs.compl_eq]
  using (has_prod_subtype_iff_mul_indicator.1 ha).mul (has_prod_subtype_iff_mul_indicator.1 hb)

@[to_additive] lemma has_prod.mul_compl {s : set Œ≤} (ha : has_prod (f ‚àò coe : s ‚Üí Œ±) a)
  (hb : has_prod (f ‚àò coe : s·∂ú ‚Üí Œ±) b) :
  has_prod f (a * b) :=
ha.mul_is_compl is_compl_compl hb

@[to_additive] lemma prodable.mul_compl {s : set Œ≤} (hs : prodable (f ‚àò coe : s ‚Üí Œ±))
  (hsc : prodable (f ‚àò coe : s·∂ú ‚Üí Œ±)) :
  prodable f :=
(hs.has_prod.mul_compl hsc.has_prod).prodable

@[to_additive] lemma has_prod.compl_mul {s : set Œ≤} (ha : has_prod (f ‚àò coe : s·∂ú ‚Üí Œ±) a)
  (hb : has_prod (f ‚àò coe : s ‚Üí Œ±) b) :
  has_prod f (a * b) :=
ha.mul_is_compl is_compl_compl.symm hb

@[to_additive] lemma has_prod.even_mul_odd {f : ‚Ñï ‚Üí Œ±} (he : has_prod (Œª k, f (2 * k)) a)
  (ho : has_prod (Œª k, f (2 * k + 1)) b) :
  has_prod f (a * b) :=
begin
  have := mul_right_injective‚ÇÄ (two_ne_zero' ‚Ñï),
  replace he := this.has_prod_range_iff.2 he,
  replace ho := ((add_left_injective 1).comp this).has_prod_range_iff.2 ho,
  refine he.mul_is_compl _ ho,
  simpa [(‚àò)] using nat.is_compl_even_odd
end

@[to_additive] lemma prodable.compl_mul {s : set Œ≤} (hs : prodable (f ‚àò coe : s·∂ú ‚Üí Œ±))
  (hsc : prodable (f ‚àò coe : s ‚Üí Œ±)) : prodable f :=
(hs.has_prod.compl_mul hsc.has_prod).prodable

@[to_additive] lemma prodable.even_mul_odd {f : ‚Ñï ‚Üí Œ±} (he : prodable (Œª k, f (2 * k)))
  (ho : prodable (Œª k, f (2 * k + 1))) : prodable f :=
(he.has_prod.even_mul_odd ho.has_prod).prodable

@[to_additive] lemma has_prod.sigma [regular_space Œ±] {Œ≥ : Œ≤ ‚Üí Type*} {f : (Œ£ b, Œ≥ b) ‚Üí Œ±}
  {g : Œ≤ ‚Üí Œ±} (ha : has_prod f a) (hf : ‚àÄ b, has_prod (Œª c, f ‚ü®b, c‚ü©) (g b)) : has_prod g a :=
begin
  refine (at_top_basis.tendsto_iff (closed_nhds_basis a)).mpr _,
  rintros s ‚ü®hs, hsc‚ü©,
  rcases mem_at_top_sets.mp (ha hs) with ‚ü®u, hu‚ü©,
  use [u.image sigma.fst, trivial],
  intros bs hbs,
  simp only [set.mem_preimage, ge_iff_le, finset.le_iff_subset] at hu,
  have : tendsto (Œª t : finset (Œ£ b, Œ≥ b), ‚àè p in t.filter (Œª p, p.1 ‚àà bs), f p)
    at_top (ùìù $ ‚àè b in bs, g b),
  { simp only [‚Üê sigma_preimage_mk, prod_sigma],
    refine tendsto_finset_prod _ (Œª b hb, _),
    change tendsto (Œª t, (Œª t, ‚àè s in t, f ‚ü®b, s‚ü©) (preimage t (sigma.mk b) _)) at_top (ùìù (g b)),
    exact tendsto.comp (hf b) (tendsto_finset_preimage_at_top_at_top _) },
  refine hsc.mem_of_tendsto this (eventually_at_top.2 ‚ü®u, Œª t ht, hu _ (Œª x hx, _)‚ü©),
  exact mem_filter.2 ‚ü®ht hx, hbs $ mem_image_of_mem _ hx‚ü©
end

/-- If a series `f` on `Œ≤ √ó Œ≥` has product `a` and for each `b` the restriction of `f` to `{b} √ó Œ≥`
has product `g b`, then the series `g` has product `a`. -/
@[to_additive has_sum.prod_fiberwise "If a series `f` on `Œ≤ √ó Œ≥` has sum `a` and for each `b` the
restriction of `f` to `{b} √ó Œ≥` has sum `g b`, then the series `g` has sum `a`."]
lemma has_prod.prod_fiberwise [regular_space Œ±] {f : Œ≤ √ó Œ≥ ‚Üí Œ±} (ha : has_prod f a)
  (hf : ‚àÄ b, has_prod (Œª c, f (b, c)) (g b)) : has_prod g a :=
has_prod.sigma ((equiv.sigma_equiv_prod Œ≤ Œ≥).has_prod_iff.2 ha) hf

@[to_additive] lemma prodable.sigma' [regular_space Œ±] {Œ≥ : Œ≤ ‚Üí Type*}
  {f : (Œ£ b, Œ≥ b) ‚Üí Œ±} (ha : prodable f) (hf : ‚àÄ b, prodable (Œª c, f ‚ü®b, c‚ü©)) :
  prodable (Œª b, ‚àè' c, f ‚ü®b, c‚ü©) :=
(ha.has_prod.sigma $ Œª b, (hf b).has_prod).prodable

@[to_additive] lemma has_prod.sigma_of_has_prod [t3_space Œ±] {Œ≥ : Œ≤ ‚Üí Type*} {f : (Œ£ b, Œ≥ b) ‚Üí Œ±}
  (ha : has_prod g a) (hf : ‚àÄ b, has_prod (Œª c, f ‚ü®b, c‚ü©) (g b)) (hf' : prodable f) :
  has_prod f a :=
by simpa [(hf'.has_prod.sigma hf).unique ha] using hf'.has_prod

/-- Version of `has_prod.update` for `comm_monoid` rather than `comm_group`.
Rather than showing that `f.update` has a specific sum in terms of `has_prod`,
it gives a relationship between the sums of `f` and `f.update` given that both exist. -/
@[to_additive "Version of `has_sum.update` for `add_comm_monoid` rather than `add_comm_group`.
Rather than showing that `f.update` has a specific sum in terms of `has_sum`,
it gives a relationship between the sums of `f` and `f.update` given that both exist."]
lemma has_prod.update' [t2_space Œ±] {f : Œ≤ ‚Üí Œ±} (hf : has_prod f a) (b : Œ≤) (x : Œ±)
  (hf' : has_prod (f.update b x) a') : a * x = a' * f b :=
begin
  have : ‚àÄ b', f b' * ite (b' = b) x 1 = f.update b x b' * ite (b' = b) (f b) 1,
  { intro b',
    split_ifs with hb',
    { simpa only [function.update_apply, hb', eq_self_iff_true] using mul_comm (f b) x },
    { simp only [function.update_apply, hb', if_false] } },
  have h := hf.mul ((has_prod_ite_eq b x)),
  simp_rw this at h,
  exact has_prod.unique h (hf'.mul $ has_prod_ite_eq b (f b)),
end

/-- Version of `has_prod_ite_div_has_prod` for `comm_monoid` rather than `comm_group`.
Rather than showing that the `ite` expression has a specific sum in terms of `has_prod`,
it gives a relationship between the sums of `f` and `ite (n = b) 1 (f n)` given that both exist. -/
@[to_additive
"Version of `has_sum_ite_sub_has_sum` for `add_comm_monoid` rather than `add_comm_group`.
Rather than showing that the `ite` expression has a specific sum in terms of `has_sum`,
it gives a relationship between the sums of `f` and `ite (n = b) 0 (f n)` given that both exist."]
lemma eq_mul_of_has_prod_ite [t2_space Œ±] (hf : has_prod f a) (b : Œ≤) (a' : Œ±)
  (hf' : has_prod (Œª n, ite (n = b) 1 (f n)) a') : a = a' * f b :=
begin
  refine (mul_one a).symm.trans (hf.update' b 1 _),
  convert hf',
  exact funext (f.update_apply b 1),
end

end has_prod

section has_continuous_star
variables [add_comm_monoid Œ±] [topological_space Œ±] [star_add_monoid Œ±] [has_continuous_star Œ±]
  {f : Œ≤ ‚Üí Œ±} {a : Œ±}

lemma has_sum.star (h : has_sum f a) : has_sum (Œª b, star (f b)) (star a) :=
by simpa only using h.map (star_add_equiv : Œ± ‚âÉ+ Œ±) continuous_star

lemma summable.star (hf : summable f) : summable (Œª b, star (f b)) :=
hf.has_sum.star.summable

lemma summable.of_star (hf : summable (Œª b, star (f b))) : summable f :=
by simpa only [star_star] using hf.star

@[simp] lemma summable_star_iff : summable (Œª b, star (f b)) ‚Üî summable f :=
‚ü®summable.of_star, summable.star‚ü©

@[simp] lemma summable_star_iff' : summable (star f) ‚Üî summable f := summable_star_iff

end has_continuous_star

section tprod
variables [comm_monoid Œ±] [topological_space Œ±] {f g : Œ≤ ‚Üí Œ±} {a a‚ÇÅ a‚ÇÇ : Œ±}

@[to_additive] lemma tprod_congr_subtype (f : Œ≤ ‚Üí Œ±) {s t : set Œ≤} (h : s = t) :
  ‚àè' x : s, f x = ‚àè' x : t, f x := by rw h

@[to_additive] lemma tprod_one' (hz : is_closed ({1} : set Œ±)) : ‚àè' b : Œ≤, (1 : Œ±) = 1 :=
begin
  classical,
  rw [tprod, dif_pos prodable_one],
  suffices : ‚àÄ (x : Œ±), has_prod (Œª (b : Œ≤), (1 : Œ±)) x ‚Üí x = 1,
  { exact this _ (classical.some_spec _) },
  intros x hx,
  contrapose! hx,
  simp only [has_prod, tendsto_nhds, finset.prod_const_one, filter.mem_at_top_sets, ge_iff_le,
              finset.le_eq_subset, set.mem_preimage, not_forall, not_exists, exists_prop,
              exists_and_distrib_right],
  refine ‚ü®{1}·∂ú, ‚ü®is_open_compl_iff.mpr hz, _‚ü©, Œª y, ‚ü®‚ü®y, subset_refl _‚ü©, _‚ü©‚ü©,
  { simpa using hx },
  { simp }
end

@[simp, to_additive] lemma tprod_one [t1_space Œ±] : ‚àè' b : Œ≤, (1 : Œ±) = 1 :=
tprod_one' is_closed_singleton

@[to_additive] lemma tprod_congr (hfg : ‚àÄ b, f b = g b) : ‚àè' b, f b = ‚àè' b, g b :=
congr_arg tprod $ funext hfg

variables [t2_space Œ±] {s : finset Œ≤}

@[to_additive] lemma has_prod.tprod_eq (ha : has_prod f a) : ‚àè' b, f b = a :=
(prodable.has_prod ‚ü®a, ha‚ü©).unique ha

@[to_additive] lemma prodable.has_prod_iff (h : prodable f) : has_prod f a ‚Üî ‚àè' b, f b = a :=
iff.intro has_prod.tprod_eq (assume eq, eq ‚ñ∏ h.has_prod)

@[simp, to_additive] lemma tprod_empty [is_empty Œ≤] : ‚àè' b, f b = 1 := has_prod_empty.tprod_eq

@[to_additive] lemma tprod_eq_prod (hf : ‚àÄ b ‚àâ s, f b = 1) : ‚àè' b, f b = ‚àè b in s, f b :=
(has_prod_prod_of_ne_finset_one hf).tprod_eq

@[to_additive] lemma prod_eq_tprod_mul_indicator (f : Œ≤ ‚Üí Œ±) (s : finset Œ≤) :
  ‚àè x in s, f x = ‚àè' x, set.mul_indicator ‚Üës f x :=
have ‚àÄ x ‚àâ s, set.mul_indicator ‚Üës f x = 1,
from Œª x hx, set.mul_indicator_apply_eq_one.2 (Œª hx', (hx $ finset.mem_coe.1 hx').elim),
(finset.prod_congr rfl (Œª x hx, (set.mul_indicator_apply_eq_self.2 $
  Œª hx', (hx' $ finset.mem_coe.2 hx).elim).symm)).trans (tprod_eq_prod this).symm

@[to_additive] lemma tprod_fintype [fintype Œ≤] (f : Œ≤ ‚Üí Œ±) : ‚àè' b, f b = ‚àè b, f b :=
(has_prod_fintype f).tprod_eq

@[to_additive] lemma tprod_bool (f : bool ‚Üí Œ±) : ‚àè' i : bool, f i = f false * f true :=
by rw [tprod_fintype, finset.prod_eq_mul]; simp

@[to_additive] lemma tprod_eq_single (b : Œ≤) (hf : ‚àÄ b' ‚â† b, f b' = 1) : ‚àè' b, f b = f b :=
(has_prod_single b hf).tprod_eq

@[to_additive] lemma tprod_tprod_eq_single (f : Œ≤ ‚Üí Œ≥ ‚Üí Œ±) (b : Œ≤) (c : Œ≥)
  (hfb : ‚àÄ b' ‚â† b, f b' c = 1) (hfc : ‚àÄ b' c', c' ‚â† c ‚Üí f b' c' = 1) :
  ‚àè' b' c', f b' c' = f b c :=
calc ‚àè' b' c', f b' c' = ‚àè' b', f b' c : tprod_congr $ Œª b', tprod_eq_single _ (hfc b')
... = f b c : tprod_eq_single _ hfb

@[simp, to_additive] lemma tprod_ite_eq (b : Œ≤) [decidable_pred (= b)] (a : Œ±) :
  ‚àè' b', (if b' = b then a else 1) = a :=
(has_prod_ite_eq b a).tprod_eq

@[simp, to_additive] lemma tprod_pi_mul_single [decidable_eq Œ≤] (b : Œ≤) (a : Œ±) :
  ‚àè' b', pi.mul_single b a b' = a :=
(has_prod_pi_mul_single b a).tprod_eq

@[to_additive] lemma tprod_dite_right (P : Prop) [decidable P] (x : Œ≤ ‚Üí ¬¨ P ‚Üí Œ±) :
  ‚àè' b, (if h : P then (1 : Œ±) else x b h) = if h : P then (1 : Œ±) else ‚àè' b, x b h :=
by by_cases hP : P; simp [hP]

@[to_additive] lemma tprod_dite_left (P : Prop) [decidable P] (x : Œ≤ ‚Üí P ‚Üí Œ±) :
  ‚àè' b, (if h : P then x b h else 1) = if h : P then (‚àè' b, x b h) else 1 :=
by by_cases hP : P; simp [hP]

@[to_additive] lemma function.surjective.tprod_eq_tprod_of_has_prod_iff_has_prod [comm_monoid Œ±']
  [topological_space Œ±'] {e : Œ±' ‚Üí Œ±} (hes : function.surjective e) (h1 : e 1 = 1) {g : Œ≥ ‚Üí Œ±'}
  (h : ‚àÄ {a}, has_prod f (e a) ‚Üî has_prod g a) :
  ‚àè' b, f b = e (‚àè' c, g c) :=
by_cases
  (assume : prodable g, (h.mpr this.has_prod).tprod_eq)
  (assume hg : ¬¨ prodable g,
    have hf : ¬¨ prodable f, from mt (hes.prodable_iff_of_has_prod_iff @h).1 hg,
    by simp [tprod, hf, hg, h1])

@[to_additive]
lemma tprod_eq_tprod_of_has_prod_iff_has_prod {g : Œ≥ ‚Üí Œ±} (h : ‚àÄ {a}, has_prod f a ‚Üî has_prod g a) :
  ‚àè' b, f b = ‚àè'c, g c :=
surjective_id.tprod_eq_tprod_of_has_prod_iff_has_prod rfl @h

@[to_additive equiv.tsum_eq] lemma equiv.tprod_eq (j : Œ≥ ‚âÉ Œ≤) (f : Œ≤ ‚Üí Œ±) :
  ‚àè'c, f (j c) = ‚àè' b, f b :=
tprod_eq_tprod_of_has_prod_iff_has_prod $ Œª a, j.has_prod_iff

@[to_additive] lemma equiv.tprod_eq_tprod_of_mul_support {g : Œ≥ ‚Üí Œ±}
  (e : mul_support f ‚âÉ mul_support g) (he : ‚àÄ x, g (e x) = f x) :
  (‚àè' x, f x) = ‚àè' y, g y :=
tprod_eq_tprod_of_has_prod_iff_has_prod $ Œª _, e.has_prod_iff_of_support he

@[to_additive]
lemma tprod_eq_tprod_of_ne_one_bij {g : Œ≥ ‚Üí Œ±} (i : mul_support g ‚Üí Œ≤)
  (hi : ‚àÄ ‚¶Éx y‚¶Ñ, i x = i y ‚Üí (x : Œ≥) = y) (hf : mul_support f ‚äÜ set.range i)
  (hfg : ‚àÄ x, f (i x) = g x) :
  ‚àè' x, f x  = ‚àè' y, g y :=
tprod_eq_tprod_of_has_prod_iff_has_prod $ Œª _, has_prod_iff_has_prod_of_ne_one_bij i hi hf hfg

/-! ### `tprod` on subsets -/

@[simp, to_additive] lemma finset.tprod_subtype (s : finset Œ≤) (f : Œ≤ ‚Üí Œ±) :
  ‚àè' x : {x // x ‚àà s}, f x = ‚àè x in s, f x :=
(s.has_prod f).tprod_eq

@[simp, to_additive] lemma finset.tprod_subtype' (s : finset Œ≤) (f : Œ≤ ‚Üí Œ±) :
  ‚àè' x : (s : set Œ≤), f x = ‚àè x in s, f x :=
s.tprod_subtype f

@[to_additive] lemma tprod_subtype (s : set Œ≤) (f : Œ≤ ‚Üí Œ±) :
  ‚àè' x : s, f x = ‚àè' x, s.mul_indicator f x :=
tprod_eq_tprod_of_has_prod_iff_has_prod $ Œª _, has_prod_subtype_iff_mul_indicator

@[to_additive]
lemma tprod_subtype_eq_of_mul_support_subset {s : set Œ≤} (hs : mul_support f ‚äÜ s) :
  ‚àè' x : s, f x = ‚àè' x, f x :=
tprod_eq_tprod_of_has_prod_iff_has_prod $ Œª x, has_prod_subtype_iff_of_mul_support_subset hs

@[simp, to_additive] lemma tprod_univ (f : Œ≤ ‚Üí Œ±) :
  ‚àè' x : (set.univ : set Œ≤), f x = ‚àè' x, f x :=
tprod_subtype_eq_of_mul_support_subset $ set.subset_univ _

@[simp, to_additive] lemma tprod_singleton (b : Œ≤) (f : Œ≤ ‚Üí Œ±) : ‚àè' x : ({b} : set Œ≤), f x = f b :=
begin
  rw [tprod_subtype, tprod_eq_single b],
  { simp },
  { intros b' hb',
    rw set.mul_indicator_of_not_mem,
    rwa set.mem_singleton_iff },
  { apply_instance }
end

@[to_additive] lemma tprod_image {g : Œ≥ ‚Üí Œ≤} (f : Œ≤ ‚Üí Œ±) {s : set Œ≥} (hg : set.inj_on g s) :
  ‚àè' x : g '' s, f x = ‚àè' x : s, f (g x) :=
((equiv.set.image_of_inj_on _ _ hg).tprod_eq (Œª x, f x)).symm

@[to_additive] lemma tprod_range {g : Œ≥ ‚Üí Œ≤} (f : Œ≤ ‚Üí Œ±) (hg : injective g) :
  ‚àè' x : set.range g, f x = ‚àè' x, f (g x) :=
by rw [‚Üê set.image_univ, tprod_image f (hg.inj_on _), tprod_univ (f ‚àò g)]

section has_continuous_mul
variable [has_continuous_mul Œ±]

@[to_additive] lemma tprod_mul (hf : prodable f) (hg : prodable g) :
  ‚àè' b, f b * g b = (‚àè' b, f b) * (‚àè' b, g b) :=
(hf.has_prod.mul hg.has_prod).tprod_eq

@[to_additive tsum_sum]
lemma tprod_prod'' {f : Œ≥ ‚Üí Œ≤ ‚Üí Œ±} {s : finset Œ≥} (hf : ‚àÄ i ‚àà s, prodable (f i)) :
  ‚àè' b, ‚àè i in s, f i b = ‚àè i in s, ‚àè' b, f i b :=
(has_prod_prod $ Œª i hi, (hf i hi).has_prod).tprod_eq

/-- Version of `tprod_eq_mul_tprod_ite` for `comm_monoid` rather than `comm_group`.
Requires a different convergence assumption involving `function.update`. -/
@[to_additive "Version of `tsum_eq_mul_tsum_ite` for `add_comm_monoid` rather
than `add_comm_group`. Requires a different convergence assumption involving `function.update`."]
lemma tprod_eq_mul_tprod_ite' (b : Œ≤) (hf : prodable (f.update b 1)) :
  ‚àè' x, f x = f b * ‚àè' x, ite (x = b) 1 (f x) :=
calc ‚àè' x, f x = ‚àè' x, ((ite (x = b) (f x) 1) * (f.update b 1 x)) :
    tprod_congr (Œª n, by split_ifs; simp [function.update_apply, h])
  ... = (‚àè' x, ite (x = b) (f x) 1) * ‚àè' x, f.update b 1 x :
    tprod_mul ‚ü®ite (b = b) (f b) 1, has_prod_single b (Œª b hb, if_neg hb)‚ü© hf
  ... = ite (b = b) (f b) 1 * ‚àè' x, f.update b 1 x :
    by { congr, exact (tprod_eq_single b (Œª b' hb', if_neg hb')) }
  ... = f b * ‚àè' x, ite (x = b) 1 (f x) :
    by simp only [function.update, eq_self_iff_true, if_true, eq_rec_constant, dite_eq_ite]

variables [comm_monoid Œ¥] [topological_space Œ¥] [t3_space Œ¥] [has_continuous_mul Œ¥]

@[to_additive]
lemma tprod_sigma' {Œ≥ : Œ≤ ‚Üí Type*} {f : (Œ£ b, Œ≥ b) ‚Üí Œ¥} (h‚ÇÅ : ‚àÄ b, prodable (Œª c, f ‚ü®b, c‚ü©))
  (h‚ÇÇ : prodable f) : ‚àè' p, f p = ‚àè' b c, f ‚ü®b, c‚ü© :=
(h‚ÇÇ.has_prod.sigma $ Œª b, (h‚ÇÅ b).has_prod).tprod_eq.symm

@[to_additive]
lemma tprod_prod' {f : Œ≤ √ó Œ≥ ‚Üí Œ¥} (h : prodable f) (h‚ÇÅ : ‚àÄ b, prodable (Œª c, f (b, c))) :
  ‚àè' p, f p = ‚àè' b c, f (b, c) :=
(h.has_prod.prod_fiberwise $ Œª b, (h‚ÇÅ b).has_prod).tprod_eq.symm

@[to_additive]
lemma tprod_comm' {f : Œ≤ ‚Üí Œ≥ ‚Üí Œ¥} (h : prodable (uncurry f)) (h‚ÇÅ : ‚àÄ b, prodable (f b))
  (h‚ÇÇ : ‚àÄ c, prodable (Œª b, f b c)) :
  ‚àè' c b, f b c = ‚àè' b c, f b c :=
begin
  erw [‚Üêtprod_prod' h h‚ÇÅ, ‚Üêtprod_prod' h.prod_symm h‚ÇÇ, ‚Üê(equiv.prod_comm Œ≥ Œ≤).tprod_eq (uncurry f)],
  refl
end

end has_continuous_mul

open encodable

section encodable
variable [encodable Œ≥]

/-- You can compute a product over an encodable type by multiplying over the natural numbers and
taking a supremum. This is useful for outer measures. -/
@[to_additive "You can compute a sum over an encodable type by summing over the natural numbers and
taking a supremum. This is useful for outer measures."]
lemma tprod_supr_decode‚ÇÇ [complete_lattice Œ≤] (m : Œ≤ ‚Üí Œ±) (m1 : m ‚ä• = 1) (s : Œ≥ ‚Üí Œ≤) :
  ‚àè' i : ‚Ñï, m (‚®Ü b ‚àà decode‚ÇÇ Œ≥ i, s b) = ‚àè' b : Œ≥, m (s b) :=
begin
  have H : ‚àÄ n, m (‚®Ü b ‚àà decode‚ÇÇ Œ≥ n, s b) ‚â† 1 ‚Üí (decode‚ÇÇ Œ≥ n).is_some,
  { intros n h,
    cases decode‚ÇÇ Œ≥ n with b,
    { refine (h $ by simp [m1]).elim },
    { exact rfl } },
  symmetry, refine tprod_eq_tprod_of_ne_one_bij (Œª a, option.get (H a.1 a.2)) _ _ _,
  { rintros ‚ü®m, hm‚ü© ‚ü®n, hn‚ü© e,
    have := mem_decode‚ÇÇ.1 (option.get_mem (H n hn)),
    rwa [‚Üê e, mem_decode‚ÇÇ.1 (option.get_mem (H m hm))] at this },
  { intros b h,
    refine ‚ü®‚ü®encode b, _‚ü©, _‚ü©,
    { simp only [mem_mul_support, encodek‚ÇÇ] at h ‚ä¢, convert h, simp [set.ext_iff, encodek‚ÇÇ] },
    { exact option.get_of_mem _ (encodek‚ÇÇ _) } },
  { rintros ‚ü®n, h‚ü©, dsimp only [subtype.coe_mk],
    transitivity, swap,
    rw [show decode‚ÇÇ Œ≥ n = _, from option.get_mem (H n h)],
    congr, simp [ext_iff, -option.some_get] }
end

/-- `tprod_supr_decode‚ÇÇ` specialized to the complete lattice of sets. -/
@[to_additive "`tsum_supr_decode‚ÇÇ` specialized to the complete lattice of sets."]
lemma tprod_Union_decode‚ÇÇ (m : set Œ≤ ‚Üí Œ±) (m1 : m ‚àÖ = 1) (s : Œ≥ ‚Üí set Œ≤) :
  ‚àè' i, m (‚ãÉ b ‚àà decode‚ÇÇ Œ≥ i, s b) = ‚àè' b, m (s b) :=
tprod_supr_decode‚ÇÇ m m1 s

end encodable

/-! Some properties about measure-like functions.
  These could also be functions defined on complete sublattices of sets, with the property
  that they are countably sub-additive.
  `R` will probably be instantiated with `(‚â§)` in all applications.
-/

section countable
variables [countable Œ≥]

/-- If a function is countably submultiplicative then it is submultiplicative on countable types. -/
@[to_additive
"If a function is countably subadditive then it is subadditive on countable types."]
lemma rel_supr_tprod [complete_lattice Œ≤] (m : Œ≤ ‚Üí Œ±) (m1 : m ‚ä• = 1) (R : Œ± ‚Üí Œ± ‚Üí Prop)
  (m_supr : ‚àÄ s : ‚Ñï ‚Üí Œ≤, R (m (‚®Ü i, s i)) ‚àè' i, m (s i)) (s : Œ≥ ‚Üí Œ≤) :
  R (m (‚®Ü b : Œ≥, s b)) ‚àè' b : Œ≥, m (s b) :=
by { casesI nonempty_encodable Œ≥, rw [‚Üêsupr_decode‚ÇÇ, ‚Üêtprod_supr_decode‚ÇÇ _ m1 s], exact m_supr _ }

/-- If a function is countably submultiplicative then it is submultiplicative on finite sets. -/
@[to_additive "If a function is countably subadditive then it is subadditive on finite sets."]
lemma rel_supr_prod [complete_lattice Œ≤] (m : Œ≤ ‚Üí Œ±) (m1 : m ‚ä• = 1) (R : Œ± ‚Üí Œ± ‚Üí Prop)
  (m_supr : ‚àÄ s : ‚Ñï ‚Üí Œ≤, R (m (‚®Ü i, s i)) (‚àè' i, m (s i))) (s : Œ¥ ‚Üí Œ≤) (t : finset Œ¥) :
  R (m (‚®Ü d ‚àà t, s d)) (‚àè d in t, m (s d)) :=
by { rw [supr_subtype', ‚Üêfinset.tprod_subtype], exact rel_supr_tprod m m1 R m_supr _ }

/-- If a function is countably submultiplicative then it is binary submultiplicative. -/
@[to_additive "If a function is countably subadditive then it is binary subadditive."]
lemma rel_sup_mul [complete_lattice Œ≤] (m : Œ≤ ‚Üí Œ±) (m1 : m ‚ä• = 1) (R : Œ± ‚Üí Œ± ‚Üí Prop)
  (m_supr : ‚àÄ s : ‚Ñï ‚Üí Œ≤, R (m (‚®Ü i, s i)) (‚àè' i, m (s i))) (s‚ÇÅ s‚ÇÇ : Œ≤) :
  R (m (s‚ÇÅ ‚äî s‚ÇÇ)) (m s‚ÇÅ * m s‚ÇÇ) :=
begin
  convert rel_supr_tprod m m1 R m_supr (Œª b, cond b s‚ÇÅ s‚ÇÇ),
  { simp only [supr_bool_eq, cond] },
  { rw [tprod_fintype, fintype.prod_bool, cond, cond] }
end

end countable

variables [has_continuous_mul Œ±]

@[to_additive] lemma tprod_mul_tprod_compl {s : set Œ≤} (hs : prodable (f ‚àò coe : s ‚Üí Œ±))
  (hsc : prodable (f ‚àò coe : s·∂ú ‚Üí Œ±)) :
  (‚àè' x : s, f x) * (‚àè' x : s·∂ú, f x) = ‚àè' x, f x :=
(hs.has_prod.mul_compl hsc.has_prod).tprod_eq.symm

@[to_additive] lemma tprod_union_disjoint {s t : set Œ≤} (hd : disjoint s t)
  (hs : prodable (f ‚àò coe : s ‚Üí Œ±)) (ht : prodable (f ‚àò coe : t ‚Üí Œ±)) :
  (‚àè' x : s ‚à™ t, f x) = (‚àè' x : s, f x) * (‚àè' x : t, f x) :=
(hs.has_prod.mul_disjoint hd ht.has_prod).tprod_eq

@[to_additive] lemma tprod_finset_bUnion_disjoint {Œπ} {s : finset Œπ} {t : Œπ ‚Üí set Œ≤}
  (hd : (s : set Œπ).pairwise (disjoint on t))
  (hf : ‚àÄ i ‚àà s, prodable (f ‚àò coe : t i ‚Üí Œ±)) :
  ‚àè' x : (‚ãÉ i ‚àà s, t i), f x = ‚àè i in s, ‚àè' x : t i, f x :=
(has_prod_prod_disjoint _ hd (Œª i hi, (hf i hi).has_prod)).tprod_eq

@[to_additive] lemma tprod_even_mul_odd {f : ‚Ñï ‚Üí Œ±} (he : prodable (Œª k, f (2 * k)))
  (ho : prodable (Œª k, f (2 * k + 1))) :
  (‚àè' k, f (2 * k)) * (‚àè' k, f (2 * k + 1)) = ‚àè' k, f k :=
(he.has_prod.even_mul_odd ho.has_prod).tprod_eq.symm

end tprod

section has_continuous_star
variables [add_comm_monoid Œ±] [topological_space Œ±] [star_add_monoid Œ±] [has_continuous_star Œ±]
  [t2_space Œ±] {f : Œ≤ ‚Üí Œ±}

lemma tsum_star : star (‚àë' b, f b) = ‚àë' b, star (f b) :=
begin
  by_cases hf : summable f,
  { exact hf.has_sum.star.tsum_eq.symm },
  { rw [tsum_eq_zero_of_not_summable hf, tsum_eq_zero_of_not_summable (mt summable.of_star hf),
      star_zero] }
end

end has_continuous_star

section prod
variables [comm_monoid Œ±] [topological_space Œ±] [comm_monoid Œ≥] [topological_space Œ≥]

@[to_additive has_sum.prod_mk]
lemma has_prod.prod_mk {f : Œ≤ ‚Üí Œ±} {g : Œ≤ ‚Üí Œ≥} {a : Œ±} {b : Œ≥}
  (hf : has_prod f a) (hg : has_prod g b) :
  has_prod (Œª x, (‚ü®f x, g x‚ü© : Œ± √ó Œ≥)) ‚ü®a, b‚ü© :=
by simp [has_prod, ‚Üê prod_mk_prod, hf.prod_mk_nhds hg]

end prod

section pi
variables {Œπ : Type*} {œÄ : Œ± ‚Üí Type*} [‚àÄ x, comm_monoid (œÄ x)] [‚àÄ x, topological_space (œÄ x)]
  {f : Œπ ‚Üí ‚àÄ x, œÄ x}

@[to_additive] lemma pi.has_prod {g : ‚àÄ x, œÄ x} : has_prod f g ‚Üî ‚àÄ x, has_prod (Œª i, f i x) (g x) :=
by simp only [has_prod, tendsto_pi_nhds, prod_apply]

@[to_additive pi.summable] lemma pi.prodable : prodable f ‚Üî ‚àÄ x, prodable (Œª i, f i x) :=
by simp only [prodable, pi.has_prod, skolem]

@[to_additive] lemma tprod_apply [‚àÄ x, t2_space (œÄ x)] {x : Œ±} (hf : prodable f) :
  (‚àè' i, f i) x = ‚àè' i, f i x :=
(pi.has_prod.1 hf.has_prod x).tprod_eq.symm

end pi

section mul_opposite
open mul_opposite
variables [add_comm_monoid Œ±] [topological_space Œ±] {f : Œ≤ ‚Üí Œ±} {a : Œ±}

lemma has_sum.op (hf : has_sum f a) : has_sum (Œª a, op (f a)) (op a) :=
(hf.map (@op_add_equiv Œ± _) continuous_op : _)

lemma summable.op (hf : summable f) : summable (op ‚àò f) := hf.has_sum.op.summable

lemma has_sum.unop {f : Œ≤ ‚Üí Œ±·µê·µí·µñ} {a : Œ±·µê·µí·µñ} (hf : has_sum f a) :
  has_sum (Œª a, unop (f a)) (unop a) :=
(hf.map (@op_add_equiv Œ± _).symm continuous_unop : _)

lemma summable.unop {f : Œ≤ ‚Üí Œ±·µê·µí·µñ} (hf : summable f) : summable (unop ‚àò f) :=
hf.has_sum.unop.summable

@[simp] lemma has_sum_op : has_sum (Œª a, op (f a)) (op a) ‚Üî has_sum f a :=
‚ü®has_sum.unop, has_sum.op‚ü©

@[simp] lemma has_sum_unop {f : Œ≤ ‚Üí Œ±·µê·µí·µñ} {a : Œ±·µê·µí·µñ} :
  has_sum (Œª a, unop (f a)) (unop a) ‚Üî has_sum f a :=
‚ü®has_sum.op, has_sum.unop‚ü©

@[simp] lemma summable_op : summable (Œª a, op (f a)) ‚Üî summable f := ‚ü®summable.unop, summable.op‚ü©

@[simp] lemma summable_unop {f : Œ≤ ‚Üí Œ±·µê·µí·µñ} : summable (Œª a, unop (f a)) ‚Üî summable f :=
‚ü®summable.op, summable.unop‚ü©

variables [t2_space Œ±]

lemma tsum_op : ‚àë' x, mul_opposite.op (f x) = mul_opposite.op (‚àë' x, f x) :=
begin
  by_cases h : summable f,
  { exact h.has_sum.op.tsum_eq },
  { have ho := summable_op.not.mpr h,
    rw [tsum_eq_zero_of_not_summable h, tsum_eq_zero_of_not_summable ho, mul_opposite.op_zero] }
end

lemma tsum_unop {f : Œ≤ ‚Üí Œ±·µê·µí·µñ} : ‚àë' x, mul_opposite.unop (f x) = mul_opposite.unop (‚àë' x, f x) :=
mul_opposite.op_injective tsum_op.symm

end mul_opposite

section add_opposite
open add_opposite
variables [comm_monoid Œ±] [topological_space Œ±] {f : Œ≤ ‚Üí Œ±} {a : Œ±}

lemma has_prod.op (hf : has_prod f a) : has_prod (Œª a, op (f a)) (op a) :=
(hf.map (@op_mul_equiv Œ± _) continuous_op : _)

lemma prodable.op (hf : prodable f) : prodable (op ‚àò f) := hf.has_prod.op.prodable

lemma has_prod.unop {f : Œ≤ ‚Üí Œ±·µÉ·µí·µñ} {a : Œ±·µÉ·µí·µñ} (hf : has_prod f a) :
  has_prod (Œª a, unop (f a)) (unop a) :=
(hf.map (@op_mul_equiv Œ± _).symm continuous_unop : _)

lemma prodable.unop {f : Œ≤ ‚Üí Œ±·µÉ·µí·µñ} (hf : prodable f) : prodable (unop ‚àò f) :=
hf.has_prod.unop.prodable

@[simp] lemma has_prod_op : has_prod (Œª a, op (f a)) (op a) ‚Üî has_prod f a :=
‚ü®has_prod.unop, has_prod.op‚ü©

@[simp] lemma has_prod_unop {f : Œ≤ ‚Üí Œ±·µÉ·µí·µñ} {a : Œ±·µÉ·µí·µñ} :
  has_prod (Œª a, unop (f a)) (unop a) ‚Üî has_prod f a :=
‚ü®has_prod.op, has_prod.unop‚ü©

@[simp] lemma prodable_op : prodable (Œª a, op (f a)) ‚Üî prodable f :=
‚ü®prodable.unop, prodable.op‚ü©

@[simp] lemma prodable_unop {f : Œ≤ ‚Üí Œ±·µÉ·µí·µñ} : prodable (Œª a, unop (f a)) ‚Üî prodable f :=
‚ü®prodable.op, prodable.unop‚ü©

variables [t2_space Œ±]

lemma tprod_op : ‚àè' x, add_opposite.op (f x) = add_opposite.op (‚àè' x, f x) :=
begin
  by_cases h : prodable f,
  { exact h.has_prod.op.tprod_eq },
  { have ho := prodable_op.not.mpr h,
    rw [tprod_eq_one_of_not_prodable h, tprod_eq_one_of_not_prodable ho, add_opposite.op_one] }
end

lemma tprod_unop {f : Œ≤ ‚Üí Œ±·µÉ·µí·µñ} : ‚àè' x, add_opposite.unop (f x) = add_opposite.unop (‚àè' x, f x) :=
add_opposite.op_injective tprod_op.symm

end add_opposite

section topological_group
variables [comm_group Œ±] [topological_space Œ±] [topological_group Œ±] {f g : Œ≤ ‚Üí Œ±} {a a‚ÇÅ a‚ÇÇ : Œ±}

-- `by simpa using` speeds up elaboration. Why?
@[to_additive] lemma has_prod.inv (h : has_prod f a) : has_prod (Œª b, (f b)‚Åª¬π) a‚Åª¬π :=
by simpa only using h.map (monoid_hom.id Œ±)‚Åª¬π continuous_inv

@[to_additive] lemma prodable.inv (hf : prodable f) : prodable (Œª b, (f b)‚Åª¬π) :=
hf.has_prod.inv.prodable

@[to_additive] lemma prodable.of_inv (hf : prodable (Œª b, (f b)‚Åª¬π)) : prodable f :=
by simpa only [inv_inv] using hf.inv

@[to_additive] lemma prodable_inv_iff : prodable (Œª b, (f b)‚Åª¬π) ‚Üî prodable f :=
‚ü®prodable.of_inv, prodable.inv‚ü©

@[to_additive] lemma has_prod.div (hf : has_prod f a‚ÇÅ) (hg : has_prod g a‚ÇÇ) :
  has_prod (Œª b, f b / g b) (a‚ÇÅ / a‚ÇÇ) :=
by { simp only [div_eq_mul_inv], exact hf.mul hg.inv }

@[to_additive] lemma prodable.div (hf : prodable f) (hg : prodable g) : prodable (Œª b, f b / g b) :=
(hf.has_prod.div hg.has_prod).prodable

@[to_additive] lemma prodable.trans_div (hg : prodable g) (hfg : prodable (Œª b, f b / g b)) :
  prodable f :=
by simpa only [div_mul_cancel'] using hfg.mul hg

@[to_additive] lemma prodable_iff_of_prodable_div (hfg : prodable (Œª b, f b / g b)) :
  prodable f ‚Üî prodable g :=
‚ü®Œª hf, hf.trans_div $ by simpa only [inv_div] using hfg.inv, Œª hg, hg.trans_div hfg‚ü©

@[to_additive] lemma has_prod.update (hf : has_prod f a‚ÇÅ) (b : Œ≤) [decidable_eq Œ≤] (a : Œ±) :
  has_prod (update f b a) (a / f b * a‚ÇÅ) :=
begin
  convert (has_prod_ite_eq b _).mul hf,
  ext b',
  split_ifs,
  { rw [h, update_same, div_mul_cancel'] },
  { rw [update_noteq h, one_mul] }
end

@[to_additive] lemma prodable.update (hf : prodable f) (b : Œ≤) [decidable_eq Œ≤] (a : Œ±) :
  prodable (update f b a) :=
(hf.has_prod.update b a).prodable

@[to_additive] lemma has_prod.has_prod_compl_iff {s : set Œ≤} (hf : has_prod (f ‚àò coe : s ‚Üí Œ±) a‚ÇÅ) :
  has_prod (f ‚àò coe : s·∂ú ‚Üí Œ±) a‚ÇÇ ‚Üî has_prod f (a‚ÇÅ * a‚ÇÇ) :=
begin
  refine ‚ü®Œª h, hf.mul_compl h, Œª h, _‚ü©,
  rw [has_prod_subtype_iff_mul_indicator] at hf ‚ä¢,
  rw [set.mul_indicator_compl, ‚Üêdiv_eq_mul_inv],
  simpa only [mul_div_cancel'''] using h.div hf,
end

@[to_additive] lemma has_prod.has_prod_iff_compl {s : set Œ≤} (hf : has_prod (f ‚àò coe : s ‚Üí Œ±) a‚ÇÅ) :
  has_prod f a‚ÇÇ ‚Üî has_prod (f ‚àò coe : s·∂ú ‚Üí Œ±) (a‚ÇÇ / a‚ÇÅ) :=
iff.symm $ hf.has_prod_compl_iff.trans $ by rw [mul_div_cancel'_right]

@[to_additive] lemma prodable.prodable_compl_iff {s : set Œ≤} (hf : prodable (f ‚àò coe : s ‚Üí Œ±)) :
  prodable (f ‚àò coe : s·∂ú ‚Üí Œ±) ‚Üî prodable f :=
‚ü®Œª ‚ü®a, ha‚ü©, (hf.has_prod.has_prod_compl_iff.1 ha).prodable,
  Œª ‚ü®a, ha‚ü©, (hf.has_prod.has_prod_iff_compl.1 ha).prodable‚ü©

@[to_additive] protected lemma finset.has_prod_compl_iff (s : finset Œ≤) :
  has_prod (Œª x : {x // x ‚àâ s}, f x) a ‚Üî has_prod f (a * ‚àè i in s, f i) :=
(s.has_prod f).has_prod_compl_iff.trans $ by rw [mul_comm]

@[to_additive] protected lemma finset.has_prod_iff_compl (s : finset Œ≤) :
  has_prod f a ‚Üî has_prod (Œª x : {x // x ‚àâ s}, f x) (a / ‚àè i in s, f i) :=
(s.has_prod f).has_prod_iff_compl

@[to_additive] protected lemma finset.prodable_compl_iff (s : finset Œ≤) :
  prodable (Œª x : {x // x ‚àâ s}, f x) ‚Üî prodable f :=
(s.prodable f).prodable_compl_iff

@[to_additive] lemma set.finite.prodable_compl_iff {s : set Œ≤} (hs : s.finite) :
  prodable (f ‚àò coe : s·∂ú ‚Üí Œ±) ‚Üî prodable f :=
(hs.prodable f).prodable_compl_iff

@[to_additive] lemma has_prod_ite_div_has_prod [decidable_eq Œ≤] (hf : has_prod f a) (b : Œ≤) :
  has_prod (Œª n, ite (n = b) 1 (f n)) (a / f b) :=
begin
  convert hf.update b 1 using 1,
  { ext n,
    rw function.update_apply },
  { rw [div_mul_eq_mul_div, one_mul] }
end

section tsum
variables [t2_space Œ±]

@[to_additive] lemma tprod_inv : ‚àè' b, (f b)‚Åª¬π = (‚àè' b, f b)‚Åª¬π :=
begin
  by_cases hf : prodable f,
  { exact hf.has_prod.inv.tprod_eq },
  { simp [tprod_eq_one_of_not_prodable hf, tprod_eq_one_of_not_prodable (mt prodable.of_inv hf)] },
end

@[to_additive] lemma tprod_div (hf : prodable f) (hg : prodable g) :
  ‚àè' b, (f b / g b) = (‚àè' b, f b) / ‚àè' b, g b :=
(hf.has_prod.div hg.has_prod).tprod_eq

@[to_additive] lemma prod_mul_tprod_compl {s : finset Œ≤} (hf : prodable f) :
  (‚àè x in s, f x) * (‚àè' x : (‚Üës : set Œ≤)·∂ú, f x) = ‚àè' x, f x :=
((s.has_prod f).mul_compl (s.prodable_compl_iff.2 hf).has_prod).tprod_eq.symm

/-- Let `f : Œ≤ ‚Üí Œ±` be a sequence with prodable series and let `b ‚àà Œ≤` be an index. This lemma
writes `‚àè f n` as the sum of `f b` plus the series of the remaining terms. -/
@[to_additive
"Let `f : Œ≤ ‚Üí Œ±` be a sequence with summable series and let `b ‚àà Œ≤` be an index. This lemma writes
`Œ£ f n` as the sum of `f b` plus the series of the remaining terms."]
lemma tprod_eq_mul_tprod_ite [decidable_eq Œ≤] (hf : prodable f) (b : Œ≤) :
  ‚àè' n, f n = f b * ‚àè' n, ite (n = b) 1 (f n) :=
begin
  rw (has_prod_ite_div_has_prod hf.has_prod b).tprod_eq,
  exact (mul_div_cancel'_right _ _).symm,
end

end tsum

/-!
### Sums on nat

We show the formula `(‚àë i in range k, f i) + (‚àë' i, f (i + k)) = (‚àë' i, f i)`, in
`sum_add_tsum_nat_add`, as well as several results relating sums on `‚Ñï` and `‚Ñ§`.
-/
section nat

@[to_additive] lemma has_prod_nat_add_iff {f : ‚Ñï ‚Üí Œ±} (k : ‚Ñï) {a : Œ±} :
  has_prod (Œª n, f (n + k)) a ‚Üî has_prod f (a * ‚àè i in range k, f i) :=
begin
  refine iff.trans _ (range k).has_prod_compl_iff,
  rw ‚Üê(not_mem_range_equiv k).symm.has_prod_iff,
  refl
end

@[to_additive] lemma prodable_nat_add_iff {f : ‚Ñï ‚Üí Œ±} (k : ‚Ñï) :
  prodable (Œª n, f (n + k)) ‚Üî prodable f :=
iff.symm $ (equiv.mul_right (‚àè i in range k, f i)).surjective.prodable_iff_of_has_prod_iff $
  Œª a, (has_prod_nat_add_iff k).symm

@[to_additive] lemma has_prod_nat_add_iff' {f : ‚Ñï ‚Üí Œ±} (k : ‚Ñï) {a : Œ±} :
  has_prod (Œª n, f (n + k)) (a / ‚àè i in range k, f i) ‚Üî has_prod f a :=
by simp [has_prod_nat_add_iff]

@[to_additive] lemma prod_mul_tprod_nat_add [t2_space Œ±] {f : ‚Ñï ‚Üí Œ±} (k : ‚Ñï) (h : prodable f) :
  (‚àè i in range k, f i) * (‚àè' i, f (i + k)) = ‚àè' i, f i :=
by simpa only [mul_comm] using
  ((has_prod_nat_add_iff k).1 ((prodable_nat_add_iff k).2 h).has_prod).unique h.has_prod

@[to_additive] lemma tprod_eq_zero_mul [t2_space Œ±] {f : ‚Ñï ‚Üí Œ±} (hf : prodable f) :
  ‚àè' b, f b = f 0 * ‚àè' b, f (b + 1) :=
by simpa only [prod_range_one] using (prod_mul_tprod_nat_add 1 hf).symm

/-- For `f : ‚Ñï ‚Üí Œ±`, then `‚àè' k, f (k + i)` tends to zero. This does not require a productability
assumption on `f`, as otherwise all products are zero. -/
@[to_additive "For `f : ‚Ñï ‚Üí Œ±`, then `‚àë' k, f (k + i)` tends to zero. This does not require a
summability assumption on `f`, as otherwise all sums are zero."]
lemma tendsto_prod_nat_add [t2_space Œ±] (f : ‚Ñï ‚Üí Œ±) : tendsto (Œª i, ‚àè' k, f (k + i)) at_top (ùìù 1) :=
begin
  by_cases hf : prodable f,
  { have h‚ÇÄ : (Œª i, (‚àè' i, f i) / ‚àè j in range i, f j) = Œª i, ‚àè' k, f (k + i),
    { ext1 i,
      rw [div_eq_iff_eq_mul, mul_comm, prod_mul_tprod_nat_add i hf] },
    have h‚ÇÅ : tendsto (Œª i : ‚Ñï, ‚àè' i, f i) at_top (ùìù (‚àè' i, f i)) := tendsto_const_nhds,
    simpa only [h‚ÇÄ, div_self'] using h‚ÇÅ.div' hf.has_prod.tendsto_prod_nat },
  { convert tendsto_const_nhds,
    ext1 i,
    rw ‚Üê prodable_nat_add_iff i at hf,
    { exact tprod_eq_one_of_not_prodable hf },
    { apply_instance } }
end

/-- If `f‚ÇÄ, f‚ÇÅ, f‚ÇÇ, ...` and `g‚ÇÄ, g‚ÇÅ, g‚ÇÇ, ...` are both convergent series then so is the `‚Ñ§`-indexed
sequence: `..., g‚ÇÇ, g‚ÇÅ, g‚ÇÄ, f‚ÇÄ, f‚ÇÅ, f‚ÇÇ, ...`. -/
@[to_additive "If `f‚ÇÄ, f‚ÇÅ, f‚ÇÇ, ...` and `g‚ÇÄ, g‚ÇÅ, g‚ÇÇ, ...` are both convergent series then so is the
`‚Ñ§`-indexed sequence: `..., g‚ÇÇ, g‚ÇÅ, g‚ÇÄ, f‚ÇÄ, f‚ÇÅ, f‚ÇÇ, ...`."]
lemma has_prod.int_rec {b : Œ±} {f g : ‚Ñï ‚Üí Œ±} (hf : has_prod f a) (hg : has_prod g b) :
  @has_prod Œ± _ _ _ (@int.rec (Œª _, Œ±) f g : ‚Ñ§ ‚Üí Œ±) (a * b) :=
begin
  -- note this proof works for any two-case inductive
  have h‚ÇÅ : injective (coe : ‚Ñï ‚Üí ‚Ñ§) := @int.of_nat.inj,
  have h‚ÇÇ : injective int.neg_succ_of_nat := @int.neg_succ_of_nat.inj,
  refine has_prod.mul_is_compl ‚ü®_, _‚ü© (h‚ÇÅ.has_prod_range_iff.mpr hf) (h‚ÇÇ.has_prod_range_iff.mpr hg),
  { rw disjoint_iff_inf_le,
    rintro _ ‚ü®‚ü®i, rfl‚ü©, ‚ü®j, ‚ü®‚ü©‚ü©‚ü© },
  { rw codisjoint_iff_le_sup,
    rintro (i | j) h,
    exacts [or.inl ‚ü®_, rfl‚ü©, or.inr ‚ü®_, rfl‚ü©] }
end

@[to_additive] lemma has_prod.nonneg_mul_neg {b : Œ±} {f : ‚Ñ§ ‚Üí Œ±}
  (hnonneg : has_prod (Œª n : ‚Ñï, f n) a) (hneg : has_prod (Œª n : ‚Ñï, f (-n.succ)) b) :
  has_prod f (a * b) :=
begin
  simp_rw ‚Üê int.neg_succ_of_nat_coe at hneg,
  convert hnonneg.int_rec hneg using 1,
  ext (i | j); refl,
end

@[to_additive] lemma has_prod.pos_mul_zero_mul_neg {b : Œ±} {f : ‚Ñ§ ‚Üí Œ±}
  (hpos : has_prod (Œª n : ‚Ñï, f (n + 1)) a) (hneg : has_prod (Œª n : ‚Ñï, f (-n.succ)) b) :
  has_prod f (a * f 0 * b) :=
begin
  have : ‚àÄ g : ‚Ñï ‚Üí Œ±, has_prod (Œª k, g (k + 1)) a ‚Üí has_prod g (a * g 0),
  { intros g hg, simpa using (has_prod_nat_add_iff _).mp hg },
  exact (this (Œª n, f n) hpos).nonneg_mul_neg hneg,
end

@[to_additive] lemma prodable_int_of_prodable_nat {f : ‚Ñ§ ‚Üí Œ±}
  (hp : prodable (Œª n : ‚Ñï, f n)) (hn : prodable (Œª n : ‚Ñï, f (-n))) : prodable f :=
(has_prod.nonneg_mul_neg hp.has_prod $ prodable.has_prod $ (prodable_nat_add_iff 1).mpr hn).prodable

@[to_additive] lemma has_prod.prod_nat_of_prod_int {Œ± : Type*} [comm_monoid Œ±] [topological_space Œ±]
  [has_continuous_mul Œ±] {a : Œ±} {f : ‚Ñ§ ‚Üí Œ±} (hf : has_prod f a) :
  has_prod (Œª n : ‚Ñï, f n * f (-n)) (a * f 0) :=
begin
  apply (hf.mul (has_prod_ite_eq (0 : ‚Ñ§) (f 0))).has_prod_of_prod_eq (Œª u, _),
  refine ‚ü®u.image int.nat_abs, Œª v' hv', _‚ü©,
  let u1 := v'.image (Œª (x : ‚Ñï), (x : ‚Ñ§)),
  let u2 := v'.image (Œª (x : ‚Ñï), - (x : ‚Ñ§)),
  have A : u ‚äÜ u1 ‚à™ u2,
  { assume x hx,
    simp only [mem_union, mem_image, exists_prop],
    rcases le_total 0 x with h'x|h'x,
    { left,
      refine ‚ü®int.nat_abs x, hv' _, _‚ü©,
      { simp only [mem_image, exists_prop],
        exact ‚ü®x, hx, rfl‚ü© },
      { simp only [h'x, int.coe_nat_abs, abs_eq_self] } },
    { right,
      refine ‚ü®int.nat_abs x, hv' _, _‚ü©,
      { simp only [mem_image, exists_prop],
        exact ‚ü®x, hx, rfl‚ü© },
      { simp only [abs_of_nonpos h'x, int.coe_nat_abs, neg_neg] } } },
  refine ‚ü®u1 ‚à™ u2, A, _‚ü©,
  calc ‚àè x in u1 ‚à™ u2, (f x * ite (x = 0) (f 0) 1)
      = (‚àè x in u1 ‚à™ u2, f x) * ‚àè x in u1 ‚à© u2, f x :
    begin
      rw prod_mul_distrib,
      congr' 1,
      refine (prod_subset_one_on_sdiff inter_subset_union _ _).symm,
      { assume x hx,
        suffices : x ‚â† 0, by simp only [this, if_false],
        rintros rfl,
        simpa only [mem_sdiff, mem_union, mem_image, neg_eq_zero, or_self, mem_inter, and_self,
          and_not_self] using hx },
      { assume x hx,
        simp only [mem_inter, mem_image, exists_prop] at hx,
        have : x = 0,
        { apply le_antisymm,
          { rcases hx.2 with ‚ü®a, ha, rfl‚ü©,
            simp only [right.neg_nonpos_iff, nat.cast_nonneg] },
          { rcases hx.1 with ‚ü®a, ha, rfl‚ü©,
            simp only [nat.cast_nonneg] } },
        simp only [this, eq_self_iff_true, if_true] }
    end
  ... = (‚àè x in u1, f x) * ‚àè x in u2, f x : prod_union_inter
  ... = (‚àè b in v', f b) * ‚àè b in v', f (-b) :
    by simp only [prod_image, nat.cast_inj, imp_self, implies_true_iff, neg_inj]
  ... = ‚àè b in v', f b * f (-b) : prod_mul_distrib.symm
end

end nat

end topological_group

section topological_semiring
variables [non_unital_non_assoc_semiring Œ±] [topological_space Œ±] [topological_semiring Œ±]
variables {f g : Œ≤ ‚Üí Œ±} {a a‚ÇÅ a‚ÇÇ : Œ±}
lemma has_sum.mul_left (a‚ÇÇ) (h : has_sum f a‚ÇÅ) : has_sum (Œªb, a‚ÇÇ * f b) (a‚ÇÇ * a‚ÇÅ) :=
by simpa only using h.map (add_monoid_hom.mul_left a‚ÇÇ) (continuous_const.mul continuous_id)

lemma has_sum.mul_right (a‚ÇÇ) (hf : has_sum f a‚ÇÅ) : has_sum (Œªb, f b * a‚ÇÇ) (a‚ÇÅ * a‚ÇÇ) :=
by simpa only using hf.map (add_monoid_hom.mul_right a‚ÇÇ) (continuous_id.mul continuous_const)

lemma summable.mul_left (a) (hf : summable f) : summable (Œªb, a * f b) :=
(hf.has_sum.mul_left _).summable

lemma summable.mul_right (a) (hf : summable f) : summable (Œªb, f b * a) :=
(hf.has_sum.mul_right _).summable

section tsum
variables [t2_space Œ±]

lemma summable.tsum_mul_left (a) (hf : summable f) : ‚àë' b, a * f b = a * ‚àë' b, f b :=
(hf.has_sum.mul_left _).tsum_eq

lemma summable.tsum_mul_right (a) (hf : summable f) : ‚àë' b, f b * a = (‚àë' b, f b) * a :=
(hf.has_sum.mul_right _).tsum_eq

lemma commute.tsum_right (a) (h : ‚àÄ b, commute a (f b)) : commute a (‚àë' b, f b) :=
if hf : summable f then
  (hf.tsum_mul_left a).symm.trans ((congr_arg _ $ funext h).trans (hf.tsum_mul_right a))
else
  (tsum_eq_zero_of_not_summable hf).symm ‚ñ∏ commute.zero_right _

lemma commute.tsum_left (a) (h : ‚àÄ b, commute (f b) a) : commute (‚àë' b, f b) a :=
(commute.tsum_right _ $ Œª b, (h b).symm).symm

end tsum

end topological_semiring

section const_smul
variables {R : Type*}
[monoid R]
[topological_space Œ±] [add_comm_monoid Œ±]
[distrib_mul_action R Œ±] [has_continuous_const_smul R Œ±]
{f : Œ≤ ‚Üí Œ±}

lemma has_sum.const_smul {a : Œ±} {r : R} (hf : has_sum f a) : has_sum (Œª z, r ‚Ä¢ f z) (r ‚Ä¢ a) :=
hf.map (distrib_mul_action.to_add_monoid_hom Œ± r) (continuous_const_smul r)

lemma summable.const_smul {r : R} (hf : summable f) : summable (Œª z, r ‚Ä¢ f z) :=
hf.has_sum.const_smul.summable

lemma tsum_const_smul [t2_space Œ±] {r : R} (hf : summable f) : ‚àë' z, r ‚Ä¢ f z = r ‚Ä¢ ‚àë' z, f z :=
hf.has_sum.const_smul.tsum_eq

end const_smul

section smul_const
variables {R : Type*}
[semiring R] [topological_space R]
[topological_space Œ±] [add_comm_monoid Œ±]
[module R Œ±] [has_continuous_smul R Œ±]
{f : Œ≤ ‚Üí R}

lemma has_sum.smul_const {a : Œ±} {r : R} (hf : has_sum f r) : has_sum (Œª z, f z ‚Ä¢ a) (r ‚Ä¢ a) :=
hf.map ((smul_add_hom R Œ±).flip a) (continuous_id.smul continuous_const)

lemma summable.smul_const {a : Œ±} (hf : summable f) : summable (Œª z, f z ‚Ä¢ a) :=
hf.has_sum.smul_const.summable

lemma tsum_smul_const [t2_space Œ±] {a : Œ±} (hf : summable f) : ‚àë' z, f z ‚Ä¢ a = (‚àë' z, f z) ‚Ä¢ a :=
hf.has_sum.smul_const.tsum_eq

end smul_const

section division_ring

variables [division_ring Œ±] [topological_space Œ±] [topological_ring Œ±]
{f g : Œ≤ ‚Üí Œ±} {a a‚ÇÅ a‚ÇÇ : Œ±}

lemma has_sum.div_const (h : has_sum f a) (b : Œ±) : has_sum (Œª x, f x / b) (a / b) :=
by simp only [div_eq_mul_inv, h.mul_right b‚Åª¬π]

lemma summable.div_const (h : summable f) (b : Œ±) : summable (Œª x, f x / b) :=
(h.has_sum.div_const b).summable

lemma has_sum_mul_left_iff (h : a‚ÇÇ ‚â† 0) : has_sum (Œªb, a‚ÇÇ * f b) (a‚ÇÇ * a‚ÇÅ) ‚Üî has_sum f a‚ÇÅ :=
‚ü®Œª H, by simpa only [inv_mul_cancel_left‚ÇÄ h] using H.mul_left a‚ÇÇ‚Åª¬π, has_sum.mul_left _‚ü©

lemma has_sum_mul_right_iff (h : a‚ÇÇ ‚â† 0) : has_sum (Œªb, f b * a‚ÇÇ) (a‚ÇÅ * a‚ÇÇ) ‚Üî has_sum f a‚ÇÅ :=
‚ü®Œª H, by simpa only [mul_inv_cancel_right‚ÇÄ h] using H.mul_right a‚ÇÇ‚Åª¬π, has_sum.mul_right _‚ü©

lemma has_sum_div_const_iff (h : a‚ÇÇ ‚â† 0) : has_sum (Œªb, f b / a‚ÇÇ) (a‚ÇÅ / a‚ÇÇ) ‚Üî has_sum f a‚ÇÅ :=
by simpa only [div_eq_mul_inv] using has_sum_mul_right_iff (inv_ne_zero h)

lemma summable_mul_left_iff (h : a ‚â† 0) : summable (Œªb, a * f b) ‚Üî summable f :=
‚ü®Œª H, by simpa only [inv_mul_cancel_left‚ÇÄ h] using H.mul_left a‚Åª¬π, Œª H, H.mul_left _‚ü©

lemma summable_mul_right_iff (h : a ‚â† 0) : summable (Œªb, f b * a) ‚Üî summable f :=
‚ü®Œª H, by simpa only [mul_inv_cancel_right‚ÇÄ h] using H.mul_right a‚Åª¬π, Œª H, H.mul_right _‚ü©

lemma summable_div_const_iff (h : a ‚â† 0) : summable (Œªb, f b / a) ‚Üî summable f :=
by simpa only [div_eq_mul_inv] using summable_mul_right_iff (inv_ne_zero h)

lemma tsum_mul_left [t2_space Œ±] : (‚àë' x, a * f x) = a * ‚àë' x, f x :=
if hf : summable f then hf.tsum_mul_left a
else if ha : a = 0 then by simp [ha]
else by rw [tsum_eq_zero_of_not_summable hf,
  tsum_eq_zero_of_not_summable (mt (summable_mul_left_iff ha).mp hf), mul_zero]

lemma tsum_mul_right [t2_space Œ±] : (‚àë' x, f x * a) = (‚àë' x, f x) * a :=
if hf : summable f then hf.tsum_mul_right a
else if ha : a = 0 then by simp [ha]
else by rw [tsum_eq_zero_of_not_summable hf,
  tsum_eq_zero_of_not_summable (mt (summable_mul_right_iff ha).mp hf), zero_mul]

lemma tsum_div_const [t2_space Œ±] : (‚àë' x, f x / a) = (‚àë' x, f x) / a :=
by simpa only [div_eq_mul_inv] using tsum_mul_right

end division_ring

section order_topology
variables [ordered_comm_monoid Œ±] [topological_space Œ±] [order_closed_topology Œ±]
variables {f g : Œ≤ ‚Üí Œ±} {a a‚ÇÅ a‚ÇÇ : Œ±}

@[to_additive]
lemma has_prod_le (h : ‚àÄ b, f b ‚â§ g b) (hf : has_prod f a‚ÇÅ) (hg : has_prod g a‚ÇÇ) : a‚ÇÅ ‚â§ a‚ÇÇ :=
le_of_tendsto_of_tendsto' hf hg $ Œª s, finset.prod_le_prod'' $ Œª b _, h b

@[to_additive]
lemma has_prod_mono (hf : has_prod f a‚ÇÅ) (hg : has_prod g a‚ÇÇ) (h : f ‚â§ g) : a‚ÇÅ ‚â§ a‚ÇÇ :=
has_prod_le h hf hg

attribute [mono] has_prod_mono has_sum_mono

@[to_additive] lemma has_prod_le_of_prod_le (hf : has_prod f a) (h : ‚àÄ s, ‚àè b in s, f b ‚â§ a‚ÇÇ) :
  a ‚â§ a‚ÇÇ :=
le_of_tendsto' hf h

@[to_additive] lemma le_has_prod_of_le_prod (hf : has_prod f a) (h : ‚àÄ s, a‚ÇÇ ‚â§ ‚àè b in s, f b) :
  a‚ÇÇ ‚â§ a :=
ge_of_tendsto' hf h

@[to_additive]
lemma has_prod_le_inj {g : Œ≥ ‚Üí Œ±} (i : Œ≤ ‚Üí Œ≥) (hi : injective i) (hs : ‚àÄ c ‚àâ set.range i, 1 ‚â§ g c)
  (h : ‚àÄ b, f b ‚â§ g (i b)) (hf : has_prod f a‚ÇÅ) (hg : has_prod g a‚ÇÇ) : a‚ÇÅ ‚â§ a‚ÇÇ :=
have has_prod (Œª c, (partial_inv i c).cases_on' 1 f) a‚ÇÅ,
begin
  refine (has_prod_iff_has_prod_of_ne_one_bij (i ‚àò coe) _ _ $ Œª c,  _).2 hf,
  { exact Œª c‚ÇÅ c‚ÇÇ eq, hi eq },
  { intros c hc,
    rw [mem_mul_support] at hc,
    cases eq : partial_inv i c with b; rw eq at hc,
    { contradiction },
    { rw [partial_inv_of_injective hi] at eq,
      exact ‚ü®‚ü®b, hc‚ü©, eq‚ü© } },
  { simp [partial_inv_left hi, option.cases_on'] }
end,
begin
  refine has_prod_le (Œª c, _) this hg,
  by_cases c ‚àà set.range i,
  { rcases h with ‚ü®b, rfl‚ü©,
    rw [partial_inv_left hi, option.cases_on'],
    exact h _ },
  { have : partial_inv i c = none := dif_neg h,
    rw [this, option.cases_on'],
    exact hs _ h }
end

@[to_additive] lemma tprod_le_tprod_of_inj {g : Œ≥ ‚Üí Œ±} (i : Œ≤ ‚Üí Œ≥) (hi : injective i)
  (hs : ‚àÄ c ‚àâ set.range i, 1 ‚â§ g c) (h : ‚àÄ b, f b ‚â§ g (i b)) (hf : prodable f) (hg : prodable g) :
  tprod f ‚â§ tprod g :=
has_prod_le_inj i hi hs h hf.has_prod hg.has_prod

@[to_additive] lemma prod_le_has_prod (s : finset Œ≤) (hs : ‚àÄ b ‚àâ s, 1 ‚â§ f b) (hf : has_prod f a) :
  ‚àè b in s, f b ‚â§ a :=
ge_of_tendsto hf $ eventually_at_top.2 ‚ü®s, Œª t hst,
  prod_le_prod_of_subset_of_one_le' hst $ Œª b hbt, hs b‚ü©

@[to_additive] lemma is_lub_has_prod (h : ‚àÄ b, 1 ‚â§ f b) (hf : has_prod f a) :
  is_lub (set.range (Œª s, ‚àè b in s, f b)) a :=
is_lub_of_tendsto_at_top (prod_mono_set_of_one_le' h) hf

@[to_additive] lemma le_has_prod (hf : has_prod f a) (b : Œ≤) (hb : ‚àÄ b' ‚â† b, 1 ‚â§ f b') : f b ‚â§ a :=
calc f b = ‚àè b in {b}, f b : finset.prod_singleton.symm
... ‚â§ a : prod_le_has_prod _ (by { convert hb, simp }) hf

@[to_additive]
lemma prod_le_tprod {f : Œ≤ ‚Üí Œ±} (s : finset Œ≤) (hs : ‚àÄ b ‚àâ s, 1 ‚â§ f b) (hf : prodable f) :
  ‚àè b in s, f b ‚â§ ‚àè' b, f b :=
prod_le_has_prod s hs hf.has_prod

@[to_additive] lemma le_tprod (hf : prodable f) (b : Œ≤) (hb : ‚àÄ b' ‚â† b, 1 ‚â§ f b') :
  f b ‚â§ ‚àè' b, f b :=
le_has_prod (prodable.has_prod hf) b hb

@[to_additive] lemma tprod_le_tprod (h : ‚àÄ b, f b ‚â§ g b) (hf : prodable f) (hg : prodable g) :
  ‚àè' b, f b ‚â§ ‚àè' b, g b :=
has_prod_le h hf.has_prod hg.has_prod

@[to_additive] lemma tprod_mono (hf : prodable f) (hg : prodable g) (h : f ‚â§ g) :
  ‚àè' n, f n ‚â§ ‚àè' n, g n :=
tprod_le_tprod h hf hg

attribute [mono] tprod_mono tsum_mono

@[to_additive] lemma tprod_le_of_prod_le (hf : prodable f) (h : ‚àÄ s, ‚àè b in s, f b ‚â§ a‚ÇÇ) :
  ‚àè' b, f b ‚â§ a‚ÇÇ :=
has_prod_le_of_prod_le hf.has_prod h

@[to_additive] lemma tprod_le_of_prod_le' (ha‚ÇÇ : 1 ‚â§ a‚ÇÇ) (h : ‚àÄ s, ‚àè b in s, f b ‚â§ a‚ÇÇ) :
  ‚àè' b, f b ‚â§ a‚ÇÇ :=
begin
  by_cases hf : prodable f,
  { exact tprod_le_of_prod_le hf h },
  { rw tprod_eq_one_of_not_prodable hf,
    exact ha‚ÇÇ }
end

@[to_additive] lemma has_prod.one_le (h : ‚àÄ b, 1 ‚â§ g b) (ha : has_prod g a) : 1 ‚â§ a :=
has_prod_le h has_prod_one ha

@[to_additive] lemma has_prod.le_one (h : ‚àÄ b, g b ‚â§ 1) (ha : has_prod g a) : a ‚â§ 1 :=
has_prod_le h ha has_prod_one

@[to_additive tsum_nonneg] lemma one_le_tprod (h : ‚àÄ b, 1 ‚â§ g b) : 1 ‚â§ ‚àè' b, g b :=
begin
  by_cases hg : prodable g,
  { exact hg.has_prod.one_le h },
  { simp [tprod_eq_one_of_not_prodable hg] }
end

@[to_additive] lemma tprod_le_one (h : ‚àÄ b, f b ‚â§ 1) : ‚àè' b, f b ‚â§ 1 :=
begin
  by_cases hf : prodable f,
  { exact hf.has_prod.le_one h },
  { simp [tprod_eq_one_of_not_prodable hf] }
end

end order_topology

section ordered_topological_group

variables [ordered_comm_group Œ±] [topological_space Œ±] [topological_group Œ±]
  [order_closed_topology Œ±] {f g : Œ≤ ‚Üí Œ±} {a‚ÇÅ a‚ÇÇ : Œ±}

@[to_additive] lemma has_prod_lt {i : Œ≤} (h : ‚àÄ (b : Œ≤), f b ‚â§ g b) (hi : f i < g i)
  (hf : has_prod f a‚ÇÅ) (hg : has_prod g a‚ÇÇ) :
  a‚ÇÅ < a‚ÇÇ :=
have update f i 1 ‚â§ update g i 1 := update_le_update_iff.mpr ‚ü®rfl.le, Œª i _, h i‚ü©,
have 1 / f i * a‚ÇÅ ‚â§ 1 / g i * a‚ÇÇ := has_prod_le this (hf.update i 1) (hg.update i 1),
by simpa only [one_div, mul_inv_cancel_left] using mul_lt_mul_of_lt_of_le hi this

@[to_additive]
lemma has_prod_strict_mono (hf : has_prod f a‚ÇÅ) (hg : has_prod g a‚ÇÇ) (h : f < g) : a‚ÇÅ < a‚ÇÇ :=
let ‚ü®hle, i, hi‚ü© := pi.lt_def.mp h in has_prod_lt hle hi hf hg

@[to_additive] lemma tprod_lt_tprod {i : Œ≤} (h : ‚àÄ (b : Œ≤), f b ‚â§ g b) (hi : f i < g i)
  (hf : prodable f) (hg : prodable g) :
  ‚àè' n, f n < ‚àè' n, g n :=
has_prod_lt h hi hf.has_prod hg.has_prod

@[to_additive] lemma tprod_strict_mono (hf : prodable f) (hg : prodable g) (h : f < g) :
  ‚àè' n, f n < ‚àè' n, g n :=
let ‚ü®hle, i, hi‚ü© := pi.lt_def.mp h in tprod_lt_tprod hle hi hf hg

attribute [mono] has_prod_strict_mono has_sum_strict_mono tprod_strict_mono tsum_strict_mono

@[to_additive tsum_pos]
lemma one_lt_tprod (hg' : prodable g) (hg : ‚àÄ b, 1 ‚â§ g b) (i : Œ≤) (hi : 1 < g i) : 1 < ‚àè' b, g b :=
by { rw ‚Üê tprod_one, exact tprod_lt_tprod hg hi prodable_one hg' }

@[to_additive] lemma has_prod_one_iff_of_one_le (hf : ‚àÄ i, 1 ‚â§ f i) : has_prod f 1 ‚Üî f = 1 :=
begin
  split,
  { intros hf',
    ext i,
    by_contra hi',
    have hi : 1 < f i := lt_of_le_of_ne (hf i) (ne.symm hi'),
    simpa using has_prod_lt hf hi has_prod_one hf' },
  { rintros rfl,
    exact has_prod_one },
end

end ordered_topological_group

section canonically_ordered
variables [canonically_ordered_monoid Œ±] [topological_space Œ±] [order_closed_topology Œ±]
variables {f : Œ≤ ‚Üí Œ±} {a : Œ±}

@[to_additive] lemma le_has_prod' (hf : has_prod f a) (b : Œ≤) : f b ‚â§ a :=
le_has_prod hf b $ Œª _ _, one_le _

@[to_additive] lemma le_tprod' (hf : prodable f) (b : Œ≤) : f b ‚â§ ‚àè' b, f b :=
le_tprod hf b $ Œª _ _, one_le _

@[to_additive] lemma has_prod_one_iff : has_prod f 1 ‚Üî ‚àÄ x, f x = 1 :=
begin
  refine ‚ü®_, Œª h, _‚ü©,
  { contrapose!,
    exact Œª ‚ü®x, hx‚ü© h, hx (le_one_iff_eq_one.1 $ le_has_prod' h x) },
  { convert has_prod_one,
    exact funext h }
end

@[to_additive] lemma tprod_eq_one_iff (hf : prodable f) : ‚àè' i, f i = 1 ‚Üî ‚àÄ x, f x = 1 :=
by rw [‚Üêhas_prod_one_iff, hf.has_prod_iff]

@[to_additive] lemma tprod_ne_one_iff (hf : prodable f) : ‚àè' i, f i ‚â† 1 ‚Üî ‚àÉ x, f x ‚â† 1 :=
by rw [ne.def, tprod_eq_one_iff hf, not_forall]

@[to_additive] lemma is_lub_has_prod' (hf : has_prod f a) :
  is_lub (set.range (Œª s, ‚àè b in s, f b)) a :=
is_lub_of_tendsto_at_top (finset.prod_mono_set' f) hf

end canonically_ordered

section uniform_group
variables [comm_group Œ±] [uniform_space Œ±]

/-- The **Cauchy criterion** for infinite products, also known as the **Cauchy convergence test** -/
@[to_additive
"The **Cauchy criterion** for infinite sums, also known as the **Cauchy convergence test**"]
lemma prodable_iff_cauchy_seq_finset [complete_space Œ±] {f : Œ≤ ‚Üí Œ±} :
  prodable f ‚Üî cauchy_seq (Œª s, ‚àè b in s, f b) :=
cauchy_map_iff_exists_tendsto.symm

variables [uniform_group Œ±] {f g : Œ≤ ‚Üí Œ±} {a a‚ÇÅ a‚ÇÇ : Œ±}

@[to_additive] lemma cauchy_seq_finset_prod_iff_vanishing :
  cauchy_seq (Œª s, ‚àè b in s, f b) ‚Üî
    ‚àÄ e ‚àà ùìù (1 : Œ±), ‚àÉ s, ‚àÄ t, disjoint t s ‚Üí ‚àè b in t, f b ‚àà e :=
begin
  simp only [cauchy_seq, cauchy_map_iff, and_iff_right at_top_ne_bot,
    prod_at_top_at_top_eq, uniformity_eq_comap_nhds_one Œ±, tendsto_comap_iff, (‚àò)],
  rw [tendsto_at_top'],
  refine ‚ü®Œª h e he, _, Œª h e he, _‚ü©,
  { obtain ‚ü®‚ü®s‚ÇÅ, s‚ÇÇ‚ü©, h‚ü© := h _ he,
    refine ‚ü®s‚ÇÅ ‚à™ s‚ÇÇ, Œª t ht, _‚ü©,
    specialize h (s‚ÇÅ ‚à™ s‚ÇÇ, (s‚ÇÅ ‚à™ s‚ÇÇ) ‚à™ t) ‚ü®le_sup_left, le_sup_of_le_left le_sup_right‚ü©,
    simpa only [finset.prod_union ht.symm, mul_div_cancel'''] using h },
  { obtain ‚ü®d, hd, hde‚ü© := exists_nhds_split_inv he,
    obtain ‚ü®s, h‚ü© := h _ hd,
    use [(s, s)],
    rintros ‚ü®t‚ÇÅ, t‚ÇÇ‚ü© ‚ü®ht‚ÇÅ, ht‚ÇÇ‚ü©,
    have : (‚àè b in t‚ÇÇ, f b) / ‚àè b in t‚ÇÅ, f b = (‚àè b in t‚ÇÇ \ s, f b) / ‚àè b in t‚ÇÅ \ s, f b,
    { simp only [‚Üêfinset.prod_sdiff ht‚ÇÅ, ‚Üêfinset.prod_sdiff ht‚ÇÇ, mul_div_mul_right_eq_div] },
    simp only [this],
    exact hde _ (h _ finset.sdiff_disjoint) _ (h _ finset.sdiff_disjoint) }
end

local attribute [instance] topological_group.t3_space

/-- The prod over the complement of a finset tends to `1` when the finset grows to cover the whole
space. This does not need a summability assumption, as otherwise all prods are one. -/
@[to_additive "The sum over the complement of a finset tends to `0`
when the finset grows to cover the whole space. This does not need a summability assumption, as
otherwise all sums are zero."]
lemma tendsto_tprod_compl_at_top_one (f : Œ≤ ‚Üí Œ±) :
  tendsto (Œª s : finset Œ≤, ‚àè' b : {x // x ‚àâ s}, f b) at_top (ùìù 1) :=
begin
  by_cases H : prodable f,
  { rintro e he,
    rcases exists_mem_nhds_is_closed_subset he with ‚ü®o, ho, o_closed, oe‚ü©,
    simp only [le_eq_subset, set.mem_preimage, mem_at_top_sets, filter.mem_map, ge_iff_le],
    obtain ‚ü®s, hs‚ü© := cauchy_seq_finset_prod_iff_vanishing.1 H.has_prod.cauchy_seq o ho,
    refine ‚ü®s, Œª a sa, oe _‚ü©,
    have A : prodable (Œª b : {x // x ‚àâ a}, f b) := a.prodable_compl_iff.2 H,
    refine o_closed.mem_of_tendsto A.has_prod (eventually_of_forall $ Œª b, _),
    rw ‚Üêprod_image (subtype.coe_injective.inj_on _),
    refine hs _ (disjoint_left.2 (Œª i hi his, _)),
    apply_instance,
    obtain ‚ü®i', hi', rfl‚ü© := mem_image.1 hi,
    exact i'.2 (sa his) },
  { convert tendsto_const_nhds,
    ext s,
    apply tprod_eq_one_of_not_prodable,
    rwa finset.prodable_compl_iff }
end

variable [complete_space Œ±]

@[to_additive] lemma prodable_iff_vanishing :
  prodable f ‚Üî ‚àÄ e ‚àà ùìù (1 : Œ±), ‚àÉ s, ‚àÄ t, disjoint t s ‚Üí ‚àè b in t, f b ‚àà e :=
by rw [prodable_iff_cauchy_seq_finset, cauchy_seq_finset_prod_iff_vanishing]

/- TODO: generalize to monoid with a uniform continuous subtraction operator: `(a * b) / b = a` -/
@[to_additive]
lemma prodable.prodable_of_eq_one_or_self (hf : prodable f) (h : ‚àÄ b, g b = 1 ‚à® g b = f b) :
  prodable g :=
prodable_iff_vanishing.2 $
  Œª e he,
  let ‚ü®s, hs‚ü© := prodable_iff_vanishing.1 hf e he in
  ‚ü®s, Œª t ht,
    have eq : ‚àè b in t.filter (Œªb, g b = f b), f b = ‚àè b in t, g b :=
      calc ‚àè b in t.filter (Œªb, g b = f b), f b = ‚àè b in t.filter (Œªb, g b = f b), g b :
          finset.prod_congr rfl (Œª b hb, (finset.mem_filter.1 hb).2.symm)
        ... = ‚àè b in t, g b :
        begin
          refine finset.prod_subset (finset.filter_subset _ _) _,
          assume b hbt hb,
          simp only [(‚àâ), finset.mem_filter, and_iff_right hbt] at hb,
          exact (h b).resolve_right hb
        end,
    eq ‚ñ∏ hs _ $ finset.disjoint_of_subset_left (finset.filter_subset _ _) ht‚ü©

@[to_additive] protected lemma prodable.mul_indicator (hf : prodable f) (s : set Œ≤) :
  prodable (s.mul_indicator f) :=
hf.prodable_of_eq_one_or_self $ set.mul_indicator_eq_one_or_self _ _

@[to_additive] lemma prodable.comp_injective {i : Œ≥ ‚Üí Œ≤} (hf : prodable f) (hi : injective i) :
  prodable (f ‚àò i) :=
begin
  simpa only [set.mul_indicator_range_comp]
    using (hi.prodable_iff _).2 (hf.mul_indicator (set.range i)),
  exact Œª x hx, set.mul_indicator_of_not_mem hx _
end

@[to_additive] protected lemma prodable.subtype (hf : prodable f) (s : set Œ≤) :
  prodable (f ‚àò coe : s ‚Üí Œ±) :=
hf.comp_injective subtype.coe_injective

@[to_additive] lemma prodable_subtype_and_compl {s : set Œ≤} :
  prodable (Œª x : s, f x) ‚àß prodable (Œª x : s·∂ú, f x) ‚Üî prodable f :=
‚ü®and_imp.2 prodable.mul_compl, Œª h, ‚ü®h.subtype s, h.subtype s·∂ú‚ü©‚ü©

@[to_additive]
lemma prodable.sigma_factor {Œ≥ : Œ≤ ‚Üí Type*} {f : (Œ£ b, Œ≥ b) ‚Üí Œ±} (ha : prodable f) (b : Œ≤) :
  prodable (Œª c, f ‚ü®b, c‚ü©) :=
ha.comp_injective sigma_mk_injective

@[to_additive]
protected lemma prodable.sigma {Œ≥ : Œ≤ ‚Üí Type*} {f : (Œ£ b, Œ≥ b) ‚Üí Œ±} (ha : prodable f) :
  prodable (Œª b, ‚àè'c, f ‚ü®b, c‚ü©) :=
ha.sigma' (Œª b, ha.sigma_factor b)

@[to_additive] lemma prodable.prod_factor {f : Œ≤ √ó Œ≥ ‚Üí Œ±} (h : prodable f) (b : Œ≤) :
  prodable (Œª c, f (b, c)) :=
h.comp_injective $ Œª c‚ÇÅ c‚ÇÇ h, (prod.ext_iff.1 h).2

@[to_additive]
lemma tprod_sigma [t1_space Œ±] {Œ≥ : Œ≤ ‚Üí Type*} {f : (Œ£ b, Œ≥ b) ‚Üí Œ±} (ha : prodable f) :
  ‚àè' p, f p = ‚àè' b c, f ‚ü®b, c‚ü© :=
tprod_sigma' (Œª b, ha.sigma_factor b) ha

@[to_additive tsum_prod] lemma tprod_prod [t1_space Œ±] {f : Œ≤ √ó Œ≥ ‚Üí Œ±} (h : prodable f) :
  ‚àè' p, f p = ‚àè' b c, f ‚ü®b, c‚ü© :=
tprod_prod' h h.prod_factor

@[to_additive] lemma tprod_comm [t1_space Œ±] {f : Œ≤ ‚Üí Œ≥ ‚Üí Œ±} (h : prodable (uncurry f)) :
  ‚àè' c b, f b c = ‚àè' b c, f b c :=
tprod_comm' h h.prod_factor h.prod_symm.prod_factor

@[to_additive]
lemma tprod_subtype_mul_tprod_subtype_compl [t2_space Œ±] (hf : prodable f) (s : set Œ≤) :
  (‚àè' x : s, f x) * ‚àè' x : s·∂ú, f x = ‚àè' x, f x :=
((hf.subtype s).has_prod.mul_compl (hf.subtype {x | x ‚àâ s}).has_prod).unique hf.has_prod

@[to_additive]
lemma prod_mul_tprod_subtype_compl [t2_space Œ±] (hf : prodable f) (s : finset Œ≤) :
  (‚àè x in s, f x) * ‚àè' x : {x // x ‚àâ s}, f x = ‚àè' x, f x :=
by { rw [‚Üêtprod_subtype_mul_tprod_subtype_compl hf s, finset.tprod_subtype'], refl }

end uniform_group

section topological_group
variables [topological_space G] [comm_group G] [topological_group G] {f : Œ± ‚Üí G}

@[to_additive]
lemma prodable.vanishing (hf : prodable f) ‚¶Ée : set G‚¶Ñ (he : e ‚àà ùìù (1 : G)) :
  ‚àÉ s : finset Œ±, ‚àÄ t, disjoint t s ‚Üí ‚àè k in t, f k ‚àà e :=
begin
  letI : uniform_space G := topological_group.to_uniform_space G,
  letI : uniform_group G := topological_comm_group_is_uniform,
  rcases hf with ‚ü®y, hy‚ü©,
  exact cauchy_seq_finset_prod_iff_vanishing.1 hy.cauchy_seq e he,
end

/-- Series divergence test: if `f` is a convergent series, then `f x` tends to one along
`cofinite`. -/
@[to_additive "Series divergence test: if `f` is a convergent series, then `f x` tends to zero along
`cofinite`."]
lemma prodable.tendsto_cofinite_one (hf : prodable f) : tendsto f cofinite (ùìù 1) :=
begin
  intros e he,
  rw [filter.mem_map],
  rcases hf.vanishing he with ‚ü®s, hs‚ü©,
  refine s.eventually_cofinite_nmem.mono (Œª x hx, _),
  by simpa using hs {x} (disjoint_singleton_left.2 hx)
end

@[to_additive] lemma prodable.tendsto_at_top_one {f : ‚Ñï ‚Üí G} (hf : prodable f) :
  tendsto f at_top (ùìù 1) :=
by { rw ‚Üênat.cofinite_eq_at_top, exact hf.tendsto_cofinite_one }

lemma summable.tendsto_top_of_pos {Œ± : Type*}
  [linear_ordered_field Œ±] [topological_space Œ±] [order_topology Œ±] {f : ‚Ñï ‚Üí Œ±}
  (hf : summable f‚Åª¬π) (hf' : ‚àÄ n, 0 < f n) : tendsto f at_top at_top :=
begin
  rw ‚Üêinv_inv f,
  apply filter.tendsto.inv_tendsto_zero,
  apply tendsto_nhds_within_of_tendsto_nhds_of_eventually_within _
    (summable.tendsto_at_top_zero hf),
  rw eventually_iff_exists_mem,
  refine ‚ü®set.Ioi 0, Ioi_mem_at_top _, Œª _ _, _‚ü©,
  rw [set.mem_Ioi, inv_eq_one_div, one_div, pi.inv_apply, _root_.inv_pos],
  exact hf' _,
end

end topological_group

section preorder

variables {E : Type*} [preorder E] [comm_monoid E] [topological_space E] [order_closed_topology E]
  [t2_space E]

@[to_additive] lemma tprod_le_of_prod_range_le {f : ‚Ñï ‚Üí E} {c : E} (hprod : prodable f)
  (h : ‚àÄ n, ‚àè i in finset.range n, f i ‚â§ c) : ‚àè' n, f n ‚â§ c :=
let ‚ü®l, hl‚ü© := hprod in hl.tprod_eq.symm ‚ñ∏ le_of_tendsto' hl.tendsto_prod_nat h

end preorder

section linear_order

/-! For infinite sums taking values in a linearly ordered monoid, the existence of a least upper
bound for the finite sums is a criterion for summability.

This criterion is useful when applied in a linearly ordered monoid which is also a complete or
conditionally complete linear order, such as `‚Ñù`, `‚Ñù‚â•0`, `‚Ñù‚â•0‚àû`, because it is then easy to check
the existence of a least upper bound.
-/

@[to_additive] lemma has_prod_of_is_lub_of_one_le [linear_ordered_comm_monoid Œ≤]
  [topological_space Œ≤] [order_topology Œ≤] {f : Œ± ‚Üí Œ≤} (b : Œ≤) (h : ‚àÄ b, 1 ‚â§ f b)
  (hf : is_lub (set.range (Œª s, ‚àè a in s, f a)) b) :
  has_prod f b :=
tendsto_at_top_is_lub (finset.prod_mono_set_of_one_le' h) hf

@[to_additive] lemma has_prod_of_is_lub [canonically_linear_ordered_monoid Œ≤] [topological_space Œ≤]
  [order_topology Œ≤] {f : Œ± ‚Üí Œ≤} (b : Œ≤) (hf : is_lub (set.range (Œª s, ‚àè a in s, f a)) b) :
  has_prod f b :=
tendsto_at_top_is_lub (finset.prod_mono_set' f) hf

lemma summable_abs_iff [linear_ordered_add_comm_group Œ≤] [uniform_space Œ≤]
  [uniform_add_group Œ≤] [complete_space Œ≤] {f : Œ± ‚Üí Œ≤} :
  summable (Œª x, |f x|) ‚Üî summable f :=
have h1 : ‚àÄ x : {x | 0 ‚â§ f x}, |f x| = f x := Œª x, abs_of_nonneg x.2,
have h2 : ‚àÄ x : {x | 0 ‚â§ f x}·∂ú, |f x| = -f x := Œª x, abs_of_neg (not_le.1 x.2),
calc summable (Œª x, |f x|) ‚Üî
  summable (Œª x : {x | 0 ‚â§ f x}, |f x|) ‚àß summable (Œª x : {x | 0 ‚â§ f x}·∂ú, |f x|) :
  summable_subtype_and_compl.symm
... ‚Üî summable (Œª x : {x | 0 ‚â§ f x}, f x) ‚àß summable (Œª x : {x | 0 ‚â§ f x}·∂ú, -f x) :
  by simp only [h1, h2]
... ‚Üî _ : by simp only [summable_neg_iff, summable_subtype_and_compl]

alias summable_abs_iff ‚Üî summable.of_abs summable.abs

lemma finite_of_summable_const [linear_ordered_add_comm_group Œ≤] [archimedean Œ≤]
  [topological_space Œ≤] [order_closed_topology Œ≤] {b : Œ≤} (hb : 0 < b)
  (hf : summable (Œª a : Œ±, b)) :
  set.finite (set.univ : set Œ±) :=
begin
  have H : ‚àÄ s : finset Œ±, s.card ‚Ä¢ b ‚â§ ‚àë' a : Œ±, b,
  { intros s,
    simpa using sum_le_has_sum s (Œª a ha, hb.le) hf.has_sum },
  obtain ‚ü®n, hn‚ü© := archimedean.arch (‚àë' a : Œ±, b) hb,
  have : ‚àÄ s : finset Œ±, s.card ‚â§ n,
  { intros s,
    simpa [nsmul_le_nsmul_iff hb] using (H s).trans hn },
  haveI : fintype Œ± := fintype_of_finset_card_le n this,
  exact set.finite_univ
end

end linear_order

section cauchy_seq
open filter

/-- If the extended distance between consecutive points of a sequence is estimated
by a summable series of `nnreal`s, then the original sequence is a Cauchy sequence. -/
lemma cauchy_seq_of_edist_le_of_summable [pseudo_emetric_space Œ±] {f : ‚Ñï ‚Üí Œ±} (d : ‚Ñï ‚Üí ‚Ñù‚â•0)
  (hf : ‚àÄ n, edist (f n) (f n.succ) ‚â§ d n) (hd : summable d) : cauchy_seq f :=
begin
  refine emetric.cauchy_seq_iff_nnreal.2 (Œª Œµ Œµpos, _),
  -- Actually we need partial sums of `d` to be a Cauchy sequence
  replace hd : cauchy_seq (Œª (n : ‚Ñï), ‚àë x in range n, d x) :=
    let ‚ü®_, H‚ü© := hd in H.tendsto_sum_nat.cauchy_seq,
  -- Now we take the same `N` as in one of the definitions of a Cauchy sequence
  refine (metric.cauchy_seq_iff'.1 hd Œµ (nnreal.coe_pos.2 Œµpos)).imp (Œª N hN n hn, _),
  have hsum := hN n hn,
  -- We simplify the known inequality
  rw [dist_nndist, nnreal.nndist_eq, ‚Üê sum_range_add_sum_Ico _ hn, add_tsub_cancel_left] at hsum,
  norm_cast at hsum,
  replace hsum := lt_of_le_of_lt (le_max_left _ _) hsum,
  rw edist_comm,
  -- Then use `hf` to simplify the goal to the same form
  apply lt_of_le_of_lt (edist_le_Ico_sum_of_edist_le hn (Œª k _ _, hf k)),
  assumption_mod_cast
end

/-- If the distance between consecutive points of a sequence is estimated by a summable series,
then the original sequence is a Cauchy sequence. -/
lemma cauchy_seq_of_dist_le_of_summable [pseudo_metric_space Œ±] {f : ‚Ñï ‚Üí Œ±} (d : ‚Ñï ‚Üí ‚Ñù)
  (hf : ‚àÄ n, dist (f n) (f n.succ) ‚â§ d n) (hd : summable d) : cauchy_seq f :=
begin
  refine metric.cauchy_seq_iff'.2 (ŒªŒµ Œµpos, _),
  replace hd : cauchy_seq (Œª (n : ‚Ñï), ‚àë x in range n, d x) :=
    let ‚ü®_, H‚ü© := hd in H.tendsto_sum_nat.cauchy_seq,
  refine (metric.cauchy_seq_iff'.1 hd Œµ Œµpos).imp (Œª N hN n hn, _),
  have hsum := hN n hn,
  rw [real.dist_eq, ‚Üê sum_Ico_eq_sub _ hn] at hsum,
  calc dist (f n) (f N) = dist (f N) (f n) : dist_comm _ _
  ... ‚â§ ‚àë x in Ico N n, d x : dist_le_Ico_sum_of_dist_le hn (Œª k _ _, hf k)
  ... ‚â§ |‚àë x in Ico N n, d x| : le_abs_self _
  ... < Œµ : hsum
end

lemma cauchy_seq_of_summable_dist [pseudo_metric_space Œ±] {f : ‚Ñï ‚Üí Œ±}
  (h : summable (Œªn, dist (f n) (f n.succ))) : cauchy_seq f :=
cauchy_seq_of_dist_le_of_summable _ (Œª _, le_rfl) h

lemma dist_le_tsum_of_dist_le_of_tendsto [pseudo_metric_space Œ±] {f : ‚Ñï ‚Üí Œ±} (d : ‚Ñï ‚Üí ‚Ñù)
  (hf : ‚àÄ n, dist (f n) (f n.succ) ‚â§ d n) (hd : summable d) {a : Œ±} (ha : tendsto f at_top (ùìù a))
  (n : ‚Ñï) :
  dist (f n) a ‚â§ ‚àë' m, d (n + m) :=
begin
  refine le_of_tendsto (tendsto_const_nhds.dist ha)
    (eventually_at_top.2 ‚ü®n, Œª m hnm, _‚ü©),
  refine le_trans (dist_le_Ico_sum_of_dist_le hnm (Œª k _ _, hf k)) _,
  rw [sum_Ico_eq_sum_range],
  refine sum_le_tsum (range _) (Œª _ _, le_trans dist_nonneg (hf _)) _,
  exact hd.comp_injective (add_right_injective n)
end

lemma dist_le_tsum_of_dist_le_of_tendsto‚ÇÄ [pseudo_metric_space Œ±] {f : ‚Ñï ‚Üí Œ±} (d : ‚Ñï ‚Üí ‚Ñù)
  (hf : ‚àÄ n, dist (f n) (f n.succ) ‚â§ d n) (hd : summable d) {a : Œ±} (ha : tendsto f at_top (ùìù a)) :
  dist (f 0) a ‚â§ tsum d :=
by simpa only [zero_add] using dist_le_tsum_of_dist_le_of_tendsto d hf hd ha 0

lemma dist_le_tsum_dist_of_tendsto [pseudo_metric_space Œ±] {f : ‚Ñï ‚Üí Œ±}
  (h : summable (Œªn, dist (f n) (f n.succ))) {a : Œ±} (ha : tendsto f at_top (ùìù a)) (n) :
  dist (f n) a ‚â§ ‚àë' m, dist (f (n+m)) (f (n+m).succ) :=
show dist (f n) a ‚â§ ‚àë' m, (Œªx, dist (f x) (f x.succ)) (n + m), from
dist_le_tsum_of_dist_le_of_tendsto (Œª n, dist (f n) (f n.succ)) (Œª _, le_rfl) h ha n

lemma dist_le_tsum_dist_of_tendsto‚ÇÄ [pseudo_metric_space Œ±] {f : ‚Ñï ‚Üí Œ±}
  (h : summable (Œªn, dist (f n) (f n.succ))) {a : Œ±} (ha : tendsto f at_top (ùìù a)) :
  dist (f 0) a ‚â§ ‚àë' n, dist (f n) (f n.succ) :=
by simpa only [zero_add] using dist_le_tsum_dist_of_tendsto h ha 0

end cauchy_seq

/-! ## Multipliying two infinite sums

In this section, we prove various results about `(‚àë' x : Œ≤, f x) * (‚àë' y : Œ≥, g y)`. Note that we
always assume that the family `Œª x : Œ≤ √ó Œ≥, f x.1 * g x.2` is summable, since there is no way to
deduce this from the summmabilities of `f` and `g` in general, but if you are working in a normed
space, you may want to use the analogous lemmas in `analysis/normed_space/basic`
(e.g `tsum_mul_tsum_of_summable_norm`).

We first establish results about arbitrary index types, `Œ≤` and `Œ≥`, and then we specialize to
`Œ≤ = Œ≥ = ‚Ñï` to prove the Cauchy product formula (see `tsum_mul_tsum_eq_tsum_sum_antidiagonal`).

### Arbitrary index types
-/

section tsum_mul_tsum

variables [topological_space Œ±] [t3_space Œ±] [non_unital_non_assoc_semiring Œ±]
  [topological_semiring Œ±] {f : Œ≤ ‚Üí Œ±} {g : Œ≥ ‚Üí Œ±} {s t u : Œ±}

lemma has_sum.mul_eq (hf : has_sum f s) (hg : has_sum g t)
  (hfg : has_sum (Œª (x : Œ≤ √ó Œ≥), f x.1 * g x.2) u) :
  s * t = u :=
have key‚ÇÅ : has_sum (Œª b, f b * t) (s * t),
  from hf.mul_right t,
have this : ‚àÄ b : Œ≤, has_sum (Œª c : Œ≥, f b * g c) (f b * t),
  from Œª b, hg.mul_left (f b),
have key‚ÇÇ : has_sum (Œª b, f b * t) u,
  from has_sum.prod_fiberwise hfg this,
key‚ÇÅ.unique key‚ÇÇ

lemma has_sum.mul (hf : has_sum f s) (hg : has_sum g t)
  (hfg : summable (Œª (x : Œ≤ √ó Œ≥), f x.1 * g x.2)) :
  has_sum (Œª (x : Œ≤ √ó Œ≥), f x.1 * g x.2) (s * t) :=
let ‚ü®u, hu‚ü© := hfg in
(hf.mul_eq hg hu).symm ‚ñ∏ hu

/-- Product of two infinites sums indexed by arbitrary types.
    See also `tsum_mul_tsum_of_summable_norm` if `f` and `g` are abolutely summable. -/
lemma tsum_mul_tsum (hf : summable f) (hg : summable g)
  (hfg : summable (Œª (x : Œ≤ √ó Œ≥), f x.1 * g x.2)) :
  (‚àë' x, f x) * (‚àë' y, g y) = (‚àë' z : Œ≤ √ó Œ≥, f z.1 * g z.2) :=
hf.has_sum.mul_eq hg.has_sum hfg.has_sum

end tsum_mul_tsum

section cauchy_product

/-! ### `‚Ñï`-indexed families (Cauchy product)

We prove two versions of the Cauchy product formula. The first one is
`tsum_mul_tsum_eq_tsum_sum_range`, where the `n`-th term is a sum over `finset.range (n+1)`
involving `nat` subtraction.
In order to avoid `nat` subtraction, we also provide `tsum_mul_tsum_eq_tsum_sum_antidiagonal`,
where the `n`-th term is a sum over all pairs `(k, l)` such that `k+l=n`, which corresponds to the
`finset` `finset.nat.antidiagonal n` -/

variables {f : ‚Ñï ‚Üí Œ±} {g : ‚Ñï ‚Üí Œ±}

open finset

variables [topological_space Œ±] [non_unital_non_assoc_semiring Œ±]

/- The family `(k, l) : ‚Ñï √ó ‚Ñï ‚Ü¶ f k * g l` is summable if and only if the family
`(n, k, l) : Œ£ (n : ‚Ñï), nat.antidiagonal n ‚Ü¶ f k * g l` is summable. -/
lemma summable_mul_prod_iff_summable_mul_sigma_antidiagonal {f g : ‚Ñï ‚Üí Œ±} :
  summable (Œª x : ‚Ñï √ó ‚Ñï, f x.1 * g x.2) ‚Üî
  summable (Œª x : (Œ£ (n : ‚Ñï), nat.antidiagonal n), f (x.2 : ‚Ñï √ó ‚Ñï).1 * g (x.2 : ‚Ñï √ó ‚Ñï).2) :=
nat.sigma_antidiagonal_equiv_prod.summable_iff.symm

variables [t3_space Œ±] [topological_semiring Œ±]

lemma summable_sum_mul_antidiagonal_of_summable_mul {f g : ‚Ñï ‚Üí Œ±}
  (h : summable (Œª x : ‚Ñï √ó ‚Ñï, f x.1 * g x.2)) :
  summable (Œª n, ‚àë kl in nat.antidiagonal n, f kl.1 * g kl.2) :=
begin
  rw summable_mul_prod_iff_summable_mul_sigma_antidiagonal at h,
  conv {congr, funext, rw [‚Üê finset.sum_finset_coe, ‚Üê tsum_fintype]},
  exact h.sigma' (Œª n, (has_sum_fintype _).summable),
end

/-- The Cauchy product formula for the product of two infinites sums indexed by `‚Ñï`,
    expressed by summing on `finset.nat.antidiagonal`.
    See also `tsum_mul_tsum_eq_tsum_sum_antidiagonal_of_summable_norm`
    if `f` and `g` are absolutely summable. -/
lemma tsum_mul_tsum_eq_tsum_sum_antidiagonal (hf : summable f) (hg : summable g)
  (hfg : summable (Œª (x : ‚Ñï √ó ‚Ñï), f x.1 * g x.2)) :
  (‚àë' n, f n) * (‚àë' n, g n) = (‚àë' n, ‚àë kl in nat.antidiagonal n, f kl.1 * g kl.2) :=
begin
  conv_rhs {congr, funext, rw [‚Üê finset.sum_finset_coe, ‚Üê tsum_fintype]},
  rw [tsum_mul_tsum hf hg hfg, ‚Üê nat.sigma_antidiagonal_equiv_prod.tsum_eq (_ : ‚Ñï √ó ‚Ñï ‚Üí Œ±)],
  exact tsum_sigma' (Œª n, (has_sum_fintype _).summable)
    (summable_mul_prod_iff_summable_mul_sigma_antidiagonal.mp hfg)
end

lemma summable_sum_mul_range_of_summable_mul {f g : ‚Ñï ‚Üí Œ±}
  (h : summable (Œª x : ‚Ñï √ó ‚Ñï, f x.1 * g x.2)) :
  summable (Œª n, ‚àë k in range (n+1), f k * g (n - k)) :=
begin
  simp_rw ‚Üê nat.sum_antidiagonal_eq_sum_range_succ (Œª k l, f k * g l),
  exact summable_sum_mul_antidiagonal_of_summable_mul h
end

/-- The Cauchy product formula for the product of two infinites sums indexed by `‚Ñï`,
    expressed by summing on `finset.range`.
    See also `tsum_mul_tsum_eq_tsum_sum_range_of_summable_norm`
    if `f` and `g` are absolutely summable. -/
lemma tsum_mul_tsum_eq_tsum_sum_range (hf : summable f) (hg : summable g)
  (hfg : summable (Œª (x : ‚Ñï √ó ‚Ñï), f x.1 * g x.2)) :
  (‚àë' n, f n) * (‚àë' n, g n) = (‚àë' n, ‚àë k in range (n+1), f k * g (n - k)) :=
begin
  simp_rw ‚Üê nat.sum_antidiagonal_eq_sum_range_succ (Œª k l, f k * g l),
  exact tsum_mul_tsum_eq_tsum_sum_antidiagonal hf hg hfg
end

end cauchy_product
