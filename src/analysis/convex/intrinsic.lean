/-
Copyright (c) 2022 Paul Reichert. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Paul Reichert, Ya√´l Dillies
-/
import analysis.convex.basic
import analysis.normed_space.add_torsor_bases
import analysis.normed_space.basic
import analysis.normed_space.linear_isometry
import data.real.basic
import data.set.pointwise
import linear_algebra.affine_space.pointwise

/-!
# Intrinsic frontier and interior

This file defines the intrinsic frontier and intrinsic interior of a set.

## References

See chapter 8 of [Barry Simon, *Convexity*][simon2011] or chapter 1 of
[Rolf Schneider, *Convex Bodies: The Brunn-Minkowski theory*][schneider2013].
-/

open_locale pointwise

-- MOVETO data.set.pointwise

lemma set.vadd_vsub_vadd_cancel_left {V : Type} [add_comm_group V]
  (x : V) (A B : set V) :
(x +·µ• A) -·µ• (x +·µ• B) = A -·µ• B :=
begin
  ext, split,
  { rintro ‚ü®-, -, ‚ü®a, ha, rfl‚ü©, ‚ü®b, hb, rfl‚ü©, rfl‚ü©,
    rw [vadd_vsub_vadd_cancel_left x],
    exact ‚ü®a, b, ha, hb, rfl‚ü© },
  { rintro ‚ü®a, b, ha, hb, rfl‚ü©,
    rw [‚Üêvadd_vsub_vadd_cancel_left x],
    exact ‚ü®_, _, ‚ü®a, ha, rfl‚ü©, ‚ü®b, hb, rfl‚ü©, rfl‚ü© },
end

-- MOVETO linear_algebra.affine_space.affine_subspace

/-- The inclusion of an affine subspace as an affine map. -/
def affine_subspace.inclusion_affine {R V P : Type} [ring R] [add_comm_group V] [module R V]
  [add_torsor V P] (E : affine_subspace R P) [nonempty E] : E ‚Üí·µÉ[R] P :=
begin
  refine ‚ü®coe, E.direction.subtype, by tauto‚ü©,
end

/-- A nonempty affine subspace of a `normed_add_torsor` is itself a `normed_add_torsor`. -/
@[nolint fails_quickly] -- Because of the add_torsor.nonempty instance.
instance affine_subspace.to_normed_add_torsor {R V P : Type*} [ring R]
  [seminormed_add_comm_group V]
  [pseudo_metric_space P] [module R V] [normed_add_torsor V P]
  (s : affine_subspace R P) [nonempty s] : normed_add_torsor s.direction s :=
{ dist_eq_norm' := Œª x y, normed_add_torsor.dist_eq_norm' ‚Üëx ‚Üëy,
  ..affine_subspace.to_add_torsor s }

/-- The inclusion of an affine subspace of a normed affine space as an affine isometry. -/
def affine_subspace.inclusion_affine_isometry {ùïú V P : Type} [normed_field ùïú]
  [seminormed_add_comm_group V] [normed_space ùïú V] [pseudo_metric_space P] [normed_add_torsor V P]
  (E : affine_subspace ùïú P) [nonempty E] : E ‚Üí·µÉ‚Å±[ùïú] P :=
begin
  refine ‚ü®E.inclusion_affine, by tauto‚ü©,
end

instance affine_subspace.nonempty_map {R V‚ÇÅ P‚ÇÅ V‚ÇÇ P‚ÇÇ : Type}
  [ring R] [add_comm_group V‚ÇÅ] [add_comm_group V‚ÇÇ] [module R V‚ÇÅ] [module R V‚ÇÇ]
  [add_torsor V‚ÇÅ P‚ÇÅ] [add_torsor V‚ÇÇ P‚ÇÇ] {E : affine_subspace R P‚ÇÅ} [Ene : nonempty E]
  {œÜ : P‚ÇÅ ‚Üí·µÉ[R] P‚ÇÇ} : nonempty (E.map œÜ) :=
begin
  obtain ‚ü®x, hx‚ü© := id Ene,
  refine ‚ü®‚ü®œÜ x, affine_subspace.mem_map.mpr ‚ü®x, hx, rfl‚ü©‚ü©‚ü©,
end

-- MOVETO algebra.module.linear_map

/-- Restrict domain and codomain of a linear map to the given submodules. -/
def linear_map.restrict' {R V‚ÇÅ V‚ÇÇ : Type}
  [ring R] [add_comm_group V‚ÇÅ] [add_comm_group V‚ÇÇ] [module R V‚ÇÅ] [module R V‚ÇÇ]
  (œÜ : V‚ÇÅ ‚Üí‚Çó[R] V‚ÇÇ) {E : submodule R V‚ÇÅ} {F : submodule R V‚ÇÇ}
  (hEF : E.map œÜ ‚â§ F) : E ‚Üí‚Çó[R] F :=
begin
  refine ‚ü®_, _, _‚ü©,
  { exact Œª x, ‚ü®œÜ x, hEF $ submodule.mem_map.mpr ‚ü®x, x.property, rfl‚ü©‚ü© },
  all_goals { intros x y,
              simp only [subtype.ext_iff, subtype.coe_mk, submodule.coe_add, submodule.coe_smul],
              apply_rules [œÜ.map_add, œÜ.map_smul] },
end

lemma linear_map.restrict'.coe_apply {R V‚ÇÅ V‚ÇÇ : Type}
  [ring R] [add_comm_group V‚ÇÅ] [add_comm_group V‚ÇÇ] [module R V‚ÇÅ] [module R V‚ÇÇ]
  (œÜ : V‚ÇÅ ‚Üí‚Çó[R] V‚ÇÇ) {E : submodule R V‚ÇÅ} {F : submodule R V‚ÇÇ}
  (hEF : E.map œÜ ‚â§ F) (x : E) :
‚Üë(œÜ.restrict' hEF x) = œÜ x := rfl

-- MOVETO linear_algebra.affine_space.affine_map

/-- Restrict domain and codomain of an affine map to the given submodules. -/
def affine_map.restrict {R V‚ÇÅ V‚ÇÇ P‚ÇÅ P‚ÇÇ : Type}
  [ring R] [add_comm_group V‚ÇÅ] [add_comm_group V‚ÇÇ] [module R V‚ÇÅ]
  [module R V‚ÇÇ]
  [add_torsor V‚ÇÅ P‚ÇÅ] [add_torsor V‚ÇÇ P‚ÇÇ]
  (œÜ : P‚ÇÅ ‚Üí·µÉ[R] P‚ÇÇ) {E : affine_subspace R P‚ÇÅ} {F : affine_subspace R P‚ÇÇ}
  [nonempty E] [nonempty F]
  (hEF : E.map œÜ ‚â§ F) : E ‚Üí·µÉ[R] F :=
begin
  refine ‚ü®_, _, _‚ü©,
  { exact Œª x, ‚ü®œÜ x, hEF $ affine_subspace.mem_map.mpr ‚ü®x, x.property, rfl‚ü©‚ü© },
  { refine œÜ.linear.restrict' _,
    rw [‚Üêaffine_subspace.map_direction],
    exact affine_subspace.direction_le hEF },
  { intros p v,
    simp only [subtype.ext_iff, subtype.coe_mk, affine_subspace.coe_vadd],
    apply affine_map.map_vadd },
end

lemma affine_map.restrict.coe_apply {R V‚ÇÅ V‚ÇÇ P‚ÇÅ P‚ÇÇ : Type}
  [ring R] [add_comm_group V‚ÇÅ] [add_comm_group V‚ÇÇ] [module R V‚ÇÅ]
  [module R V‚ÇÇ]
  [add_torsor V‚ÇÅ P‚ÇÅ] [add_torsor V‚ÇÇ P‚ÇÇ]
  (œÜ : P‚ÇÅ ‚Üí·µÉ[R] P‚ÇÇ) {E : affine_subspace R P‚ÇÅ} {F : affine_subspace R P‚ÇÇ}
  [nonempty E] [nonempty F]
  (hEF : E.map œÜ ‚â§ F) (x : E) :
‚Üë(œÜ.restrict hEF x) = œÜ x := rfl

lemma affine_map.restrict.linear {R V‚ÇÅ V‚ÇÇ P‚ÇÅ P‚ÇÇ : Type}
  [ring R] [add_comm_group V‚ÇÅ] [add_comm_group V‚ÇÇ] [module R V‚ÇÅ]
  [module R V‚ÇÇ]
  [add_torsor V‚ÇÅ P‚ÇÅ] [add_torsor V‚ÇÇ P‚ÇÇ]
  (œÜ : P‚ÇÅ ‚Üí·µÉ[R] P‚ÇÇ) {E : affine_subspace R P‚ÇÅ} {F : affine_subspace R P‚ÇÇ}
  [nonempty E] [nonempty F]
  (hEF : E.map œÜ ‚â§ F) :
(œÜ.restrict hEF).linear = œÜ.linear.restrict'
  (by { rw [‚Üêaffine_subspace.map_direction], exact affine_subspace.direction_le hEF }) := rfl

lemma affine_map.restrict.injective {R V‚ÇÅ V‚ÇÇ P‚ÇÅ P‚ÇÇ : Type}
  [ring R] [add_comm_group V‚ÇÅ] [add_comm_group V‚ÇÇ] [module R V‚ÇÅ]
  [module R V‚ÇÇ]
  [add_torsor V‚ÇÅ P‚ÇÅ] [add_torsor V‚ÇÇ P‚ÇÇ]
  {œÜ : P‚ÇÅ ‚Üí·µÉ[R] P‚ÇÇ}
  (hœÜ : function.injective œÜ) {E : affine_subspace R P‚ÇÅ} {F : affine_subspace R P‚ÇÇ}
  [nonempty E] [nonempty F]
  (hEF : E.map œÜ ‚â§ F) :
function.injective (affine_map.restrict œÜ hEF) :=
begin
  intros x y h,
  simp only [subtype.ext_iff, subtype.coe_mk, affine_map.restrict.coe_apply] at h ‚ä¢,
  exact hœÜ h,
end

lemma affine_map.restrict.surjective {R V‚ÇÅ V‚ÇÇ P‚ÇÅ P‚ÇÇ : Type}
  [ring R] [add_comm_group V‚ÇÅ] [add_comm_group V‚ÇÇ] [module R V‚ÇÅ]
  [module R V‚ÇÇ] [add_torsor V‚ÇÅ P‚ÇÅ] [add_torsor V‚ÇÇ P‚ÇÇ]
  (œÜ : P‚ÇÅ ‚Üí·µÉ[R] P‚ÇÇ) {E : affine_subspace R P‚ÇÅ} [nonempty E] :
function.surjective (affine_map.restrict œÜ (le_refl (E.map œÜ))) :=
begin
  rintro ‚ü®x, hx : x ‚àà E.map œÜ‚ü©,
  rw [affine_subspace.mem_map] at hx,
  obtain ‚ü®y, hy, rfl‚ü© := hx,
  exact ‚ü®‚ü®y, hy‚ü©, rfl‚ü©,
end

lemma affine_map.bijective_iff_linear_bijective {R V‚ÇÅ V‚ÇÇ P‚ÇÅ P‚ÇÇ : Type}
  [ring R] [add_comm_group V‚ÇÅ] [add_comm_group V‚ÇÇ] [module R V‚ÇÅ]
  [module R V‚ÇÇ] [add_torsor V‚ÇÅ P‚ÇÅ] [add_torsor V‚ÇÇ P‚ÇÇ]
  (œÜ : P‚ÇÅ ‚Üí·µÉ[R] P‚ÇÇ) :
function.bijective œÜ ‚Üî function.bijective œÜ.linear :=
begin
  simp only [function.bijective,
    œÜ.injective_iff_linear_injective, œÜ.surjective_iff_linear_surjective],
end

lemma affine_span_induction {R V P : Type} [ring R] [add_comm_group V] [module R V]
  [add_torsor V P] {x : P} {s : set P} {p : P ‚Üí Prop} (h : x ‚àà affine_span R s)
  (Hs : ‚àÄ x : P, x ‚àà s ‚Üí p x)
  (Hc : ‚àÄ (c : R) (u v w : P), p u ‚Üí p v ‚Üí p w ‚Üí p (c ‚Ä¢ (u -·µ• v) +·µ• w)) : p x :=
(@affine_span_le _ _ _ _ _ _ _ _ ‚ü®p, Hc‚ü©).mpr Hs h

lemma affine_span_induction' {R V P : Type} [ring R] [add_comm_group V] [module R V]
  [add_torsor V P] {x : P} {s : set P} {p : Œ† x, x ‚àà affine_span R s ‚Üí Prop}
  (h : x ‚àà affine_span R s)
  (Hs : ‚àÄ y (hys : y ‚àà s), p y (subset_affine_span R _ hys))
  (Hc : ‚àÄ (c : R) u hu v hv w hw, p u hu ‚Üí p v hv ‚Üí p w hw ‚Üí
    p (c ‚Ä¢ (u -·µ• v) +·µ• w) (affine_subspace.smul_vsub_vadd_mem _ _ hu hv hw)) : p x h :=
begin
  refine exists.elim _ (Œª (hx : x ‚àà affine_span R s) (hc : p x hx), hc),
  refine @affine_span_induction R V P _ _ _ _ _ _ _ h _ _,
  -- Why can't I substitute the following goals into the `refine` expression?
  { exact (Œª y hy, ‚ü®subset_affine_span _ _ hy, Hs y hy‚ü©) },
  { exact (Œª c u v w hu hv hw, exists.elim hu $ Œª hu' hu, exists.elim hv $ Œª hv' hv,
      exists.elim hw $ Œª hw' hw,
        ‚ü®affine_subspace.smul_vsub_vadd_mem _ _ hu' hv' hw', Hc _ _ _ _ _ _ _ hu hv hw‚ü©) },
end

lemma affine_span_affine_span_coe_preimage (R : Type) {V P : Type}
  [ring R] [add_comm_group V] [module R V] [add_torsor V P] (A : set P) [nonempty A] :
affine_span R ((coe : affine_span R A ‚Üí P) ‚Åª¬π' A) = ‚ä§ :=
begin
  rw [eq_top_iff],
  rintro ‚ü®x, hx‚ü© -,
  refine affine_span_induction' hx (Œª y hy, _) (Œª c u hu v hv w hw, _),
  { exact subset_affine_span _ _ hy },
  { exact affine_subspace.smul_vsub_vadd_mem _ _ },
end

-- MOVETO linear_algebra.affine_space.affine_equiv

/-- Bijective affine maps are affine isomorphisms. -/
noncomputable def affine_equiv.of_bijective {R V‚ÇÅ V‚ÇÇ P‚ÇÅ P‚ÇÇ : Type}
  [ring R] [add_comm_group V‚ÇÅ] [add_comm_group V‚ÇÇ] [module R V‚ÇÅ]
  [module R V‚ÇÇ]
  [add_torsor V‚ÇÅ P‚ÇÅ] [add_torsor V‚ÇÇ P‚ÇÇ]
  {œÜ : P‚ÇÅ ‚Üí·µÉ[R] P‚ÇÇ}
  (hœÜ : function.bijective œÜ) : P‚ÇÅ ‚âÉ·µÉ[R] P‚ÇÇ :=
begin
  refine ‚ü®equiv.of_bijective _ hœÜ, _, _‚ü©,
  { refine linear_equiv.of_bijective œÜ.linear _ _ ;
      obtain ‚ü®_, _‚ü© := hœÜ ;
      simp only [œÜ.injective_iff_linear_injective, œÜ.surjective_iff_linear_surjective] ;
      assumption },
  simp only [equiv.of_bijective_apply, linear_equiv.of_bijective_apply, affine_map.map_vadd,
    eq_self_iff_true, forall_const],
end

lemma affine_equiv.of_bijective_apply {R V‚ÇÅ V‚ÇÇ P‚ÇÅ P‚ÇÇ : Type}
  [ring R] [add_comm_group V‚ÇÅ] [add_comm_group V‚ÇÇ] [module R V‚ÇÅ]
  [module R V‚ÇÇ]
  [add_torsor V‚ÇÅ P‚ÇÅ] [add_torsor V‚ÇÇ P‚ÇÇ]
  {œÜ : P‚ÇÅ ‚Üí·µÉ[R] P‚ÇÇ}
  (hœÜ : function.bijective œÜ) (x : P‚ÇÅ) :
affine_equiv.of_bijective hœÜ x = œÜ x := rfl

lemma affine_equiv.of_bijective.symm_eq {R V‚ÇÅ V‚ÇÇ P‚ÇÅ P‚ÇÇ : Type}
  [ring R] [add_comm_group V‚ÇÅ] [add_comm_group V‚ÇÇ] [module R V‚ÇÅ]
  [module R V‚ÇÇ]
  [add_torsor V‚ÇÅ P‚ÇÅ] [add_torsor V‚ÇÇ P‚ÇÇ]
  {œÜ : P‚ÇÅ ‚Üí·µÉ[R] P‚ÇÇ}
  (hœÜ : function.bijective œÜ) :
(affine_equiv.of_bijective hœÜ).symm.to_equiv = (equiv.of_bijective _ hœÜ).symm := rfl

lemma affine_equiv.of_bijective_linear {R V‚ÇÅ V‚ÇÇ P‚ÇÅ P‚ÇÇ : Type}
  [ring R] [add_comm_group V‚ÇÅ] [add_comm_group V‚ÇÇ] [module R V‚ÇÅ]
  [module R V‚ÇÇ]
  [add_torsor V‚ÇÅ P‚ÇÅ] [add_torsor V‚ÇÇ P‚ÇÇ]
  {œÜ : P‚ÇÅ ‚Üí·µÉ[R] P‚ÇÇ}
  (hœÜ : function.bijective œÜ) :
(affine_equiv.of_bijective hœÜ).linear = linear_equiv.of_bijective œÜ.linear
  (œÜ.injective_iff_linear_injective.mpr hœÜ.1)
  (œÜ.surjective_iff_linear_surjective.mpr hœÜ.2) := rfl

lemma affine_equiv.image_symm {R V‚ÇÅ P‚ÇÅ V‚ÇÇ P‚ÇÇ : Type} [ring R]
  [add_comm_group V‚ÇÅ] [add_comm_group V‚ÇÇ]
  [module R V‚ÇÅ] [module R V‚ÇÇ]
  [add_torsor V‚ÇÅ P‚ÇÅ] [add_torsor V‚ÇÇ P‚ÇÇ]
  (f : P‚ÇÅ ‚âÉ·µÉ[R] P‚ÇÇ) :
set.image f.symm = set.preimage f :=
funext f.symm.to_equiv.image_eq_preimage

lemma affine_equiv.preimage_symm {R V‚ÇÅ P‚ÇÅ V‚ÇÇ P‚ÇÇ : Type} [ring R]
  [add_comm_group V‚ÇÅ] [add_comm_group V‚ÇÇ]
  [module R V‚ÇÅ] [module R V‚ÇÇ]
  [add_torsor V‚ÇÅ P‚ÇÅ] [add_torsor V‚ÇÇ P‚ÇÇ]
  (f : P‚ÇÅ ‚âÉ·µÉ[R] P‚ÇÇ) :
set.preimage f.symm = set.image f :=
(funext f.to_equiv.image_eq_preimage).symm

lemma affine_equiv.comap_span {R V‚ÇÅ P‚ÇÅ V‚ÇÇ P‚ÇÇ : Type} [ring R]
  [add_comm_group V‚ÇÅ] [add_comm_group V‚ÇÇ]
  [module R V‚ÇÅ] [module R V‚ÇÇ]
  [add_torsor V‚ÇÅ P‚ÇÅ] [add_torsor V‚ÇÇ P‚ÇÇ]
  (f : P‚ÇÅ ‚âÉ·µÉ[R] P‚ÇÇ) (A : set P‚ÇÇ) :
affine_subspace.comap f.to_affine_map (affine_span R A) = affine_span R (f ‚Åª¬π' A) :=
begin
  ext1,
  simp only [affine_subspace.coe_comap, ‚Üêaffine_equiv.image_symm],
  simp only [‚Üêaffine_equiv.coe_to_affine_map],
  rw [‚Üêaffine_subspace.map_span, affine_subspace.coe_map],
  exact (f.to_equiv.symm.image_eq_preimage _).symm,
end

-- MOVETO analysis.normed_space.affine_isometry

/-- Restriction of an affine isometry to an affine isomorphism, given a submodule of the domain. -/
noncomputable def affine_isometry.restrict_to_equiv {ùïú V‚ÇÅ V‚ÇÇ P‚ÇÅ P‚ÇÇ : Type}
  [normed_field ùïú] [seminormed_add_comm_group V‚ÇÅ] [seminormed_add_comm_group V‚ÇÇ] [normed_space ùïú V‚ÇÅ]
  [normed_space ùïú V‚ÇÇ] [metric_space P‚ÇÅ] [pseudo_metric_space P‚ÇÇ]
  [normed_add_torsor V‚ÇÅ P‚ÇÅ] [normed_add_torsor V‚ÇÇ P‚ÇÇ]
  (E : affine_subspace ùïú P‚ÇÅ) [nonempty E]
  (œÜ : P‚ÇÅ ‚Üí·µÉ‚Å±[ùïú] P‚ÇÇ) : E ‚âÉ·µÉ‚Å±[ùïú] E.map œÜ.to_affine_map :=
begin
  let f := œÜ.to_affine_map.restrict (le_refl (E.map œÜ.to_affine_map)),
  have fi : function.injective f := affine_map.restrict.injective œÜ.injective _,
  have fs : function.surjective f := affine_map.restrict.surjective _,
  have fb : function.bijective f := ‚ü®fi, fs‚ü©,
  refine ‚ü®affine_equiv.of_bijective fb, _‚ü©,
  { simp only [affine_equiv.of_bijective_linear, linear_equiv.of_bijective_apply],
    simp only [f, affine_map.restrict.linear],
    simp only [‚Üêsubmodule.norm_coe, linear_map.restrict'.coe_apply],
    simp only [affine_isometry.linear_eq_linear_isometry, linear_isometry.coe_to_linear_map,
      linear_isometry.norm_map, eq_self_iff_true, forall_const] },
end

lemma affine_isometry.restrict_to_equiv.apply_symm_apply {ùïú V‚ÇÅ V‚ÇÇ P‚ÇÅ P‚ÇÇ : Type}
  [normed_field ùïú] [seminormed_add_comm_group V‚ÇÅ] [seminormed_add_comm_group V‚ÇÇ] [normed_space ùïú V‚ÇÅ]
  [normed_space ùïú V‚ÇÇ] [metric_space P‚ÇÅ] [pseudo_metric_space P‚ÇÇ]
  [normed_add_torsor V‚ÇÅ P‚ÇÅ] [normed_add_torsor V‚ÇÇ P‚ÇÇ]
  {E : affine_subspace ùïú P‚ÇÅ} [nonempty E]
  {œÜ : P‚ÇÅ ‚Üí·µÉ‚Å±[ùïú] P‚ÇÇ} (x : E.map œÜ.to_affine_map) :
œÜ ((œÜ.restrict_to_equiv E).symm x) = x :=
begin
  simp only [affine_isometry.restrict_to_equiv,
    ‚Üêaffine_isometry_equiv.coe_to_affine_equiv, ‚Üêaffine_isometry_equiv.to_affine_equiv_symm],
  simp only [‚Üêaffine_equiv.coe_to_equiv, affine_equiv.of_bijective.symm_eq],
  have := equiv.of_bijective_apply_symm_apply (œÜ.to_affine_map.restrict _) _ x,
  replace this := congr_arg (coe : E.map œÜ.to_affine_map ‚Üí P‚ÇÇ) this,
  simp only [affine_map.restrict.coe_apply] at this,
  exact this,
end

lemma affine_isometry_equiv.comap_span {ùïú V‚ÇÅ P‚ÇÅ V‚ÇÇ P‚ÇÇ : Type} [normed_field ùïú]
  [normed_add_comm_group V‚ÇÅ] [normed_add_comm_group V‚ÇÇ]
  [pseudo_metric_space P‚ÇÅ] [pseudo_metric_space P‚ÇÇ] [normed_space ùïú V‚ÇÅ] [normed_space ùïú V‚ÇÇ]
  [normed_add_torsor V‚ÇÅ P‚ÇÅ] [normed_add_torsor V‚ÇÇ P‚ÇÇ]
  (f : P‚ÇÅ ‚âÉ·µÉ‚Å±[ùïú] P‚ÇÇ) (A : set P‚ÇÇ) :
affine_subspace.comap f.to_affine_equiv.to_affine_map (affine_span ùïú A) =
  affine_span ùïú (f ‚Åª¬π' A) :=
f.to_affine_equiv.comap_span A

lemma affine_isometry_equiv.map_span {ùïú V‚ÇÅ P‚ÇÅ V‚ÇÇ P‚ÇÇ : Type} [normed_field ùïú]
  [normed_add_comm_group V‚ÇÅ] [normed_add_comm_group V‚ÇÇ]
  [pseudo_metric_space P‚ÇÅ] [pseudo_metric_space P‚ÇÇ] [normed_space ùïú V‚ÇÅ] [normed_space ùïú V‚ÇÇ]
  [normed_add_torsor V‚ÇÅ P‚ÇÅ] [normed_add_torsor V‚ÇÇ P‚ÇÇ]
  (f : P‚ÇÅ ‚âÉ·µÉ‚Å±[ùïú] P‚ÇÇ) (A : set P‚ÇÅ) :
affine_subspace.map f.to_affine_equiv.to_affine_map (affine_span ùïú A) =
  affine_span ùïú (f '' A) :=
affine_subspace.map_span f.to_affine_equiv.to_affine_map A

-- MOVETO analysis.normed.group.add_torsor

/-- In a normed additive torsor, translation is an affine isometry. -/
def normed_add_torsor.vadd_affine_isometry (R P : Type) {V : Type}
  [normed_field R] [seminormed_add_comm_group V] [normed_space R V] [pseudo_metric_space P]
  [normed_add_torsor V P] (x : V):
P ‚Üí·µÉ‚Å±[R] P :=
begin
  refine ‚ü®‚ü®has_vadd.vadd x, linear_map.id, _‚ü©, _‚ü©,
  { intros p v,
    rw [vadd_vadd, vadd_vadd, add_comm],
    refl },
  { simp only [linear_map.id_coe, id.def, eq_self_iff_true, forall_const] },
end

-- MOVETO topology.homeomorph

lemma homeomorph.interior_nonempty_iff_image {Œ± Œ≤ : Type}
  [topological_space Œ±] [topological_space Œ≤] (œÜ : Œ± ‚âÉ‚Çú Œ≤) (A : set Œ±) :
(interior A).nonempty ‚Üî (interior (œÜ '' A)).nonempty :=
begin
  rw [‚ÜêœÜ.image_interior, set.nonempty_image_iff],
end

lemma homeomorph.interior_nonempty_iff_preimage {Œ± Œ≤ : Type}
  [topological_space Œ±] [topological_space Œ≤] (œÜ : Œ± ‚âÉ‚Çú Œ≤) (A : set Œ≤) :
(interior A).nonempty ‚Üî (interior (œÜ ‚Åª¬π' A)).nonempty :=
begin
  rw [‚ÜêœÜ.image_symm, œÜ.interior_nonempty_iff_image, ‚Üêset.image_comp, œÜ.self_comp_symm,
    set.image_id],
end

-- BEGIN intrinsic_interior.lean

/-- The intrinsic interior of a set is its interior considered as a set in its affine span. -/
def intrinsic_interior (R : Type) {V P : Type} [ring R] [seminormed_add_comm_group V] [module R V]
  [pseudo_metric_space P] [normed_add_torsor V P] -- have to redeclare variables to ensure that
                                                  -- all typeclasses are used
  (A : set P) := (coe : affine_span R A ‚Üí P) '' interior ((coe : affine_span R A ‚Üí P) ‚Åª¬π' A)

/-- The intrinsic frontier of a set is its frontier considered as a set in its affine span. -/
def intrinsic_frontier (R : Type) {V P : Type} [ring R] [seminormed_add_comm_group V] [module R V]
  [pseudo_metric_space P] [normed_add_torsor V P] (A : set P) :=
(coe : affine_span R A ‚Üí P) '' frontier ((coe : affine_span R A ‚Üí P) ‚Åª¬π' A)

/-- The intrinsic closure of a set is its closure considered as a set in its affine span. -/
def intrinsic_closure (R : Type) {V P : Type} [ring R] [seminormed_add_comm_group V] [module R V]
  [pseudo_metric_space P] [normed_add_torsor V P] (A : set P) :=
(coe : affine_span R A ‚Üí P) '' closure ((coe : affine_span R A ‚Üí P) ‚Åª¬π' A)

lemma intrinsic_interior_def (R : Type) {V P : Type} [ring R] [seminormed_add_comm_group V]
  [module R V] [pseudo_metric_space P] [normed_add_torsor V P] (A : set P) :
intrinsic_interior R A =
  (coe : affine_span R A ‚Üí P) '' interior ((coe : affine_span R A ‚Üí P) ‚Åª¬π' A) := rfl

lemma intrinsic_frontier_def (R : Type) {V P : Type} [ring R] [seminormed_add_comm_group V]
  [module R V] [pseudo_metric_space P] [normed_add_torsor V P] (A : set P) :
intrinsic_frontier R A =
  (coe : affine_span R A ‚Üí P) '' frontier ((coe : affine_span R A ‚Üí P) ‚Åª¬π' A) := rfl

lemma intrinsic_closure_def (R : Type) {V P : Type} [ring R] [seminormed_add_comm_group V]
  [module R V] [pseudo_metric_space P] [normed_add_torsor V P] (A : set P) :
intrinsic_closure R A =
  (coe : affine_span R A ‚Üí P) '' closure ((coe : affine_span R A ‚Üí P) ‚Åª¬π' A) := rfl

lemma intrinsic_interior_subset {R : Type} {V P : Type} [ring R] [seminormed_add_comm_group V]
  [module R V] [pseudo_metric_space P] [normed_add_torsor V P] (A : set P) :
intrinsic_interior R A ‚äÜ A :=
set.image_subset_iff.mpr interior_subset

lemma intrinsic_frontier_subset {R : Type} {V P : Type} [ring R] [seminormed_add_comm_group V]
  [module R V] [pseudo_metric_space P] [normed_add_torsor V P] {A : set P} (hA : is_closed A) :
intrinsic_frontier R A ‚äÜ A :=
set.image_subset_iff.mpr (hA.preimage continuous_induced_dom).frontier_subset

@[simp]
lemma intrinsic_interior_empty {R : Type} {V P : Type} [ring R] [seminormed_add_comm_group V]
  [module R V] [pseudo_metric_space P] [normed_add_torsor V P] :
intrinsic_interior R (‚àÖ : set P) = ‚àÖ :=
set.subset_empty_iff.mp $ intrinsic_interior_subset _

@[simp]
lemma intrinsic_frontier_empty {R : Type} {V P : Type} [ring R] [seminormed_add_comm_group V]
  [module R V] [pseudo_metric_space P] [normed_add_torsor V P] :
intrinsic_frontier R (‚àÖ : set P) = ‚àÖ :=
set.subset_empty_iff.mp $ intrinsic_frontier_subset is_closed_empty

lemma preimage_singleton_eq_univ {R : Type} {V P : Type} [ring R]
  [seminormed_add_comm_group V] [module R V] [pseudo_metric_space P] [normed_add_torsor V P]
  (x : P) : (coe : affine_span R ({x} : set P) ‚Üí P) ‚Åª¬π' {x} = set.univ :=
begin
  refine subset_antisymm (set.subset_univ _) _,
  rintro ‚ü®y, hy‚ü© -,
  obtain rfl := (affine_subspace.mem_affine_span_singleton _ _ _ _).mp hy,
  exact subtype.coe_mk _ _,
end

@[simp] lemma intrinsic_interior_singleton {R : Type} {V P : Type} [ring R]
  [seminormed_add_comm_group V] [module R V] [pseudo_metric_space P] [normed_add_torsor V P]
  (x : P) : intrinsic_interior R ({x} : set P) = {x} :=
begin
  rw [intrinsic_interior_def, interior_eq_iff_open.mpr], swap,
  { convert is_open_univ,
    exact preimage_singleton_eq_univ x },
  { rw [set.eq_singleton_iff_unique_mem],
    refine ‚ü®‚ü®‚ü®x, _‚ü©, subtype.coe_mk _ _, subtype.coe_mk _ _‚ü©, _‚ü©,
    { exact (affine_subspace.mem_affine_span_singleton _ _ _ _).mpr rfl },
    { rintro - ‚ü®‚ü®y, hy‚ÇÅ‚ü©, hy‚ÇÇ, rfl‚ü©,
      simpa only [set.mem_preimage, subtype.coe_mk, set.mem_singleton_iff] using hy‚ÇÇ } },
end

@[simp] lemma intrinsic_frontier_singleton  {R : Type} {V P : Type} [ring R]
  [seminormed_add_comm_group V] [module R V] [pseudo_metric_space P] [normed_add_torsor V P]
  (x : P) : intrinsic_frontier R ({x} : set P) = ‚àÖ :=
begin
  rw [intrinsic_frontier_def, set.image_eq_empty],
  convert frontier_univ,
  exact preimage_singleton_eq_univ x,
end

@[simp] lemma intrinsic_closure_diff_intrinsic_interior {R : Type} {V P : Type} [ring R]
  [seminormed_add_comm_group V] [module R V] [pseudo_metric_space P] [normed_add_torsor V P]
  (A : set P) :
intrinsic_closure R A \ intrinsic_interior R A = intrinsic_frontier R A :=
begin
  rw [intrinsic_frontier_def, intrinsic_closure_def, intrinsic_interior_def,
    ‚Üêset.image_diff subtype.coe_injective],
  refl,
end

/--
The image of the intrinsic interior under an affine isometry is
the relative interior of the image.
-/
@[simp] -- not sure whether this is the correct direction for simp
lemma affine_isometry.image_intrinsic_interior {ùïú V V‚ÇÇ P P‚ÇÇ: Type}
  [normed_field ùïú] [seminormed_add_comm_group V] [seminormed_add_comm_group V‚ÇÇ] [normed_space ùïú V]
  [normed_space ùïú V‚ÇÇ] [metric_space P] [pseudo_metric_space P‚ÇÇ] [normed_add_torsor V P]
  [normed_add_torsor V‚ÇÇ P‚ÇÇ]
  (œÜ : P ‚Üí·µÉ‚Å±[ùïú] P‚ÇÇ) (A : set P) :
intrinsic_interior ùïú (œÜ '' A) = œÜ '' intrinsic_interior ùïú A :=
begin
  rcases A.eq_empty_or_nonempty with rfl | hc,
  { simp only [intrinsic_interior_empty, set.image_empty] },
  haveI : nonempty A := hc.to_subtype,
  let f := œÜ.restrict_to_equiv (affine_span ùïú A),
  let f' := f.to_homeomorph,
  have : œÜ.to_affine_map ‚àò (coe : affine_span ùïú A ‚Üí P) ‚àò f'.symm =
    (coe : (affine_span ùïú A).map œÜ.to_affine_map ‚Üí P‚ÇÇ),
  { funext x,
    exact affine_isometry.restrict_to_equiv.apply_symm_apply _ },
  simp only [intrinsic_interior_def, ‚ÜêœÜ.coe_to_affine_map],
  rw [intrinsic_interior_def],
  rw [‚Üêaffine_subspace.map_span œÜ.to_affine_map A, ‚Üêthis,
    ‚Üêfunction.comp.assoc, set.image_comp _ f'.symm,
    set.image_comp _ (coe : affine_span ùïú A ‚Üí P), f'.symm.image_interior, f'.image_symm,
    ‚Üêset.preimage_comp, function.comp.assoc, f'.symm_comp_self, affine_isometry.coe_to_affine_map,
    function.comp.right_id, @set.preimage_comp _ P, œÜ.injective.preimage_image],
end

@[simp] lemma intrinsic_closure_eq_closure (ùïú : Type)
  [nontrivially_normed_field ùïú] [complete_space ùïú]
  {V P : Type} [normed_add_comm_group V] [normed_space ùïú V]
  [metric_space P] [normed_add_torsor V P]
  (A : set P) [finite_dimensional ùïú V] :
intrinsic_closure ùïú A = closure A :=
begin
  simp only [intrinsic_closure_def],
  ext x,
  simp only [mem_closure_iff, set.mem_image],
  split,
  { rintro ‚ü®x, h, rfl‚ü© o ho hxo,
    obtain ‚ü®z, hz‚ÇÅ, hz‚ÇÇ‚ü© := h ((coe : affine_span ùïú A ‚Üí P) ‚Åª¬π' o)
                   (continuous_induced_dom.is_open_preimage o ho) hxo,
    exact ‚ü®z, hz‚ÇÅ, hz‚ÇÇ‚ü© },
  { intro h,
    refine ‚ü®‚ü®x, _‚ü©, _‚ü©,
    { by_contradiction hc,
      obtain ‚ü®z, hz‚ÇÅ, hz‚ÇÇ‚ü© := h
        (affine_span ùïú A)·∂ú
        (affine_subspace.closed_of_finite_dimensional (affine_span ùïú A)).is_open_compl
        hc,
      exact hz‚ÇÅ (subset_affine_span ùïú A hz‚ÇÇ) },
    refine ‚ü®_, subtype.coe_mk _ _‚ü©,
    intros o ho hxo,
    have ho' := ho,
    rw [is_open_induced_iff] at ho,
    obtain ‚ü®o, ho, rfl‚ü© := ho,
    rw [set.mem_preimage, subtype.coe_mk] at hxo,
    obtain ‚ü®w, hwo, hwA‚ü© := h _ ho hxo,
    have : w ‚àà affine_span ùïú A := subset_affine_span ùïú A hwA,
    refine ‚ü®‚ü®w, subset_affine_span ùïú A hwA‚ü©, hwo, hwA‚ü© },
end

@[simp] lemma closure_diff_intrinsic_interior {ùïú : Type}
  [nontrivially_normed_field ùïú] [complete_space ùïú]
  {V P : Type} [normed_add_comm_group V] [normed_space ùïú V] [finite_dimensional ùïú V]
  [metric_space P] [normed_add_torsor V P]
  (A : set P) :
closure A \ intrinsic_interior ùïú A = intrinsic_frontier ùïú A :=
(intrinsic_closure_eq_closure ùïú A) ‚ñ∏ intrinsic_closure_diff_intrinsic_interior A

@[simp] lemma intrinsic_interior_vadd {ùïú V P : Type}
  [normed_field ùïú] [seminormed_add_comm_group V] [normed_space ùïú V]
  [metric_space P] [normed_add_torsor V P] (x : V) (A : set P) :
intrinsic_interior ùïú (x +·µ• A) = x +·µ• intrinsic_interior ùïú A :=
(normed_add_torsor.vadd_affine_isometry ùïú P x).image_intrinsic_interior A

lemma nonempty_intrinsic_interior_of_nonempty_of_convex
  {V : Type} [normed_add_comm_group V] [normed_space ‚Ñù V] [finite_dimensional ‚Ñù V]
  {A : set V} (Ane : A.nonempty) (Acv : convex ‚Ñù A) :
(intrinsic_interior ‚Ñù A).nonempty :=
begin
  haveI : nonempty A := set.nonempty_coe_sort.mpr Ane,
  rw [intrinsic_interior_def, set.nonempty_image_iff],
  obtain ‚ü®p, hp‚ü© := Ane,
  let p' : affine_span ‚Ñù A := ‚ü®p, subset_affine_span _ _ hp‚ü©,
  rw [(affine_isometry_equiv.const_vsub ‚Ñù p').symm.to_homeomorph.interior_nonempty_iff_preimage,
    convex.interior_nonempty_iff_affine_span_eq_top],
  { rw [affine_isometry_equiv.coe_to_homeomorph,
      ‚Üêaffine_isometry_equiv.comap_span (affine_isometry_equiv.const_vsub ‚Ñù p').symm,
      affine_span_affine_span_coe_preimage ‚Ñù A],
    exact affine_subspace.comap_top },
  { exact convex.affine_preimage ((affine_span ‚Ñù A).inclusion_affine.comp
    (affine_isometry_equiv.const_vsub ‚Ñù p').symm.to_affine_equiv.to_affine_map) Acv },
end
