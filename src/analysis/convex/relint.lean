import analysis.convex.basic
import analysis.normed_space.add_torsor_bases
import analysis.normed_space.basic
import analysis.normed_space.linear_isometry
import data.real.basic
import data.set.pointwise
import linear_algebra.affine_space.pointwise

open_locale pointwise


-- MOVETO topology.constructions, after subtype.topological_space?

def subtype.inclusion {Œ± : Type} [topological_space Œ±] {p q : Œ± ‚Üí Prop} (h : ‚àÄ a, p a ‚Üí q a) :
subtype p ‚Üí subtype q := subtype.map id h

lemma subtype.continuous_inclusion {Œ± : Type} [topological_space Œ±] {p q : Œ± ‚Üí Prop} (h : ‚àÄ a, p a ‚Üí q a) :
continuous (subtype.inclusion h) :=
begin
  simp only [continuous_def, is_open_induced_iff, subtype.inclusion, subtype.map, id.def],
  rintro - ‚ü®U, hU, rfl‚ü©,
  refine ‚ü®U, hU, _‚ü©,
  ext,
  simp only [set.mem_preimage, subtype.coe_mk],
end

def subtype.equiv_inclusion {Œ± : Type} [topological_space Œ±] {p q : Œ± ‚Üí Prop} (h : ‚àÄ {a}, p a ‚Üî q a) :
subtype p ‚âÉ subtype q :=
begin
  refine ‚ü®subtype.inclusion (Œª _, h.mp), subtype.inclusion (Œª _, h.mpr), _, _‚ü©;
    simp only [subtype.inclusion, subtype.map, id.def,
      function.left_inverse_iff_comp, function.right_inverse_iff_comp,
      function.funext_iff, subtype.coe_mk,
      subtype.ext_iff, eq_self_iff_true, implies_true_iff],
end

def subtype.homeomorph_inclusion {Œ± : Type} [topological_space Œ±] {p q : Œ± ‚Üí Prop} (h : ‚àÄ a, p a ‚Üî q a) :
subtype p ‚âÉ‚Çú subtype q :=
begin
  refine ‚ü®subtype.equiv_inclusion h, _, _‚ü© ;
    simp only [auto_param_eq, subtype.equiv_inclusion] ;
    apply subtype.continuous_inclusion,
end

-- MOVETO data.set.pointwise

lemma set.vadd_vsub_vadd_cancel_left {V : Type} [add_comm_group V]
  (x : V) (A B : set V) :
(x +·µ• A) -·µ• (x +·µ• B) = A -·µ• B :=
begin
  ext, split,
  { rintro ‚ü®-, -, ‚ü®a, ha, rfl‚ü©, ‚ü®b, hb, rfl‚ü©, rfl‚ü©,
    rw [vadd_vsub_vadd_cancel_left x],
    exact ‚ü®a, b, ha, hb, rfl‚ü©, },
  { rintro ‚ü®a, b, ha, hb, rfl‚ü©,
    rw [‚Üêvadd_vsub_vadd_cancel_left x],
    exact ‚ü®_, _, ‚ü®a, ha, rfl‚ü©, ‚ü®b, hb, rfl‚ü©, rfl‚ü© },
end

-- MOVETO linear_algebra.affine_space.affine_subspace

lemma affine_subspace.neg_vadd_mem_iff {V R : Type} [ring R]
  [add_comm_group V] [module R V]
  (E : affine_subspace R V) (x y : V) :
(-x) +·µ• y ‚àà E ‚Üî y ‚àà x +·µ• E :=
begin
  split,
  {
    intro h,
    refine ‚ü®-x +·µ• y, h, _‚ü©,
    simp only [vadd_eq_add, affine_equiv.coe_coe, affine_equiv.const_vadd_apply,
      add_neg_cancel_left],
  },
  {
    rintro ‚ü®z, hz, rfl‚ü©,
    simpa only [affine_equiv.coe_coe, affine_equiv.const_vadd_apply, vadd_eq_add,
      neg_add_cancel_left] using hz,
  },
end

lemma affine_span_eq_vector_span {V : Type} (R : Type) [ring R] [add_comm_group V] [module R V]
  {A : set V} {x : V} (hxA : x ‚àà A) :
(affine_span R (-x +·µ• A) : set V) = vector_span R A :=
begin
  suffices hs : (affine_span R (-x +·µ• A)).direction = vector_span R A,
  {
    rw [‚Üêaffine_subspace.pointwise_vadd_span, ‚Üêdirection_affine_span],
    ext y, split,
    { rintro ‚ü®y, hy, rfl‚ü©,
      simp only [affine_equiv.coe_coe, affine_equiv.const_vadd_apply, vadd_eq_add],
      rw [‚Üêsub_eq_neg_add, affine_subspace.coe_direction_eq_vsub_set_right],
      { refine ‚ü®y, hy, rfl‚ü© },
      { apply subset_affine_span ; assumption } },
    { rintro h,
    refine ‚ü®y + x, _, _‚ü©,
    { rw [affine_subspace.mem_coe],
      refine affine_subspace.vadd_mem_of_mem_direction h _,
      { apply subset_affine_span ; assumption } },
    simp only [affine_equiv.coe_coe, affine_equiv.const_vadd_apply, vadd_eq_add,
      neg_add_cancel_comm_assoc], }
  },
  simp only [direction_affine_span, vector_span_def, set.vadd_vsub_vadd_cancel_left],
end

lemma affine_span_eq_vector_span' {V : Type} (R : Type) [ring R] [add_comm_group V] [module R V]
  {A : set V} (hzm : (0 : V) ‚àà A) :
(affine_span R A : set V) = vector_span R A :=
begin
  convert affine_span_eq_vector_span R hzm,
  simp only [neg_zero, zero_vadd],
end

def affine_subspace.inclusion {R V P : Type} [ring R] [add_comm_group V] [module R V]
  [add_torsor V P] (E : affine_subspace R P) : E ‚Üí P := coe

lemma affine_subspace.inclusion_def {R V P : Type} [ring R] [add_comm_group V] [module R V]
  [add_torsor V P] (E : affine_subspace R P) :
E.inclusion = coe := rfl

def affine_subspace.inclusion_aff {R V P : Type} [ring R] [add_comm_group V] [module R V]
  [add_torsor V P] (E : affine_subspace R P) [nonempty E] : E ‚Üí·µÉ[R] P :=
begin
  refine ‚ü®E.inclusion, E.direction.subtype, by tauto‚ü©,
end

instance blubb {ùïú V P : Type} [normed_field ùïú] [seminormed_add_comm_group V]
  [normed_space ùïú V] [pseudo_metric_space P] [normed_add_torsor V P]
  {E : affine_subspace ùïú P} [nonempty E] : normed_add_torsor E.direction E :=
{ to_add_torsor := E.to_add_torsor,
  dist_eq_norm' :=
  begin
    intros x y,
    simp only [subtype.dist_eq, submodule.coe_norm, affine_subspace.coe_vsub],
    apply dist_eq_norm_vsub,
  end }

def affine_subspace.inclusion_ai {ùïú V P : Type} [normed_field ùïú] [seminormed_add_comm_group V]
  [normed_space ùïú V] [pseudo_metric_space P] [normed_add_torsor V P]
  (E : affine_subspace ùïú P) [nonempty E] : E ‚Üí·µÉ‚Å±[ùïú] P :=
begin
  refine ‚ü®E.inclusion_aff, by tauto‚ü©,
end

instance affine_subspace.nonempty_map {R V‚ÇÅ P‚ÇÅ V‚ÇÇ P‚ÇÇ : Type}
  [ring R] [add_comm_group V‚ÇÅ] [add_comm_group V‚ÇÇ] [module R V‚ÇÅ] [module R V‚ÇÇ]
  [add_torsor V‚ÇÅ P‚ÇÅ] [add_torsor V‚ÇÇ P‚ÇÇ] {E : affine_subspace R P‚ÇÅ} [Ene : nonempty E]
  {œÜ : P‚ÇÅ ‚Üí·µÉ[R] P‚ÇÇ} : nonempty (E.map œÜ) :=
begin
  obtain ‚ü®x, hx‚ü© := id Ene,
  refine ‚ü®‚ü®œÜ x, affine_subspace.mem_map.mpr ‚ü®x, hx, rfl‚ü©‚ü©‚ü©,
end

instance nonempty_affine_span {R V P : Type}
  [ring R] [add_comm_group V] [module R V] [add_torsor V P] {A : set V} [nonempty A] :
nonempty (affine_span R A) :=
begin
  simp only [coe_sort_coe_base, coe_affine_span, set.nonempty_coe_sort, span_points_nonempty],
  exact set.nonempty_of_nonempty_subtype,
end

-- MOVETO algebra.module.linear_map

def linear_map.restrict' {R V‚ÇÅ V‚ÇÇ : Type}
  [ring R] [add_comm_group V‚ÇÅ] [add_comm_group V‚ÇÇ] [module R V‚ÇÅ] [module R V‚ÇÇ]
  (œÜ : V‚ÇÅ ‚Üí‚Çó[R] V‚ÇÇ) {E : submodule R V‚ÇÅ} {F : submodule R V‚ÇÇ}
  (hEF : E.map œÜ ‚â§ F) : E ‚Üí‚Çó[R] F :=
begin
  refine ‚ü®_, _, _‚ü©,
  { exact Œª x, ‚ü®œÜ x, hEF $ submodule.mem_map.mpr ‚ü®x, x.property, rfl‚ü©‚ü© },
  all_goals { intros x y,
    simp only [subtype.ext_iff, subtype.coe_mk, submodule.coe_add, submodule.coe_smul],
    apply_rules [œÜ.map_add, œÜ.map_smul] },
end

def linear_map.restrict'.coe_apply {R V‚ÇÅ V‚ÇÇ : Type}
  [ring R] [add_comm_group V‚ÇÅ] [add_comm_group V‚ÇÇ] [module R V‚ÇÅ] [module R V‚ÇÇ]
  (œÜ : V‚ÇÅ ‚Üí‚Çó[R] V‚ÇÇ) {E : submodule R V‚ÇÅ} {F : submodule R V‚ÇÇ}
  (hEF : E.map œÜ ‚â§ F) (x : E) :
‚Üë(œÜ.restrict' hEF x) = œÜ x := rfl

-- MOVETO linear_algebra.affine_space.affine_map

def affine_map.restrict {R V‚ÇÅ V‚ÇÇ P‚ÇÅ P‚ÇÇ : Type}
  [ring R] [add_comm_group V‚ÇÅ] [add_comm_group V‚ÇÇ] [module R V‚ÇÅ]
  [module R V‚ÇÇ]
  [add_torsor V‚ÇÅ P‚ÇÅ] [add_torsor V‚ÇÇ P‚ÇÇ]
  (œÜ : P‚ÇÅ ‚Üí·µÉ[R] P‚ÇÇ) {E : affine_subspace R P‚ÇÅ} {F : affine_subspace R P‚ÇÇ}
  [nonempty E] [nonempty F]
  (hEF : E.map œÜ ‚â§ F) : E ‚Üí·µÉ[R] F :=
begin
  refine ‚ü®_, _, _‚ü©,
  { exact Œª x, ‚ü®œÜ x, hEF $ affine_subspace.mem_map.mpr ‚ü®x, x.property, rfl‚ü©‚ü© },
  { refine œÜ.linear.restrict' _,
    rw [‚Üêaffine_subspace.map_direction],
    exact affine_subspace.direction_le hEF },
  { intros p v,
    simp only [subtype.ext_iff, subtype.coe_mk, affine_subspace.coe_vadd],
    apply affine_map.map_vadd },
end

lemma affine_map.restrict.coe_apply {R V‚ÇÅ V‚ÇÇ P‚ÇÅ P‚ÇÇ : Type}
  [ring R] [add_comm_group V‚ÇÅ] [add_comm_group V‚ÇÇ] [module R V‚ÇÅ]
  [module R V‚ÇÇ]
  [add_torsor V‚ÇÅ P‚ÇÅ] [add_torsor V‚ÇÇ P‚ÇÇ]
  (œÜ : P‚ÇÅ ‚Üí·µÉ[R] P‚ÇÇ) {E : affine_subspace R P‚ÇÅ} {F : affine_subspace R P‚ÇÇ}
  [nonempty E] [nonempty F]
  (hEF : E.map œÜ ‚â§ F) (x : E) :
‚Üë(œÜ.restrict hEF x) = œÜ x := rfl

lemma affine_map.restrict.linear {R V‚ÇÅ V‚ÇÇ P‚ÇÅ P‚ÇÇ : Type}
  [ring R] [add_comm_group V‚ÇÅ] [add_comm_group V‚ÇÇ] [module R V‚ÇÅ]
  [module R V‚ÇÇ]
  [add_torsor V‚ÇÅ P‚ÇÅ] [add_torsor V‚ÇÇ P‚ÇÇ]
  (œÜ : P‚ÇÅ ‚Üí·µÉ[R] P‚ÇÇ) {E : affine_subspace R P‚ÇÅ} {F : affine_subspace R P‚ÇÇ}
  [nonempty E] [nonempty F]
  (hEF : E.map œÜ ‚â§ F) :
(œÜ.restrict hEF).linear = œÜ.linear.restrict'
  (by { rw [‚Üêaffine_subspace.map_direction], exact affine_subspace.direction_le hEF }) := rfl

lemma affine_map.restrict.injective {R V‚ÇÅ V‚ÇÇ P‚ÇÅ P‚ÇÇ : Type}
  [ring R] [add_comm_group V‚ÇÅ] [add_comm_group V‚ÇÇ] [module R V‚ÇÅ]
  [module R V‚ÇÇ]
  [add_torsor V‚ÇÅ P‚ÇÅ] [add_torsor V‚ÇÇ P‚ÇÇ]
  {œÜ : P‚ÇÅ ‚Üí·µÉ[R] P‚ÇÇ}
  (hœÜ : function.injective œÜ) {E : affine_subspace R P‚ÇÅ} {F : affine_subspace R P‚ÇÇ}
  [nonempty E] [nonempty F]
  (hEF : E.map œÜ ‚â§ F) :
function.injective (affine_map.restrict œÜ hEF) :=
begin
  intros x y h,
  simp only [subtype.ext_iff, subtype.coe_mk, affine_map.restrict.coe_apply] at h ‚ä¢,
  exact hœÜ h,
end

lemma affine_map.restrict.surjective {R V‚ÇÅ V‚ÇÇ P‚ÇÅ P‚ÇÇ : Type}
  [ring R] [add_comm_group V‚ÇÅ] [add_comm_group V‚ÇÇ] [module R V‚ÇÅ]
  [module R V‚ÇÇ] [add_torsor V‚ÇÅ P‚ÇÅ] [add_torsor V‚ÇÇ P‚ÇÇ]
  (œÜ : P‚ÇÅ ‚Üí·µÉ[R] P‚ÇÇ) {E : affine_subspace R P‚ÇÅ} [nonempty E] :
function.surjective (affine_map.restrict œÜ (le_refl (E.map œÜ))) :=
begin
  rintro ‚ü®x, hx : x ‚àà E.map œÜ‚ü©,
  rw [affine_subspace.mem_map] at hx,
  obtain ‚ü®y, hy, rfl‚ü© := hx,
  exact ‚ü®‚ü®y, hy‚ü©, rfl‚ü©,
end

lemma affine_map.bijective_iff_linear_bijective {R V‚ÇÅ V‚ÇÇ P‚ÇÅ P‚ÇÇ : Type}
  [ring R] [add_comm_group V‚ÇÅ] [add_comm_group V‚ÇÇ] [module R V‚ÇÅ]
  [module R V‚ÇÇ] [add_torsor V‚ÇÅ P‚ÇÅ] [add_torsor V‚ÇÇ P‚ÇÇ]
  (œÜ : P‚ÇÅ ‚Üí·µÉ[R] P‚ÇÇ) :
function.bijective œÜ ‚Üî function.bijective œÜ.linear :=
begin
  simp only [function.bijective,
    œÜ.injective_iff_linear_injective, œÜ.surjective_iff_linear_surjective],
end

-- MOVETO linear_algebra.affine_space.affine_equiv
noncomputable def affine_equiv.of_bijective {R V‚ÇÅ V‚ÇÇ P‚ÇÅ P‚ÇÇ : Type}
  [ring R] [add_comm_group V‚ÇÅ] [add_comm_group V‚ÇÇ] [module R V‚ÇÅ]
  [module R V‚ÇÇ]
  [add_torsor V‚ÇÅ P‚ÇÅ] [add_torsor V‚ÇÇ P‚ÇÇ]
  {œÜ : P‚ÇÅ ‚Üí·µÉ[R] P‚ÇÇ}
  (hœÜ : function.bijective œÜ) : P‚ÇÅ ‚âÉ·µÉ[R] P‚ÇÇ :=
begin
  refine ‚ü®equiv.of_bijective _ hœÜ, _, _‚ü©,
  { refine linear_equiv.of_bijective œÜ.linear _ _ ;
      obtain ‚ü®_, _‚ü© := hœÜ ;
      simp only [œÜ.injective_iff_linear_injective, œÜ.surjective_iff_linear_surjective] ;
      assumption },
  simp only [equiv.of_bijective_apply, linear_equiv.of_bijective_apply, affine_map.map_vadd,
    eq_self_iff_true, forall_const],
end

lemma affine_equiv.of_bijective_apply {R V‚ÇÅ V‚ÇÇ P‚ÇÅ P‚ÇÇ : Type}
  [ring R] [add_comm_group V‚ÇÅ] [add_comm_group V‚ÇÇ] [module R V‚ÇÅ]
  [module R V‚ÇÇ]
  [add_torsor V‚ÇÅ P‚ÇÅ] [add_torsor V‚ÇÇ P‚ÇÇ]
  {œÜ : P‚ÇÅ ‚Üí·µÉ[R] P‚ÇÇ}
  (hœÜ : function.bijective œÜ) (x : P‚ÇÅ) :
affine_equiv.of_bijective hœÜ x = œÜ x := rfl

/- lemma affine_equiv.of_bijective.apply_symm_apply {R V‚ÇÅ V‚ÇÇ P‚ÇÅ P‚ÇÇ : Type}
  [ring R] [add_comm_group V‚ÇÅ] [add_comm_group V‚ÇÇ] [module R V‚ÇÅ]
  [module R V‚ÇÇ]
  [add_torsor V‚ÇÅ P‚ÇÅ] [add_torsor V‚ÇÇ P‚ÇÇ]
  {œÜ : P‚ÇÅ ‚Üí·µÉ[R] P‚ÇÇ}
  (hœÜ : function.bijective œÜ) (x : P‚ÇÇ) :
œÜ ((affine_equiv.of_bijective hœÜ).symm x) = x :=
begin
end -/

lemma affine_equiv.of_bijective.symm_eq {R V‚ÇÅ V‚ÇÇ P‚ÇÅ P‚ÇÇ : Type}
  [ring R] [add_comm_group V‚ÇÅ] [add_comm_group V‚ÇÇ] [module R V‚ÇÅ]
  [module R V‚ÇÇ]
  [add_torsor V‚ÇÅ P‚ÇÅ] [add_torsor V‚ÇÇ P‚ÇÇ]
  {œÜ : P‚ÇÅ ‚Üí·µÉ[R] P‚ÇÇ}
  (hœÜ : function.bijective œÜ) :
(affine_equiv.of_bijective hœÜ).symm.to_equiv = (equiv.of_bijective _ hœÜ).symm := rfl

lemma affine_equiv.of_bijective_linear {R V‚ÇÅ V‚ÇÇ P‚ÇÅ P‚ÇÇ : Type}
  [ring R] [add_comm_group V‚ÇÅ] [add_comm_group V‚ÇÇ] [module R V‚ÇÅ]
  [module R V‚ÇÇ]
  [add_torsor V‚ÇÅ P‚ÇÅ] [add_torsor V‚ÇÇ P‚ÇÇ]
  {œÜ : P‚ÇÅ ‚Üí·µÉ[R] P‚ÇÇ}
  (hœÜ : function.bijective œÜ) :
(affine_equiv.of_bijective hœÜ).linear = linear_equiv.of_bijective œÜ.linear
  (œÜ.injective_iff_linear_injective.mpr hœÜ.1)
  (œÜ.surjective_iff_linear_surjective.mpr hœÜ.2) := rfl

-- MOVETO analysis.normed_space.affine_isometry

lemma affine_isometry.injective' {ùïú V‚ÇÅ V‚ÇÇ P‚ÇÅ P‚ÇÇ : Type}
  [normed_field ùïú] [/- this -/normed_add_comm_group V‚ÇÅ] [seminormed_add_comm_group V‚ÇÇ]
  [normed_space ùïú V‚ÇÅ] [normed_space ùïú V‚ÇÇ] [pseudo_metric_space P‚ÇÅ] [pseudo_metric_space P‚ÇÇ]
  [h : normed_add_torsor V‚ÇÅ P‚ÇÅ] [normed_add_torsor V‚ÇÇ P‚ÇÇ] (f : P‚ÇÅ ‚Üí·µÉ‚Å±[ùïú] P‚ÇÇ) :
function.injective f :=
begin
  let : metric_space P‚ÇÅ :=
    { to_pseudo_metric_space := infer_instance,
      eq_of_dist_eq_zero := Œª x y, by simp only [dist_eq_norm_vsub V‚ÇÅ x y, norm_eq_zero,
        vsub_eq_zero_iff_eq, imp_self] },
  convert @affine_isometry.injective ùïú V‚ÇÅ V‚ÇÇ P‚ÇÅ P‚ÇÇ _ _ _ _ _ this _ (by convert h) _ f,
end


noncomputable def affine_isometry.cod_restrict_to_equiv {ùïú V‚ÇÅ V‚ÇÇ P‚ÇÅ P‚ÇÇ : Type}
  [normed_field ùïú] [normed_add_comm_group V‚ÇÅ] [seminormed_add_comm_group V‚ÇÇ] [normed_space ùïú V‚ÇÅ]
  [normed_space ùïú V‚ÇÇ] [pseudo_metric_space P‚ÇÅ] [pseudo_metric_space P‚ÇÇ]
  [normed_add_torsor V‚ÇÅ P‚ÇÅ] [normed_add_torsor V‚ÇÇ P‚ÇÇ]
  (E : affine_subspace ùïú P‚ÇÅ) [nonempty E]
  (œÜ : P‚ÇÅ ‚Üí·µÉ‚Å±[ùïú] P‚ÇÇ) : E ‚âÉ·µÉ‚Å±[ùïú] E.map œÜ.to_affine_map :=
begin
  let f := œÜ.to_affine_map.restrict (le_refl (E.map œÜ.to_affine_map)),
  have fi : function.injective f := affine_map.restrict.injective œÜ.injective' _,
  have fs : function.surjective f := affine_map.restrict.surjective _,
  have fb : function.bijective f := ‚ü®fi, fs‚ü©,
  refine ‚ü®affine_equiv.of_bijective fb, _‚ü©,
  { simp only [affine_equiv.of_bijective_linear, linear_equiv.of_bijective_apply],
    simp only [f, affine_map.restrict.linear],
    simp only [‚Üêsubmodule.norm_coe, linear_map.restrict'.coe_apply],
    simp only [affine_isometry.linear_eq_linear_isometry, linear_isometry.coe_to_linear_map,
      linear_isometry.norm_map, eq_self_iff_true, forall_const] },
end

lemma affine_isometry.cod_restrict_to_equiv.apply_symm_apply {ùïú V‚ÇÅ V‚ÇÇ P‚ÇÅ P‚ÇÇ : Type}
  [normed_field ùïú] [normed_add_comm_group V‚ÇÅ] [seminormed_add_comm_group V‚ÇÇ] [normed_space ùïú V‚ÇÅ]
  [normed_space ùïú V‚ÇÇ] [pseudo_metric_space P‚ÇÅ] [pseudo_metric_space P‚ÇÇ]
  [normed_add_torsor V‚ÇÅ P‚ÇÅ] [normed_add_torsor V‚ÇÇ P‚ÇÇ]
  {E : affine_subspace ùïú P‚ÇÅ} [nonempty E]
  {œÜ : P‚ÇÅ ‚Üí·µÉ‚Å±[ùïú] P‚ÇÇ} (x : E.map œÜ.to_affine_map) :
œÜ ((œÜ.cod_restrict_to_equiv E).symm x) = x :=
begin
  simp only [affine_isometry.cod_restrict_to_equiv,
    ‚Üêaffine_isometry_equiv.coe_to_affine_equiv, ‚Üêaffine_isometry_equiv.to_affine_equiv_symm],
  simp only [‚Üêaffine_equiv.coe_to_equiv, affine_equiv.of_bijective.symm_eq],
  have := equiv.of_bijective_apply_symm_apply (œÜ.to_affine_map.restrict _) _ x,
  replace this := congr_arg (coe : E.map œÜ.to_affine_map ‚Üí P‚ÇÇ) this,
  simp only [affine_map.restrict.coe_apply] at this,
  exact this,
end

-- BEGIN intrinsic_interior.lean

section experiment

variables (R : Type) {V P : Type} [ring R] [seminormed_add_comm_group V] [module R V]
  [pseudo_metric_space P] [normed_add_torsor V P]

def intrinsic_interior' (R : Type) {V P : Type} [ring R] [seminormed_add_comm_group V] [module R V]
  [pseudo_metric_space P] [normed_add_torsor V P] -- have to redeclare variables to ensure that
                                                  -- all typeclasses are used
  (A : set P) :=
(affine_span R A).inclusion '' interior ((affine_span R A).inclusion ‚Åª¬π' A)

lemma intrinsic_interior'_def (R : Type) {V P : Type} [ring R] [seminormed_add_comm_group V] [module R V]
  [pseudo_metric_space P] [normed_add_torsor V P]
  (A : set P) :
intrinsic_interior' R A =
(affine_span R A).inclusion '' interior ((affine_span R A).inclusion ‚Åª¬π' A) := rfl

@[simp]
lemma intrinsic_interior'_empty (R : Type) {V P : Type} [ring R] [seminormed_add_comm_group V] [module R V]
  [pseudo_metric_space P] [normed_add_torsor V P] :
intrinsic_interior' R (‚àÖ : set P) = ‚àÖ :=
begin
  simp only [intrinsic_interior', set.preimage_empty, interior_empty, set.image_empty],
end

lemma isometry_range_intrinsic_interior {ùïú V V‚ÇÇ P P‚ÇÇ: Type}
  [normed_field ùïú] [normed_add_comm_group V] [seminormed_add_comm_group V‚ÇÇ] [normed_space ùïú V]
  [normed_space ùïú V‚ÇÇ] [pseudo_metric_space P] [pseudo_metric_space P‚ÇÇ] [normed_add_torsor V P]
  [normed_add_torsor V‚ÇÇ P‚ÇÇ]
  (œÜ : P ‚Üí·µÉ‚Å±[ùïú] P‚ÇÇ) (A : set P) :
œÜ '' intrinsic_interior' ùïú A = intrinsic_interior' ùïú (œÜ '' A) :=
begin
  rcases A.eq_empty_or_nonempty with rfl | hc,
  { simp only [intrinsic_interior'_empty, set.image_empty] },
  haveI : nonempty A := hc.to_subtype,
  let f := œÜ.cod_restrict_to_equiv (affine_span ùïú A),
  let f' := f.to_homeomorph,
  have : œÜ.to_affine_map ‚àò (affine_span ùïú A).inclusion ‚àò f'.symm =
    ((affine_span ùïú A).map œÜ.to_affine_map).inclusion,
  { funext x,
    exact affine_isometry.cod_restrict_to_equiv.apply_symm_apply _ },
  simp only [intrinsic_interior'_def, ‚ÜêœÜ.coe_to_affine_map],
  rw [intrinsic_interior'_def],
  rw [‚Üêaffine_subspace.map_span œÜ.to_affine_map A, ‚Üêthis,
    ‚Üêfunction.comp.assoc, set.image_comp _ f'.symm,
    set.image_comp _ (affine_span ùïú A).inclusion, f'.symm.image_interior, f'.image_symm,
    ‚Üêset.preimage_comp, function.comp.assoc, f'.symm_comp_self, affine_isometry.coe_to_affine_map,
    function.comp.right_id, @set.preimage_comp _ P, œÜ.injective'.preimage_image],
end

end experiment

variables (ùïú : Type) [ring ùïú]

section definitions

variables (R : Type) [ring R] {V : Type} [add_comm_group V] [module R V] [topological_space V]

/-- The intrinsic interior of a set is its interior considered as a set in its affine span. -/
def intrinsic_interior
  (A : set V) :=
(coe : affine_span R A ‚Üí V) '' interior ((coe : affine_span R A ‚Üí V) ‚Åª¬π' A)

lemma intrinsic_interior_def (A : set V) :
intrinsic_interior R A =
(coe : affine_span R A ‚Üí V) '' interior ((coe : affine_span R A ‚Üí V) ‚Åª¬π' A) := rfl

/-- The intrinsic frontier of a set is its frontier considered as a set in its affine span. -/
def intrinsic_frontier (A : set V) : set V := coe '' frontier ((coe : affine_span R A ‚Üí V) ‚Åª¬π' A)

lemma intrinsic_interior_eq_' (R : Type) {V : Type} [ring R] [seminormed_add_comm_group V] [module R V]
  (A : set V) :
intrinsic_interior R A = intrinsic_interior' R A := rfl

lemma intrinsic_frontier_def (A : set V) :
intrinsic_frontier R A =
(coe : affine_span R A ‚Üí V) '' frontier ((coe : affine_span R A ‚Üí V) ‚Åª¬π' A) := rfl

/-- The intrinsic closure of a set is its closure considered as a set in its affine span. -/
def intrinsic_closure (A : set V) : set V := coe '' closure ((coe : affine_span R A ‚Üí V) ‚Åª¬π' A)

lemma intrinsic_closure_def (A : set V) :
intrinsic_closure R A =
(coe : affine_span R A ‚Üí V) '' closure ((coe : affine_span R A ‚Üí V) ‚Åª¬π' A) := rfl

end definitions

section basic

variables (R : Type) [ring R] {V : Type} [add_comm_group V] [module R V] [topological_space V]

@[simp] lemma intrinsic_closure_eq_closure (ùïú : Type)
  [nontrivially_normed_field ùïú] [complete_space ùïú]
  {V : Type} [normed_add_comm_group V] [normed_space ùïú V] [finite_dimensional ùïú V]
  (A : set V) : intrinsic_closure ùïú A = closure A :=
begin
  simp only [intrinsic_closure_def],
  ext x,
  simp only [mem_closure_iff, set.mem_image],
  split,
  { rintro ‚ü®x, h, rfl‚ü© o ho hxo,
    obtain ‚ü®z, hz‚ÇÅ, hz‚ÇÇ‚ü© := h ((coe : affine_span ùïú A ‚Üí V) ‚Åª¬π' o)
                   (continuous_induced_dom.is_open_preimage o ho) hxo,
    exact ‚ü®z, hz‚ÇÅ, hz‚ÇÇ‚ü© },
  {
    intro h,
    refine ‚ü®‚ü®x, _‚ü©, _‚ü©,
    { by_contradiction hc,
    obtain ‚ü®z, hz‚ÇÅ, hz‚ÇÇ‚ü© := h
      (affine_span ùïú A)·∂ú
      (affine_subspace.closed_of_finite_dimensional (affine_span ùïú A)).is_open_compl
      hc,
    exact hz‚ÇÅ (subset_affine_span ùïú A hz‚ÇÇ), },
    refine ‚ü®_, subtype.coe_mk _ _‚ü©,
    intros o ho hxo,
    have ho' := ho,
    rw [is_open_induced_iff] at ho,
    obtain ‚ü®o, ho, rfl‚ü© := ho,
    rw [set.mem_preimage, subtype.coe_mk] at hxo,
    obtain ‚ü®w, hwo, hwA‚ü© := h _ ho hxo,
    have : w ‚àà affine_span ùïú A := subset_affine_span ùïú A hwA,
    refine ‚ü®‚ü®w, subset_affine_span ùïú A hwA‚ü©, hwo, hwA‚ü©,
  },
end

@[simp] lemma intrinsic_closure_diff_intrinsic_interior (A : set V) :
intrinsic_closure R A \ intrinsic_interior R A = intrinsic_frontier R A :=
begin
  rw [intrinsic_frontier_def, intrinsic_closure_def, intrinsic_interior_def,
    ‚Üêset.image_diff subtype.coe_injective],
  refl,
end

@[simp] lemma closure_diff_intrinsic_interior  (ùïú : Type)
  [nontrivially_normed_field ùïú] [complete_space ùïú]
  {V : Type} [normed_add_comm_group V] [normed_space ùïú V] [finite_dimensional ùïú V]
  (A : set V) :
closure A \ intrinsic_interior ùïú A = intrinsic_frontier ùïú A :=
begin
  simp only [‚Üêintrinsic_closure_eq_closure ùïú],
  exact intrinsic_closure_diff_intrinsic_interior ùïú A,
end

lemma intrinsic_interior_subset (A : set V) : intrinsic_interior R A ‚äÜ A :=
set.image_subset_iff.mpr interior_subset

lemma intrinsic_frontier_subset {A : set V} (hA : is_closed A) : intrinsic_frontier R A ‚äÜ A :=
set.image_subset_iff.mpr (hA.preimage continuous_induced_dom).frontier_subset

@[simp] lemma intrinsic_interior_empty : intrinsic_interior R (‚àÖ : set V) = ‚àÖ :=
set.subset_empty_iff.mp $ intrinsic_interior_subset R _

@[simp] lemma intrinsic_frontier_empty : intrinsic_frontier R (‚àÖ : set V) = ‚àÖ :=
set.subset_empty_iff.mp $ intrinsic_frontier_subset R is_closed_empty

@[simp] lemma intrinsic_interior_singleton (x : V) : intrinsic_interior R ({x} : set V) = {x} :=
sorry

end basic

lemma intrinsic_interior_vadd_subset {V : Type}
  [add_comm_group V] [module ùïú V] [topological_space V] [has_continuous_const_vadd V V]
  (A : set V) (x : V) :
intrinsic_interior ùïú (x +·µ• A) ‚äÜ x +·µ• intrinsic_interior ùïú A :=
begin
  simp only [intrinsic_interior_def],
  rintro - ‚ü®y, hy, rfl‚ü©,
  refine ‚ü®y - x, _, _‚ü©, swap,
  { apply add_sub_cancel'_right },
  refine ‚ü®‚ü®y - x, _‚ü©, _, rfl‚ü©,
  { change ‚Üëy - x ‚àà affine_span ùïú A,
    rw [‚Üêaffine_subspace.vadd_mem_pointwise_vadd_iff, affine_subspace.pointwise_vadd_span],
    swap, exact x,
    simp only [vadd_eq_add, add_sub_cancel'_right],
    exact y.property },
  obtain ‚ü®y, yprop‚ü© := y,
  rw [‚Üêaffine_subspace.pointwise_vadd_span] at yprop,
  simp only [mem_interior_iff_mem_nhds, mem_nhds_induced] at hy ‚ä¢,
  simp only [mem_nhds_iff, subtype.coe_mk, exists_prop] at hy ‚ä¢,
  obtain ‚ü®t, ‚ü®u, ut, uopen, yu‚ü©, ht‚ü© := hy,
  refine ‚ü®(-x) +·µ• u, ‚ü®(-x) +·µ• u, subset_refl _, _, _‚ü©, _‚ü©,
  { apply uopen.vadd, apply_instance, },
  { refine ‚ü®y, yu, _‚ü©,
    rw [vadd_eq_add, ‚Üêsub_eq_neg_add], },

  rintro ‚ü®z, hz‚ÇÅ‚ü© hz‚ÇÇ,
  simp only [set.mem_preimage, subtype.coe_mk] at hz‚ÇÇ ‚ä¢,
  obtain ‚ü®z, hz‚ÇÇ, rfl‚ü© := hz‚ÇÇ,
  change (-x) +·µ• z ‚àà affine_span ùïú A at hz‚ÇÅ,
  rw [affine_subspace.neg_vadd_mem_iff, affine_subspace.pointwise_vadd_span] at hz‚ÇÅ,
  let w : affine_span ùïú (x +·µ• A) := ‚ü®z, hz‚ÇÅ‚ü©,
  have hw: w ‚àà (coe : affine_span ùïú (x +·µ• A) ‚Üí V) ‚Åª¬π' t := ut hz‚ÇÇ,
  rw [‚Üêset.mem_vadd_set_iff_neg_vadd_mem],
  exact ht hw,
end

lemma intrinsic_interior_vadd {V : Type}
  [add_comm_group V] [module ùïú V] [topological_space V] [has_continuous_const_vadd V V]
  (A : set V) (x : V) :
intrinsic_interior ùïú (x +·µ• A) = x +·µ• intrinsic_interior ùïú A :=
begin
  refine subset_antisymm (by apply intrinsic_interior_vadd_subset) _,
  suffices hs : intrinsic_interior ùïú ((-x) +·µ• (x +·µ• A)) ‚äÜ (-x) +·µ• intrinsic_interior ùïú (x +·µ• A),
  { simp only [neg_vadd_vadd] at hs,
    rintro - ‚ü®y, hy, rfl‚ü©,
    obtain ‚ü®z, hz, rfl‚ü© := hs hy,
    simpa only [vadd_eq_add, add_neg_cancel_left] using hz },
  apply intrinsic_interior_vadd_subset,
end

lemma intrinsic_interior_vector_span {V : Type} [add_comm_group V] [module ùïú V] [topological_space V]
  {A : set V} (hzm : (0 : V) ‚àà A) :
intrinsic_interior ùïú A = (coe : vector_span ùïú A ‚Üí V) '' interior ((coe : vector_span ùïú A ‚Üí V) ‚Åª¬π' A) :=
begin
  have : ‚àÄ v : V, v ‚àà vector_span ùïú A ‚Üî v ‚àà affine_span ùïú A,
  {
    intros v,
    simp only [‚Üêset_like.mem_coe, ‚Üêaffine_subspace.mem_coe],
    rw [affine_span_eq_vector_span' ùïú hzm],
  },
  let œÜ : vector_span ùïú A ‚âÉ‚Çú affine_span ùïú A := subtype.homeomorph_inclusion this,
  rw [intrinsic_interior_def],
  ext y,
  simp only [set.mem_image],
  split,
  all_goals { rintro ‚ü®y, hy, rfl‚ü©,
              refine ‚ü®œÜ.symm y, _, rfl‚ü© <|> refine ‚ü®œÜ y, _, rfl‚ü©,
              have := set.mem_image_of_mem _ hy,
              rw [homeomorph.image_interior] at this,
              convert this using 2,
              rw [‚Üêhomeomorph.preimage_symm, ‚Üêset.preimage_comp],
              refl },
end

lemma subset_vector_span_of_zero_mem {V : Type} [add_comm_group V] [module ùïú V]
  {A : set V} (hzm : (0 : V) ‚àà A) :
A ‚äÜ vector_span ùïú A :=
begin
  refine subset_trans _ (vsub_set_subset_vector_span _ _),
  intros a ha,
  exact ‚ü®a, 0, ha, hzm, sub_zero _‚ü©,
end

@[protected]
lemma coe_preimage_vsub {V R : Type} [ring R]
  [add_comm_group V] [module R V]
  {A : set V} {E : submodule R V} (hAE : A ‚äÜ E) :
(coe : E ‚Üí V) ‚Åª¬π' (A -·µ• A) = ((coe : E ‚Üí V) ‚Åª¬π' A) -·µ• ((coe : E ‚Üí V) ‚Åª¬π' A) :=
begin
  ext, split,
  { rintro ‚ü®x‚ÇÅ, x‚ÇÇ, hx‚ÇÅ, hx‚ÇÇ, h‚ü©,
    refine ‚ü®‚ü®x‚ÇÅ, hAE hx‚ÇÅ‚ü©, ‚ü®x‚ÇÇ, hAE hx‚ÇÇ‚ü©, hx‚ÇÅ, hx‚ÇÇ, _‚ü©,
    ext,
    exact h, },
  { rintro ‚ü®x‚ÇÅ, x‚ÇÇ, hx‚ÇÅ, hx‚ÇÇ, rfl‚ü©,
    refine ‚ü®‚Üëx‚ÇÅ, ‚Üëx‚ÇÇ, hx‚ÇÅ, hx‚ÇÇ, rfl‚ü©, },
end

@[protected]
lemma coe_vector_span_preimage_spans_top {V : Type} [add_comm_group V] [module ùïú V]
  {A : set V} (hzm : (0 : V) ‚àà A) :
vector_span ùïú ((coe : vector_span ùïú A ‚Üí V) ‚Åª¬π' A) = ‚ä§ :=
begin
  refine eq.trans _ submodule.span_span_coe_preimage,
  rw [coe_preimage_vsub],
  { refl },
  { exact subset_vector_span_of_zero_mem ùïú hzm },
end

lemma nonempty_intrinsic_interior_of_nonempty_of_convex
  {V : Type} [normed_add_comm_group V] [normed_space ‚Ñù V]
  [finite_dimensional ‚Ñù V]
  {A : set V}
(Ane : A.nonempty) (Acv : convex ‚Ñù A) :
(intrinsic_interior ‚Ñù A).nonempty :=
begin
  obtain ‚ü®x, hx‚ü© := Ane,
  have hzm : (0 : V) ‚àà -x +·µ• A :=‚ü®x, hx, add_left_neg x‚ü©,
  rw [‚Üêvadd_neg_vadd x A, intrinsic_interior_vadd],
  apply set.nonempty.vadd_set,
  rw [intrinsic_interior_vector_span ‚Ñù hzm, set.nonempty_image_iff,
    convex.interior_nonempty_iff_affine_span_eq_top,
    affine_subspace.affine_span_eq_top_iff_vector_span_eq_top_of_nonempty],
  { exact coe_vector_span_preimage_spans_top ‚Ñù hzm },
  { exact ‚ü®0, hzm‚ü© },
  { rw [‚Üêsubmodule.coe_subtype],
    exact (Acv.vadd _).linear_preimage _ },
end
