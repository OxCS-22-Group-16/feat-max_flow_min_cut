import algebra.homology.short_complex_left_homology

noncomputable theory

open category_theory category_theory.category

namespace category_theory

namespace limits

variables {C : Type*} [category C] [has_zero_morphisms C]

namespace kernel_fork

@[simp]
lemma is_limit.lift_Œπ {X Y : C} {f : X ‚ü∂ Y} {c : kernel_fork f} (hc : is_limit c)
  (c' : kernel_fork f) : hc.lift c' ‚â´ c.Œπ = c'.Œπ :=
by apply fork.is_limit.lift_Œπ

@[simps]
def is_limit.of_Œπ_op {K X Y : C} (i : K ‚ü∂ X) {f : X ‚ü∂ Y}
  (w : i ‚â´ f = 0) (h : is_limit (kernel_fork.of_Œπ i w)) :
  is_colimit (cokernel_cofork.of_œÄ i.op
    (show f.op ‚â´ i.op = 0, by simpa only [‚Üê op_comp, w])) :=
cokernel_cofork.is_colimit.of_œÄ _ _
  (Œª A x hx, (h.lift (kernel_fork.of_Œπ x.unop (quiver.hom.op_inj hx))).op)
  (Œª A x hx, quiver.hom.unop_inj (is_limit.lift_Œπ h _))
  (Œª A x hx b hb, quiver.hom.unop_inj (fork.is_limit.hom_ext h begin
    simp only [quiver.hom.unop_op, is_limit.lift_Œπ],
    exact quiver.hom.op_inj hb,
  end))

@[simps]
def is_limit.of_Œπ_unop {K X Y : C·µí·µñ} (i : K ‚ü∂ X) {f : X ‚ü∂ Y}
  (w : i ‚â´ f = 0) (h : is_limit (kernel_fork.of_Œπ i w)) :
  is_colimit (cokernel_cofork.of_œÄ i.unop
    (show f.unop ‚â´ i.unop = 0, by simpa only [‚Üê unop_comp, w])) :=
cokernel_cofork.is_colimit.of_œÄ _ _
  (Œª A x hx, (h.lift (kernel_fork.of_Œπ x.op (quiver.hom.unop_inj hx))).unop)
  (Œª A x hx, quiver.hom.op_inj (is_limit.lift_Œπ h _))
  (Œª A x hx b hb, quiver.hom.op_inj (fork.is_limit.hom_ext h begin
    simp only [quiver.hom.op_unop, is_limit.lift_Œπ],
    exact quiver.hom.unop_inj hb,
  end))

end kernel_fork

namespace cokernel_cofork

@[simp]
lemma is_colimit.œÄ_desc {X Y : C} {f : X ‚ü∂ Y} {c : cokernel_cofork f} (hc : is_colimit c)
  (c' : cokernel_cofork f) : c.œÄ ‚â´ hc.desc c' = c'.œÄ :=
by apply cofork.is_colimit.œÄ_desc

@[simps]
def is_colimit.of_œÄ_op {X Y Q : C} (p : Y ‚ü∂ Q) {f : X ‚ü∂ Y}
  (w : f ‚â´ p = 0) (h : is_colimit (cokernel_cofork.of_œÄ p w)) :
  is_limit (kernel_fork.of_Œπ p.op
    (show p.op ‚â´ f.op = 0, by simpa only [‚Üê op_comp, w])) :=
kernel_fork.is_limit.of_Œπ _ _
  (Œª A x hx, (h.desc (cokernel_cofork.of_œÄ x.unop (quiver.hom.op_inj hx))).op)
  (Œª A x hx, quiver.hom.unop_inj (is_colimit.œÄ_desc h _))
  (Œª A x hx b hb, quiver.hom.unop_inj (cofork.is_colimit.hom_ext h begin
    simp only [quiver.hom.unop_op, is_colimit.œÄ_desc],
    exact quiver.hom.op_inj hb,
  end))

@[simps]
def is_colimit.of_œÄ_unop {X Y Q : C·µí·µñ} (p : Y ‚ü∂ Q) {f : X ‚ü∂ Y}
  (w : f ‚â´ p = 0) (h : is_colimit (cokernel_cofork.of_œÄ p w)) :
  is_limit (kernel_fork.of_Œπ p.unop
    (show p.unop ‚â´ f.unop = 0, by simpa only [‚Üê unop_comp, w])) :=
kernel_fork.is_limit.of_Œπ _ _
  (Œª A x hx, (h.desc (cokernel_cofork.of_œÄ x.op (quiver.hom.unop_inj hx))).unop)
  (Œª A x hx, quiver.hom.op_inj (is_colimit.œÄ_desc h _))
  (Œª A x hx b hb, quiver.hom.op_inj (cofork.is_colimit.hom_ext h begin
    simp only [quiver.hom.op_unop, is_colimit.œÄ_desc],
    exact quiver.hom.unop_inj hb,
  end))

end cokernel_cofork

end limits

end category_theory

open category_theory.limits
variables {C : Type*} [category C] [has_zero_morphisms C]
  (S : short_complex C)

namespace short_complex

@[nolint has_nonempty_instance]
structure right_homology_data :=
(Q H : C)
(p : S.X‚ÇÇ ‚ü∂ Q)
(Œπ : H ‚ü∂ Q)
(hp‚ÇÄ : S.f ‚â´ p = 0)
(hp : is_colimit (cokernel_cofork.of_œÄ p hp‚ÇÄ))
(hŒπ‚ÇÄ : Œπ ‚â´ hp.desc (cokernel_cofork.of_œÄ _ S.zero) = 0)
(hŒπ : is_limit (kernel_fork.of_Œπ Œπ hŒπ‚ÇÄ))

namespace right_homology_data

@[simp]
def of_coker_of_ker [has_cokernel S.f] [has_kernel (cokernel.desc‚ÇÄ S.f S.g S.zero)] :
  S.right_homology_data :=
{ Q := cokernel S.f,
  H := kernel (cokernel.desc‚ÇÄ S.f S.g S.zero),
  p := cokernel.œÄ _,
  Œπ := kernel.Œπ _,
  hp‚ÇÄ := cokernel.condition _,
  hp := cokernel_is_cokernel _,
  hŒπ‚ÇÄ := kernel.condition _,
  hŒπ := kernel_is_kernel _, }

attribute [simp, reassoc] hp‚ÇÄ hŒπ‚ÇÄ
variables {S} (h : right_homology_data S) {A : C}

instance : epi h.p :=
‚ü®Œª Y l‚ÇÅ l‚ÇÇ, cofork.is_colimit.hom_ext h.hp‚ü©

instance : mono h.Œπ :=
‚ü®Œª Y l‚ÇÅ l‚ÇÇ, fork.is_limit.hom_ext h.hŒπ‚ü©

def desc_Q (k : S.X‚ÇÇ ‚ü∂ A) (hk : S.f ‚â´ k = 0) : h.Q ‚ü∂ A :=
h.hp.desc (cokernel_cofork.of_œÄ k hk)

@[simp, reassoc]
lemma p_desc_Q (k : S.X‚ÇÇ ‚ü∂ A) (hk : S.f ‚â´ k = 0) :
  h.p ‚â´ h.desc_Q k hk = k :=
h.hp.fac _ walking_parallel_pair.one

@[simp]
def desc_H (k : S.X‚ÇÇ ‚ü∂ A) (hk : S.f ‚â´ k = 0) : h.H ‚ü∂ A :=
  h.Œπ ‚â´ h.desc_Q k hk

/-- The morphism `h.Q ‚ü∂ S.X‚ÇÉ` induced by `S.g : S.X‚ÇÇ ‚ü∂ S.X‚ÇÉ` and the fact that
`h.Q` is a cokernel of `S.f : S.X‚ÇÅ ‚ü∂ S.X‚ÇÇ`. -/
def g' : h.Q ‚ü∂ S.X‚ÇÉ := h.desc_Q S.g S.zero

@[simp, reassoc]
lemma p_g' : h.p ‚â´ h.g' = S.g :=
p_desc_Q _ _ _

@[simp, reassoc]
lemma Œπ_g' : h.Œπ ‚â´ h.g' = 0 := h.hŒπ‚ÇÄ

/-- For `h : homology_ful_data S`, this is a restatement of `h.hŒπ`, saying that
`Œπ : h.H ‚ü∂ h.Q` is a kernel of `h.g' : h.Q ‚ü∂ S.X‚ÇÉ`. -/
@[simp]
def hŒπ' : is_limit (kernel_fork.of_Œπ h.Œπ h.Œπ_g') := h.hŒπ

def lift_H (k : A ‚ü∂ h.Q) (hk : k ‚â´ h.g' = 0) :
  A ‚ü∂ h.H :=
h.hŒπ.lift (kernel_fork.of_Œπ k hk)

@[simp, reassoc]
lemma lift_H_Œπ (k : A ‚ü∂ h.Q) (hk : k ‚â´ h.g' = 0) :
  h.lift_H k hk ‚â´ h.Œπ = k :=
h.hŒπ.fac (kernel_fork.of_Œπ k hk) walking_parallel_pair.zero

variable (S)

@[simp]
def of_colimit_cokernel_cofork (hg : S.g = 0) (c : cokernel_cofork S.f) (hc : is_colimit c) :
  S.right_homology_data :=
{ Q := c.X,
  H := c.X,
  p := c.œÄ,
  Œπ := ùüô _,
  hp‚ÇÄ := cokernel_cofork.condition _,
  hp := is_colimit.of_iso_colimit hc (cofork.ext (iso.refl _) (by tidy)),
  hŒπ‚ÇÄ := cofork.is_colimit.hom_ext hc begin
    dsimp,
    simp only [hg, id_comp, cofork.is_colimit.œÄ_desc, cokernel_cofork.œÄ_of_œÄ, comp_zero],
  end,
  hŒπ := kernel_zero _ begin
    apply cofork.is_colimit.hom_ext hc,
    dsimp,
    simp only [hg, id_comp, cofork.is_colimit.œÄ_desc, cokernel_cofork.œÄ_of_œÄ, comp_zero],
  end }

@[simp]
def of_has_cokernel [has_cokernel S.f] (hg : S.g = 0) : S.right_homology_data :=
of_colimit_cokernel_cofork S hg _ (cokernel_is_cokernel _)

@[simp]
def of_limit_kernel_fork (hf : S.f = 0) (c : kernel_fork S.g) (hc : is_limit c) :
  S.right_homology_data :=
{ Q := S.X‚ÇÇ,
  H := c.X,
  p := ùüô _,
  Œπ := c.Œπ,
  hp‚ÇÄ := by rw [comp_id, hf],
  hp := cokernel_zero _ hf,
  hŒπ‚ÇÄ := kernel_fork.condition _,
  hŒπ := is_limit.of_iso_limit hc (fork.ext (iso.refl _) (by tidy)), }

@[simp]
def of_has_kernel [has_kernel S.g] (hf : S.f = 0) : S.right_homology_data :=
of_limit_kernel_fork S hf _ (kernel_is_kernel _)

@[simp]
def of_zeros (hf : S.f = 0) (hg : S.g = 0) :
  S.right_homology_data :=
{ Q := S.X‚ÇÇ,
  H := S.X‚ÇÇ,
  p := ùüô _,
  Œπ := ùüô _,
  hp‚ÇÄ := by rw [comp_id, hf],
  hp := cokernel_zero _ hf,
  hŒπ‚ÇÄ := by { dsimp, rw [id_comp, hg], },
  hŒπ := kernel_zero _ hg, }

end right_homology_data

class has_right_homology : Prop :=
(cond : nonempty S.right_homology_data)

def some_right_homology_data [has_right_homology S] :
  S.right_homology_data := has_right_homology.cond.some

variable {S}

lemma has_right_homology.mk' (h : S.right_homology_data) : has_right_homology S :=
‚ü®nonempty.intro h‚ü©

@[priority 100]
instance has_right_homology_of_coker_of_ker
  [has_cokernel S.f] [has_kernel (cokernel.desc‚ÇÄ S.f S.g S.zero)] :
  S.has_right_homology := has_right_homology.mk' (right_homology_data.of_coker_of_ker S)

instance has_right_homology_of_has_cokernel {X Y : C} (f : X ‚ü∂ Y) (Z : C)
  [has_cokernel f] :
  (short_complex.mk f (0 : Y ‚ü∂ Z) comp_zero).has_right_homology :=
has_right_homology.mk' (right_homology_data.of_has_cokernel _ rfl)

instance has_right_homology_of_has_kernel {Y Z : C} (g : Y ‚ü∂ Z) (X : C)
  [has_kernel g] :
  (short_complex.mk (0 : X ‚ü∂ Y) g zero_comp).has_right_homology :=
has_right_homology.mk' (right_homology_data.of_has_kernel _ rfl)

instance has_right_homology_of_zeros (X Y Z : C) :
  (short_complex.mk (0 : X ‚ü∂ Y) (0 : Y ‚ü∂ Z) zero_comp).has_right_homology :=
has_right_homology.mk' (right_homology_data.of_zeros _ rfl rfl)

@[simp]
def left_homology_data.op (h : left_homology_data S) :
  right_homology_data S.op :=
{ Q := opposite.op h.K,
  H := opposite.op h.H,
  p := h.i.op,
  Œπ := h.œÄ.op,
  hp‚ÇÄ := quiver.hom.unop_inj h.hi‚ÇÄ,
  hp := kernel_fork.is_limit.of_Œπ_op _ _ h.hi,
  hŒπ‚ÇÄ := quiver.hom.unop_inj h.hœÄ‚ÇÄ,
  hŒπ := cokernel_cofork.is_colimit.of_œÄ_op _ _ h.hœÄ, }

@[simp] lemma left_homology_data.op_p (h : left_homology_data S) : h.op.p = h.i.op := rfl
@[simp] lemma left_homology_data.op_Œπ (h : left_homology_data S) : h.op.Œπ = h.œÄ.op := rfl
@[simp] lemma left_homology_data.op_g' (h : left_homology_data S) : h.op.g' = h.f'.op := rfl

@[simp]
def right_homology_data.op (h : right_homology_data S) :
  left_homology_data S.op :=
{ K := opposite.op h.Q,
  H := opposite.op h.H,
  i := h.p.op,
  œÄ := h.Œπ.op,
  hi‚ÇÄ := quiver.hom.unop_inj h.hp‚ÇÄ,
  hi := cokernel_cofork.is_colimit.of_œÄ_op _ _ h.hp,
  hœÄ‚ÇÄ := quiver.hom.unop_inj h.hŒπ‚ÇÄ,
  hœÄ := kernel_fork.is_limit.of_Œπ_op _ _ h.hŒπ, }

@[simp] lemma right_homology_data.op_i (h : right_homology_data S) : h.op.i = h.p.op := rfl
@[simp] lemma right_homology_data.op_œÄ (h : right_homology_data S) : h.op.œÄ = h.Œπ.op := rfl
@[simp] lemma right_homology_data.op_f' (h : right_homology_data S) : h.op.f' = h.g'.op := rfl

section

variable {S' : short_complex C·µí·µñ}

@[simp]
def left_homology_data.unop (h : left_homology_data S') :
  right_homology_data S'.unop :=
{ Q := opposite.unop h.K,
  H := opposite.unop h.H,
  p := h.i.unop,
  Œπ := h.œÄ.unop,
  hp‚ÇÄ := quiver.hom.op_inj h.hi‚ÇÄ,
  hp := kernel_fork.is_limit.of_Œπ_unop _ _ h.hi,
  hŒπ‚ÇÄ := quiver.hom.op_inj h.hœÄ‚ÇÄ,
  hŒπ := cokernel_cofork.is_colimit.of_œÄ_unop _ _ h.hœÄ, }

@[simp] lemma left_homology_data.unop_p (h : left_homology_data S') : h.unop.p = h.i.unop := rfl
@[simp] lemma left_homology_data.unop_Œπ (h : left_homology_data S') : h.unop.Œπ = h.œÄ.unop := rfl
@[simp] lemma left_homology_data.unop_g' (h : left_homology_data S') : h.unop.g' = h.f'.unop := rfl

@[simp]
def right_homology_data.unop (h : right_homology_data S') :
  left_homology_data S'.unop :=
{ K := opposite.unop h.Q,
  H := opposite.unop h.H,
  i := h.p.unop,
  œÄ := h.Œπ.unop,
  hi‚ÇÄ := quiver.hom.op_inj h.hp‚ÇÄ,
  hi := cokernel_cofork.is_colimit.of_œÄ_unop _ _ h.hp,
  hœÄ‚ÇÄ := quiver.hom.op_inj h.hŒπ‚ÇÄ,
  hœÄ := kernel_fork.is_limit.of_Œπ_unop _ _ h.hŒπ, }

@[simp] lemma right_homology_data.unop_i (h : right_homology_data S') : h.unop.i = h.p.unop := rfl
@[simp] lemma right_homology_data.unop_œÄ (h : right_homology_data S') : h.unop.œÄ = h.Œπ.unop := rfl
@[simp] lemma right_homology_data.unop_f' (h : right_homology_data S') :
  h.unop.f' = h.g'.unop := rfl

end

variables {S‚ÇÅ S‚ÇÇ S‚ÇÉ : short_complex C} (œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ)
  (h‚ÇÅ : S‚ÇÅ.right_homology_data) (h‚ÇÇ : S‚ÇÇ.right_homology_data)

structure right_homology_map_data :=
(œÜQ : h‚ÇÅ.Q ‚ü∂ h‚ÇÇ.Q)
(œÜH : h‚ÇÅ.H ‚ü∂ h‚ÇÇ.H)
(commp : h‚ÇÅ.p ‚â´ œÜQ = œÜ.œÑ‚ÇÇ ‚â´ h‚ÇÇ.p)
(commg' : h‚ÇÅ.g' ‚â´ œÜ.œÑ‚ÇÉ = œÜQ ‚â´ h‚ÇÇ.g')
(commŒπ : h‚ÇÅ.Œπ ‚â´ œÜQ = œÜH ‚â´ h‚ÇÇ.Œπ)

namespace right_homology_map_data

attribute [reassoc] commp commg' commŒπ

@[simps]
def id (h : S.right_homology_data) : right_homology_map_data (ùüô S) h h :=
{ œÜQ := ùüô _,
  œÜH := ùüô _,
  commp := by simp only [id_œÑ‚ÇÇ, comp_id, id_comp],
  commg' := by simp only [comp_id, id_œÑ‚ÇÉ, id_comp],
  commŒπ := by simp only [comp_id, id_comp], }

@[simps]
def comp {œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ} {œÜ' : S‚ÇÇ ‚ü∂ S‚ÇÉ} {h‚ÇÅ : S‚ÇÅ.right_homology_data}
  {h‚ÇÇ : S‚ÇÇ.right_homology_data} {h‚ÇÉ : S‚ÇÉ.right_homology_data}
  (œà : right_homology_map_data œÜ h‚ÇÅ h‚ÇÇ) (œà' : right_homology_map_data œÜ' h‚ÇÇ h‚ÇÉ) :
  right_homology_map_data (œÜ ‚â´ œÜ') h‚ÇÅ h‚ÇÉ :=
{ œÜQ := œà.œÜQ ‚â´ œà'.œÜQ,
  œÜH := œà.œÜH ‚â´ œà'.œÜH,
  commp := by simp only [comp_œÑ‚ÇÇ, assoc, œà.commp_assoc, œà'.commp],
  commg' := by simp only [comp_œÑ‚ÇÉ, assoc, œà.commg'_assoc, œà'.commg'],
  commŒπ := by simp only [assoc, œà.commŒπ_assoc, œà'.commŒπ], }

instance : subsingleton (right_homology_map_data œÜ h‚ÇÅ h‚ÇÇ) :=
‚ü®begin
  rintros ‚ü®œÜQ‚ÇÅ, œÜH‚ÇÅ, commp‚ÇÅ, commg'‚ÇÅ, commŒπ‚ÇÅ‚ü© ‚ü®œÜQ‚ÇÇ, œÜH‚ÇÇ, commp‚ÇÇ, commg'‚ÇÇ, commŒπ‚ÇÇ‚ü©,
  have hQ : œÜQ‚ÇÅ = œÜQ‚ÇÇ := by rw [‚Üê cancel_epi h‚ÇÅ.p, commp‚ÇÅ, commp‚ÇÇ],
  have hH : œÜH‚ÇÅ = œÜH‚ÇÇ := by rw [‚Üê cancel_mono h‚ÇÇ.Œπ, ‚Üê commŒπ‚ÇÅ, ‚Üê commŒπ‚ÇÇ, hQ],
  simp only,
  split; assumption,
end‚ü©

instance : inhabited (right_homology_map_data œÜ h‚ÇÅ h‚ÇÇ) :=
‚ü®begin
  let œÜQ : h‚ÇÅ.Q ‚ü∂ h‚ÇÇ.Q := h‚ÇÅ.desc_Q (œÜ.œÑ‚ÇÇ ‚â´ h‚ÇÇ.p)
    (by rw [‚Üê œÜ.comm‚ÇÅ‚ÇÇ_assoc, h‚ÇÇ.hp‚ÇÄ, comp_zero]),
  have commp : h‚ÇÅ.p ‚â´ œÜQ = œÜ.œÑ‚ÇÇ ‚â´ h‚ÇÇ.p := right_homology_data.p_desc_Q _ _ _,
  have commg' : h‚ÇÅ.g' ‚â´ œÜ.œÑ‚ÇÉ = œÜQ ‚â´ h‚ÇÇ.g',
  { simp only [‚Üê cancel_epi h‚ÇÅ.p, assoc, right_homology_data.p_desc_Q_assoc,
      right_homology_data.p_g'_assoc, right_homology_data.p_g', œÜ.comm‚ÇÇ‚ÇÉ], },
  let œÜH : h‚ÇÅ.H ‚ü∂ h‚ÇÇ.H := h‚ÇÇ.lift_H (h‚ÇÅ.Œπ ‚â´ œÜQ)
    (by rw [assoc, ‚Üê commg', h‚ÇÅ.Œπ_g'_assoc, zero_comp]),
  have commŒπ : h‚ÇÅ.Œπ ‚â´ œÜQ = œÜH ‚â´ h‚ÇÇ.Œπ := by rw right_homology_data.lift_H_Œπ,
  exact ‚ü®œÜQ, œÜH, commp, commg', commŒπ‚ü©,
end‚ü©

instance : unique (right_homology_map_data œÜ h‚ÇÅ h‚ÇÇ) := unique.mk' _

end right_homology_map_data

@[simps]
def left_homology_map_data.op {S‚ÇÅ S‚ÇÇ : short_complex C} {œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ}
  {h‚ÇÅ : S‚ÇÅ.left_homology_data} {h‚ÇÇ : S‚ÇÇ.left_homology_data}
  (œà : left_homology_map_data œÜ h‚ÇÅ h‚ÇÇ) :
  right_homology_map_data (op_map œÜ) h‚ÇÇ.op h‚ÇÅ.op :=
{ œÜQ := œà.œÜK.op,
  œÜH := œà.œÜH.op,
  commp := by simp only [op_map_œÑ‚ÇÇ, ‚Üê op_comp, left_homology_data.op_p, œà.commi],
  commg' := by simp only [left_homology_data.op_g', op_map_œÑ‚ÇÉ, ‚Üê op_comp, œà.commf'],
  commŒπ := by simp only [left_homology_data.op_Œπ, ‚Üê op_comp, œà.commœÄ], }

@[simps]
def left_homology_map_data.unop {S‚ÇÅ S‚ÇÇ : short_complex C·µí·µñ} {œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ}
  {h‚ÇÅ : S‚ÇÅ.left_homology_data} {h‚ÇÇ : S‚ÇÇ.left_homology_data}
  (œà : left_homology_map_data œÜ h‚ÇÅ h‚ÇÇ) :
  right_homology_map_data (unop_map œÜ) h‚ÇÇ.unop h‚ÇÅ.unop :=
{ œÜQ := œà.œÜK.unop,
  œÜH := œà.œÜH.unop,
  commp := by simp only [unop_map_œÑ‚ÇÇ, ‚Üê unop_comp, left_homology_data.unop_p, œà.commi],
  commg' := by simp only [left_homology_data.unop_g', unop_map_œÑ‚ÇÉ, ‚Üê unop_comp, œà.commf'],
  commŒπ := by simp only [left_homology_data.unop_Œπ, ‚Üê unop_comp, œà.commœÄ], }

@[simps]
def right_homology_map_data.op {S‚ÇÅ S‚ÇÇ : short_complex C} {œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ}
  {h‚ÇÅ : S‚ÇÅ.right_homology_data} {h‚ÇÇ : S‚ÇÇ.right_homology_data}
  (œà : right_homology_map_data œÜ h‚ÇÅ h‚ÇÇ) :
  left_homology_map_data (op_map œÜ) h‚ÇÇ.op h‚ÇÅ.op :=
{ œÜK := œà.œÜQ.op,
  œÜH := œà.œÜH.op,
  commi := by simp only [right_homology_data.op_i, op_map_œÑ‚ÇÇ, ‚Üê op_comp, œà.commp],
  commf' := by simp only [right_homology_data.op_f', op_map_œÑ‚ÇÅ, ‚Üê op_comp, œà.commg'],
  commœÄ := by { simp only [right_homology_data.op_œÄ, ‚Üê op_comp, œà.commŒπ], }, }

@[simps]
def right_homology_map_data.unop {S‚ÇÅ S‚ÇÇ : short_complex C·µí·µñ} {œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ}
  {h‚ÇÅ : S‚ÇÅ.right_homology_data} {h‚ÇÇ : S‚ÇÇ.right_homology_data}
  (œà : right_homology_map_data œÜ h‚ÇÅ h‚ÇÇ) :
  left_homology_map_data (unop_map œÜ) h‚ÇÇ.unop h‚ÇÅ.unop :=
{ œÜK := œà.œÜQ.unop,
  œÜH := œà.œÜH.unop,
  commi := by simp only [right_homology_data.unop_i, unop_map_œÑ‚ÇÇ, ‚Üê unop_comp, œà.commp],
  commf' := by simp only [right_homology_data.unop_f', unop_map_œÑ‚ÇÅ, ‚Üê unop_comp, œà.commg'],
  commœÄ := by { simp only [right_homology_data.unop_œÄ, ‚Üê unop_comp, œà.commŒπ], }, }

end short_complex
