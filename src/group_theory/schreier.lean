/-
Copyright (c) 2022 Thomas Browning. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Thomas Browning
-/

import group_theory.abelianization
import group_theory.transfer

/-!
# Schreier's Lemma

In this file we prove Schreier's lemma.

## Main results

- `closure_mul_image_eq` : **Schreier's Lemma**: If `R : set G` is a right_transversal
  of `H : subgroup G` with `1 ∈ R`, and if `G` is generated by `S : set G`,
  then `H` is generated by the `set` `(R * S).image (λ g, g * (to_fun hR g)⁻¹)`.
- `fg_of_index_ne_zero` : **Schreier's Lemma**: A finite index subgroup of a finitely generated
  group is finitely generated.
-/

open_locale pointwise

namespace subgroup

open mem_right_transversals

variables {G : Type*} [group G] {H : subgroup G} {R S : set G}

lemma closure_mul_image_mul_eq_top
  (hR : R ∈ right_transversals (H : set G)) (hR1 : (1 : G) ∈ R) (hS : closure S = ⊤) :
  (closure ((R * S).image (λ g, g * (to_fun hR g)⁻¹)) : set G) * R = ⊤ :=
begin
  let f : G → R := λ g, to_fun hR g,
  let U : set G := (R * S).image (λ g, g * (f g)⁻¹),
  change (closure U : set G) * R = ⊤,
  refine top_le_iff.mp (λ g hg, _),
  apply closure_induction_right (eq_top_iff.mp hS (mem_top g)),
  { exact ⟨1, 1, (closure U).one_mem, hR1, one_mul 1⟩ },
  { rintros - s hs ⟨u, r, hu, hr, rfl⟩,
    rw show u * r * s = u * ((r * s) * (f (r * s))⁻¹) * f (r * s), by group,
    refine set.mul_mem_mul ((closure U).mul_mem hu _) (f (r * s)).coe_prop,
    exact subset_closure ⟨r * s, set.mul_mem_mul hr hs, rfl⟩ },
  { rintros - s hs ⟨u, r, hu, hr, rfl⟩,
    rw show u * r * s⁻¹ = u * (f (r * s⁻¹) * s * r⁻¹)⁻¹ * f (r * s⁻¹), by group,
    refine set.mul_mem_mul ((closure U).mul_mem hu ((closure U).inv_mem _)) (f (r * s⁻¹)).2,
    refine subset_closure ⟨f (r * s⁻¹) * s, set.mul_mem_mul (f (r * s⁻¹)).2 hs, _⟩,
    rw [mul_right_inj, inv_inj, ←subtype.coe_mk r hr, ←subtype.ext_iff, subtype.coe_mk],
    apply (mem_right_transversals_iff_exists_unique_mul_inv_mem.mp hR (f (r * s⁻¹) * s)).unique
      (mul_inv_to_fun_mem hR (f (r * s⁻¹) * s)),
    rw [mul_assoc, ←inv_inv s, ←mul_inv_rev, inv_inv],
    exact to_fun_mul_inv_mem hR (r * s⁻¹) },
end

/-- **Schreier's Lemma**: If `R : set G` is a right_transversal of `H : subgroup G`
  with `1 ∈ R`, and if `G` is generated by `S : set G`, then `H` is generated by the `set`
  `(R * S).image (λ g, g * (to_fun hR g)⁻¹)`. -/
lemma closure_mul_image_eq
  (hR : R ∈ right_transversals (H : set G)) (hR1 : (1 : G) ∈ R) (hS : closure S = ⊤) :
  closure ((R * S).image (λ g, g * (to_fun hR g)⁻¹)) = H :=
begin
  have hU : closure ((R * S).image (λ g, g * (to_fun hR g)⁻¹)) ≤ H,
  { rw closure_le,
    rintros - ⟨g, -, rfl⟩,
    exact mul_inv_to_fun_mem hR g },
  refine le_antisymm hU (λ h hh, _),
  obtain ⟨g, r, hg, hr, rfl⟩ :=
  show h ∈ _, from eq_top_iff.mp (closure_mul_image_mul_eq_top hR hR1 hS) (mem_top h),
  suffices : (⟨r, hr⟩ : R) = (⟨1, hR1⟩ : R),
  { rwa [show r = 1, from subtype.ext_iff.mp this, mul_one] },
  apply (mem_right_transversals_iff_exists_unique_mul_inv_mem.mp hR r).unique,
  { rw [subtype.coe_mk, mul_inv_self],
    exact H.one_mem },
  { rw [subtype.coe_mk, inv_one, mul_one],
    exact (H.mul_mem_cancel_left (hU hg)).mp hh },
end

/-- **Schreier's Lemma**: If `R : set G` is a right_transversal of `H : subgroup G`
  with `1 ∈ R`, and if `G` is generated by `S : set G`, then `H` is generated by the `set`
  `(R * S).image (λ g, g * (to_fun hR g)⁻¹)`. -/
lemma closure_mul_image_eq_top
  (hR : R ∈ right_transversals (H : set G)) (hR1 : (1 : G) ∈ R) (hS : closure S = ⊤) :
  closure ((R * S).image (λ g, ⟨g * (to_fun hR g)⁻¹, mul_inv_to_fun_mem hR g⟩) : set H) = ⊤ :=
begin
  rw [eq_top_iff, ←map_subtype_le_map_subtype, monoid_hom.map_closure, set.image_image],
  exact (map_subtype_le ⊤).trans (ge_of_eq (closure_mul_image_eq hR hR1 hS)),
end

/-- **Schreier's Lemma**: If `R : finset G` is a right_transversal of `H : subgroup G`
  with `1 ∈ R`, and if `G` is generated by `S : finset G`, then `H` is generated by the `finset`
  `(R * S).image (λ g, g * (to_fun hR g)⁻¹)`. -/
lemma closure_mul_image_eq_top' [decidable_eq G] {R S : finset G}
  (hR : (R : set G) ∈ right_transversals (H : set G)) (hR1 : (1 : G) ∈ R)
  (hS : closure (S : set G) = ⊤) :
  closure ((((R * S).image (λ g, ⟨_, mul_inv_to_fun_mem hR g⟩)) : finset H) : set H) = ⊤ :=
begin
  rw [finset.coe_image, finset.coe_mul],
  exact closure_mul_image_eq_top hR hR1 hS,
end

lemma exists_finset_card_le_mul (hH : H.index ≠ 0) {S : finset G} (hS : closure (S : set G) = ⊤) :
  ∃ T : finset H, T.card ≤ H.index * S.card ∧ closure (T : set H) = ⊤ :=
begin
  haveI : decidable_eq G := classical.dec_eq G,
  obtain ⟨R₀, hR : R₀ ∈ right_transversals (H : set G), hR1⟩ := exists_right_transversal (1 : G),
  haveI : fintype (G ⧸ H) := fintype_of_index_ne_zero hH,
  haveI : fintype R₀ := fintype.of_equiv _ (mem_right_transversals.to_equiv hR),
  let R : finset G := set.to_finset R₀,
  replace hR : (R : set G) ∈ right_transversals (H : set G) := by rwa set.coe_to_finset,
  replace hR1 : (1 : G) ∈ R := by rwa set.mem_to_finset,
  refine ⟨_, _, closure_mul_image_eq_top' hR hR1 hS⟩,
  calc _ ≤ (R * S).card : finset.card_image_le
  ... ≤ (R ×ˢ S).card : finset.card_image_le
  ... = R.card * S.card : R.card_product S
  ... = H.index * S.card : congr_arg (* S.card) _,
  calc R.card = fintype.card R : (fintype.card_coe R).symm
  ... = _ : (fintype.card_congr (mem_right_transversals.to_equiv hR)).symm
  ... = fintype.card (G ⧸ H) : quotient_group.card_quotient_right_rel H
  ... = H.index : H.index_eq_card.symm,
end

/-- **Schreier's Lemma**: A finite index subgroup of a finitely generated
  group is finitely generated. -/
lemma fg_of_index_ne_zero [hG : group.fg G] (hH : H.index ≠ 0) : group.fg H :=
begin
  obtain ⟨S, hS⟩ := hG.1,
  obtain ⟨T, -, hT⟩ := exists_finset_card_le_mul hH hS,
  exact ⟨⟨T, hT⟩⟩,
end

lemma rank_le_index_mul_rank [hG : group.fg G] {H : subgroup G} (hH : H.index ≠ 0)
  [decidable_pred (λ n, ∃ (S : finset G), S.card = n ∧ closure (S : set G) = ⊤)]
  [decidable_pred (λ n, ∃ (S : finset H), S.card = n ∧ closure (S : set H) = ⊤)] :
  @group.rank H _ (fg_of_index_ne_zero hH) _ ≤ H.index * group.rank G :=
begin
  haveI := fg_of_index_ne_zero hH,
  obtain ⟨S, hS₀, hS⟩ := group.rank_spec G,
  obtain ⟨T, hT₀, hT⟩ := exists_finset_card_le_mul hH hS,
  calc group.rank H ≤ T.card : group.rank_le H hT
  ... ≤ H.index * S.card : hT₀
  ... = H.index * group.rank G : congr_arg ((*) H.index) hS₀,
end

open_locale big_operators

lemma zmod.card {n : ℕ} : nat.card (zmod n) = n :=
begin
  rcases nat.eq_zero_or_pos n with rfl | h,
  { exact nat.card_eq_zero_of_infinite },
  { haveI := fact.mk h,
    rw [nat.card_eq_fintype_card, zmod.card] },
end

lemma orbit_eq_self_of_mem {G : Type*} [group G] {H : subgroup G} {g : G} (h : g ∈ H) :
  mul_action.orbit H g = H :=
set.ext (λ x, ⟨λ ⟨y, z⟩, (congr_arg (∈ H) z).mp (H.mul_mem y.2 h),
  λ y, ⟨⟨x, y⟩ * ⟨g, h⟩⁻¹, inv_mul_cancel_right x g⟩⟩)

lemma orbit_one_eq_self {G : Type*} [group G] (H : subgroup G) : mul_action.orbit H (1 : G) = H :=
orbit_eq_self_of_mem H.one_mem

lemma order_eq_card_zpowers' {G : Type*} [group G] (g : G) : order_of g = nat.card (zpowers g) :=
begin
  have := nat.card_congr (mul_action.orbit_zpowers_equiv g (1 : G)),
  rwa [zmod.card, orbit_one_eq_self, eq_comm] at this,
end

lemma key_lemma0 (G : Type*) [comm_group G] [group.fg G]
  [decidable_pred (λ n, ∃ (S : finset G), S.card = n ∧ closure (S : set G) = ⊤)] :
  nat.card G ∣ monoid.exponent G ^ group.rank G :=
begin
  classical,
  obtain ⟨S, hS1, hS2⟩ := group.rank_spec G,
  rw [←hS1, ←fintype.card_coe, ←finset.card_univ, ←finset.prod_const],
  let f : (Π g : S, zpowers (g : G)) →* G :=
  { to_fun := λ a, ∏ g : S, a g,
    map_one' := finset.prod_const_one,
    map_mul' := λ a b, finset.prod_mul_distrib },
  have hf : function.surjective f,
  { rw [←monoid_hom.range_top_iff_surjective, eq_top_iff, ←hS2, closure_le],
    intros g₀ hg₀,
    refine ⟨λ g, if ↑g = g₀ then ⟨g, mem_zpowers g⟩ else 1, _⟩,
    simp only [f, monoid_hom.coe_mk],
    refine (finset.prod_eq_single_of_mem (⟨g₀, hg₀⟩ : S) (finset.mem_univ ⟨g₀, hg₀⟩) _).trans _,
    { intros g _ hg,
      rw [if_neg, coe_one],
      rwa [ne, subtype.ext_iff] at hg },
    { rw [if_pos, subtype.coe_mk, subtype.coe_mk],
      rw subtype.coe_mk } },
  replace hf : nat.card G ∣ nat.card (Π g : S, zpowers (g : G)),
  { sorry },
  replace hf : nat.card G ∣ ∏ g : S, nat.card (zpowers (g : G)),
  { sorry },
  refine hf.trans (finset.prod_dvd_prod_of_dvd _ _ (λ g hg, _)),
  rw ← order_eq_card_zpowers',
  exact monoid.order_dvd_exponent (g : G),
end

lemma key_lemma17 {G : Type*} [comm_group G] [group.fg G] {n : ℕ} (hG : ∀ g : G, g ^ n = 1)
  [decidable_pred (λ n, ∃ (S : finset G), S.card = n ∧ closure (S : set G) = ⊤)] :
  nat.card G ∣ n ^ group.rank G :=
(key_lemma0 G).trans
    (pow_dvd_pow_of_dvd (monoid.exponent_dvd_of_forall_pow_eq_one G n hG) (group.rank G))

instance map_is_commutative {G G' : Type*} [group G] [group G'] (f : G →* G') {H : subgroup G}
  [hH : H.is_commutative] : (H.map f).is_commutative :=
⟨⟨begin
  rintros ⟨-, a, ha, rfl⟩ ⟨-, b, hb, rfl⟩,
  rw [subtype.ext_iff, coe_mul, coe_mul, subtype.coe_mk, subtype.coe_mk, ←map_mul, ←map_mul],
  exact congr_arg f (subtype.ext_iff.mp (mul_comm ⟨a, ha⟩ ⟨b, hb⟩)),
end⟩⟩

lemma comap_injective_is_commutative {G G' : Type*} [group G] [group G'] {f : G →* G'}
  (hf : function.injective f) {H : subgroup G'}
  [hH : H.is_commutative] : (H.comap f).is_commutative :=
⟨⟨λ a b, subtype.ext begin
  have := mul_comm (⟨f a, a.2⟩ : H) (⟨f b, b.2⟩ : H),
  rwa [subtype.ext_iff, coe_mul, coe_mul, coe_mk, coe_mk, ←map_mul, ←map_mul, hf.eq_iff] at this,
end⟩⟩

instance subgroup_of_is_commutative
  {G : Type*} [group G] {H K : subgroup G} [hH : H.is_commutative] :
  (H.subgroup_of K).is_commutative :=
subgroup.comap_injective_is_commutative subtype.coe_injective

instance {G : Type*} [group G] (s : set G) [finite s] : group.fg (closure s) :=
sorry

@[to_additive] lemma subgroup.rank_le {G : Type*} [group G]
  {H : subgroup G} [group.fg H]
  [decidable_pred (λ n, ∃ (S : finset H), S.card = n ∧ subgroup.closure (S : set H) = ⊤)]
  {S : finset G} (hS : subgroup.closure (S : set G) = H) : group.rank H ≤ S.card :=
begin
  let T : finset H := S.preimage coe (subtype.coe_injective.inj_on _),
  have key : S = T.map (function.embedding.subtype _),
  { simp_rw [finset.ext_iff, finset.mem_map, finset.mem_preimage],
    simp only [function.embedding.coe_subtype, exists_prop],
    sorry },
  rw [key, finset.card_map],
  apply group.rank_le,
  apply subgroup.map_injective (show function.injective H.subtype, from subtype.coe_injective),
  rw [monoid_hom.map_closure, ←monoid_hom.range_eq_map, subtype_range],
  rwa [key, finset.coe_map] at hS,
end

lemma rank_closure_le_card {G : Type*} [group G] (s : set G) [finite s]
  [decidable_pred (λ n, ∃ (S : finset (closure s)), S.card = n ∧ closure (S : set (closure s)) = ⊤)] :
  group.rank (closure s) ≤ nat.card s :=
begin
  haveI := fintype.of_finite s,
  rw [nat.card_eq_fintype_card, ←set.to_finset_card],
  have key := group.rank_le (closure s),
  have key : nat.card s = s.to_finset.card,
  { simp only [nat.card_eq_fintype_card, set.to_finset_card] },
  have key := s.to_finset,
  sorry
end

instance (G : Type*) [group G] [finite {g | ∃ g₁ g₂ : G, ⁅g₁, g₂⁆ = g}] :
  group.fg (commutator G) :=
begin
  sorry
end

lemma rank_commutator_le_card (G : Type*) [group G] [finite {g | ∃ g₁ g₂ : G, ⁅g₁, g₂⁆ = g}]
  [decidable_pred (λ n, ∃ (S : finset (commutator G)), S.card = n ∧ closure (S : set (commutator G)) = ⊤)] :
  group.rank (commutator G) ≤ nat.card {g | ∃ g₁ g₂ : G, ⁅g₁, g₂⁆ = g} :=
begin
  sorry
end

lemma key_lemma [finite {g | ∃ g₁ g₂ : G, ⁅g₁, g₂⁆ = g}] :
  nat.card (commutator G) ∣ (center G).index ^ ((center G).index * nat.card {g | ∃ g₁ g₂ : G, ⁅g₁, g₂⁆ = g} + 1) :=
begin
  classical,
  by_cases hG : (center G).index = 0,
  { simp only [hG, zero_mul, zero_add, pow_one, dvd_zero] },
  let H := (center G).subgroup_of (commutator G),
  rw [←H.card_mul_index, pow_succ'],
  have h0 := relindex_dvd_index_of_normal (center G) (commutator G),
  have h2 := ne_zero_of_dvd_ne_zero hG h0,
  refine mul_dvd_mul (dvd_trans _ (pow_dvd_pow (center G).index ((rank_le_index_mul_rank h2).trans
    (nat.mul_le_mul (nat.le_of_dvd (nat.pos_of_ne_zero hG) h0) (rank_commutator_le_card G))))) h0,
  apply key_lemma17 (λ g, _),
  have key := subtype.ext_iff.mp (abelianization.commutator_subset_ker
    (monoid_hom.transfer_center_pow' hG) g.1.2),
  exact subtype.ext (subtype.ext key),
end

-- bounded commutators and bounded index of center implies bounded commutator subgroup
-- bounded commutators implies bounded index of center
-- bounded index of center implies bounded commutators

end subgroup
