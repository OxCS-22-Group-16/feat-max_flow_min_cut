/-
Copyright (c) 2022 Chris Birkbeck. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Chris Birkbeck, David Loeffler
-/
import algebra.module.submodule.basic
import analysis.complex.upper_half_plane.basic
import linear_algebra.general_linear_group
import linear_algebra.special_linear_group
import algebra.direct_sum.ring
import number_theory.modular
import geometry.manifold.mfderiv
import analysis.complex.upper_half_plane.functions_bounded_at_infty
import number_theory.modular_forms.slash_actions

/-!
# Modular forms

This file defines modular forms and proves some basic properties about them.

We begin by defining the notion of weakly modular form from which we then we construct the vector
space of modular forms, cusp forms and prove that the product of two modular forms is a modular
form (of higher weight).
-/

universes u v

open complex upper_half_plane

open_locale topological_space manifold upper_half_plane

noncomputable theory

local notation `‚Ñç'` := (‚ü®upper_half_plane.upper_half_space ,
 upper_half_plane.upper_half_plane_is_open‚ü©: topological_space.opens ‚ÑÇ)

local prefix `‚Üë‚Çò`:1024 := @coe _ (matrix (fin 2) (fin 2) _) _

local notation `GL(` n `, ` R `)`‚Å∫ := matrix.GL_pos (fin n) R

local notation `SL(` n `, ` R `)` := matrix.special_linear_group (fin n) R

variables (Œì : subgroup SL(2,‚Ñ§)) (k : ‚Ñ§)

namespace modular_forms

local notation f `‚à£[`:73 k:0, A `]`  :72 := slash_action.map ‚ÑÇ k A f

@[simp]
lemma slash_action_eq_slash (k : ‚Ñ§) (A : Œì) (f : ‚Ñç ‚Üí ‚ÑÇ) : f ‚à£[k, A] = slash k A f := by {refl}

@[simp]
lemma slash_action_eq_slash' (k : ‚Ñ§) (A : SL(2, ‚Ñ§)) (f : ‚Ñç ‚Üí ‚ÑÇ) : f ‚à£[k, A] = slash k A f :=
by {refl}

/--The space of functions that are modular-/
def weakly_modular_submodule (k : ‚Ñ§) (Œì : subgroup SL(2,‚Ñ§)) : submodule ‚ÑÇ (‚Ñç ‚Üí ‚ÑÇ) :=
  {carrier := { f : (‚Ñç ‚Üí ‚ÑÇ) | ‚àÄ (Œ≥ : Œì), (f  ‚à£[k, Œ≥]) = f },
  zero_mem' := by {apply slash_action.mul_zero },
  add_mem' := by { intros f g hf hg Œ≥,
    rw [slash_action.add_action k Œ≥ f g, hf Œ≥, hg Œ≥]},
  smul_mem' := by { intros c f hf Œ≥,
    have : (c ‚Ä¢ f) ‚à£[k, Œ≥] = c ‚Ä¢ (f ‚à£[k, Œ≥]), by {apply slash_action.smul_action},
    rw (hf Œ≥) at this,
    apply this,} }

lemma wmodular_mem (k : ‚Ñ§) (Œì : subgroup SL(2,‚Ñ§)) (f : ‚Ñç ‚Üí ‚ÑÇ) :
  f ‚àà (weakly_modular_submodule k Œì) ‚Üî ‚àÄ (Œ≥ : Œì), (f ‚à£[k, Œ≥]) = f := iff.rfl

lemma slash_mul (k1 k2 : ‚Ñ§) (A : GL(2, ‚Ñù)‚Å∫) (f g : ‚Ñç ‚Üí ‚ÑÇ) :
  (f * g) ‚à£[k1 + k2, A] = (((‚Üë‚Çò A).det) : ‚Ñù) ‚Ä¢ (f ‚à£[k1, A]) * (g ‚à£[k2, A]) :=
begin
  ext1,
  simp only [slash_action.map, slash, matrix.general_linear_group.coe_det_apply, subtype.val_eq_coe,
   ‚Üêmul_assoc],
  have h1 : ((((‚Üë‚Çò A).det) : ‚Ñù)^(k1 + k2 - 1) : ‚ÑÇ) =
  (((‚Üë‚Çò A).det) : ‚Ñù) * (((‚Üë‚Çò A).det) : ‚Ñù)^(k1 - 1) * (((‚Üë‚Çò A).det) : ‚Ñù)^(k2 - 1),
  by {simp only [mul_assoc, matrix.general_linear_group.coe_det_apply, subtype.val_eq_coe, coe_coe],
  rw [‚Üêzpow_add‚ÇÄ, ‚Üêzpow_one_add‚ÇÄ],
  ring_exp,
  all_goals { norm_cast, apply (matrix.GL_pos.det_ne_zero A), }, },
  have h22 : (upper_half_plane.denom A x)^(-(k1+k2)) = (upper_half_plane.denom A x)^(-k1) *
    (upper_half_plane.denom A x)^(-k2),
  by { rw [int.neg_add, zpow_add‚ÇÄ], exact upper_half_plane.denom_ne_zero A x, },
  rw [h1, h22],
  simp only [upper_half_plane.denom, pi.mul_apply, coe_coe, zpow_neg, algebra.smul_mul_assoc,
    pi.smul_apply, real_smul],
  ring,
end

lemma slash_mul_SL2 (k1 k2 : ‚Ñ§) (A : SL(2,‚Ñ§)) (f g : ‚Ñç ‚Üí ‚ÑÇ) :
  (f * g) ‚à£[k1 + k2, A] = (f ‚à£[k1, A]) * (g ‚à£[k2, A]) :=
begin
  have : (((‚Üë‚Çò(A : GL(2,‚Ñù)‚Å∫)).det) : ‚Ñù) = 1,
  { simp only [coe_coe,matrix.special_linear_group.coe_GL_pos_coe_GL_coe_matrix,
    matrix.special_linear_group.det_coe], },
  have hs := slash_mul k1 k2 A f g,
  simp_rw [this, one_smul] at hs,
  convert hs,
end

lemma slash_mul_subgroup (k1 k2 : ‚Ñ§) (Œì : subgroup SL(2,‚Ñ§)) (A : Œì) (f g : ‚Ñç ‚Üí ‚ÑÇ) :
  (f * g) ‚à£[k1 + k2, A] = (f ‚à£[k1, A]) * (g ‚à£[k2, A]) :=
begin
  have : (((‚Üë‚Çò(A : GL(2,‚Ñù)‚Å∫)).det) : ‚Ñù) = 1,
  by { simp only [coe_coe,matrix.special_linear_group.coe_GL_pos_coe_GL_coe_matrix,
    matrix.special_linear_group.det_coe], },
  have t1 := slash_mul k1 k2 A f g,
  rw this at t1,
  simp only [coe_coe, one_smul] at t1,
  convert t1,
end

/--A function `f : ‚Ñç ‚Üí ‚ÑÇ` is weakly modular, of weight `k ‚àà ‚Ñ§` and level `Œì`, if for every matrix in
 `Œ≥ ‚àà Œì` we have `f(Œ≥ ‚Ä¢ z)= (c*z+d)^k f(z)` where `Œ≥= ![![a, b], ![c, d]]`,
 and it acts on `‚Ñç` via Moebius trainsformations. -/
lemma wmodular_mem' (k : ‚Ñ§) (Œì : subgroup SL(2,‚Ñ§)) (f : ‚Ñç ‚Üí ‚ÑÇ) :
  f ‚àà (weakly_modular_submodule k Œì) ‚Üî ‚àÄ Œ≥ : Œì, ‚àÄ z : ‚Ñç,
  f (Œ≥ ‚Ä¢ z) = ((‚Üë‚ÇòŒ≥ 1 0 : ‚Ñù) * z +(‚Üë‚ÇòŒ≥ 1 1 : ‚Ñù))^k * f z :=
begin
  simp only [wmodular_mem],
  split,
  { intros h1 Œ≥ z,
  have h3 : (f ‚à£[k, Œ≥]) z = f z , by {simp_rw (h1 Œ≥)},
  rw [‚Üêh3, mul_comm],
  simp only [slash_action_eq_slash, slash],
  have h55 := zpow_neg_mul_zpow_self k (upper_half_plane.denom_ne_zero (Œ≥ : GL(2, ‚Ñù)‚Å∫) z),
  simp only [upper_half_plane.denom, upper_half_plane.subgroup_to_sl_moeb, upper_half_plane.sl_moeb,
    coe_coe, matrix.special_linear_group.coe_GL_pos_coe_GL_coe_matrix,
    matrix.special_linear_group.coe_matrix_coe, int.coe_cast_ring_hom, matrix.map_apply,
    of_real_int_cast] at *,
  rw [mul_assoc, h55, ‚Üêint.coe_cast_ring_hom, ‚Üêmatrix.special_linear_group.coe_matrix_coe,
    matrix.special_linear_group.det_coe ((Œ≥ : SL(2, ‚Ñ§)) : SL(2, ‚Ñù))],
  simp only [of_real_one, one_zpow, mul_one], },
  { intros hf Œ≥,
  simp_rw [slash_action_eq_slash, slash],
  ext1,
  rw [‚Üêupper_half_plane.subgroup_moeb, (hf Œ≥ x), mul_comm],
  have h55 := zpow_neg_mul_zpow_self k (upper_half_plane.denom_ne_zero (Œ≥ : GL(2, ‚Ñù)‚Å∫) x),
  simp_rw upper_half_plane.denom at *,
  simp only [matrix.special_linear_group.coe_GL_pos_coe_GL_coe_matrix, coe_coe,
    matrix.special_linear_group.coe_matrix_coe, int.coe_cast_ring_hom, matrix.map_apply,
    of_real_int_cast] at h55,
  simp only [coe_coe, matrix.special_linear_group.coe_GL_pos_coe_GL_coe_matrix,
    matrix.map_apply, of_real_int_cast],
  rw (matrix.special_linear_group.det_coe ((Œ≥ : SL(2, ‚Ñ§)) : SL(2, ‚Ñù))),
  simp only [matrix.special_linear_group.coe_matrix_coe, int.coe_cast_ring_hom, matrix.map_apply,
    of_real_int_cast, of_real_one, one_zpow, mul_one],
  simp_rw [‚Üê mul_assoc, h55],
  simp },
end

lemma mul_modular (k_1 k_2 : ‚Ñ§) (Œì : subgroup SL(2,‚Ñ§)) (f g : ‚Ñç ‚Üí ‚ÑÇ)
  (hf : f ‚àà weakly_modular_submodule k_1 Œì) (hg : g ‚àà weakly_modular_submodule k_2 Œì) :
  f * g ‚àà weakly_modular_submodule (k_1 + k_2) Œì :=
begin
  simp only [wmodular_mem', pi.mul_apply, coe_coe] at *,
  intros Œ≥ z,
  rw [(hf Œ≥ z), (hg Œ≥ z)],
  have pown := zpow_add‚ÇÄ (upper_half_plane.denom_ne_zero (Œ≥ : GL(2, ‚Ñù)‚Å∫) z) k_1 k_2,
  simp only [upper_half_plane.denom, coe_fn_coe_base, ne.def,
    matrix.general_linear_group.coe_fn_eq_coe, coe_coe] at pown,
  rw pown,
  ring,
end

/-- A function `f : ‚Ñç ‚Üí ‚ÑÇ` is a modular form weight `k ‚àà ‚Ñ§` and of level `Œì` if it is holomorphic,
 weakly modular and bounded at infinity -/
structure is_modular_form_of_weight_and_level (k : ‚Ñ§) (Œì : subgroup SL(2,‚Ñ§)) (f : ‚Ñç ‚Üí ‚ÑÇ) : Prop :=
  (hol : mdifferentiable ùìò(‚ÑÇ) ùìò(‚ÑÇ) (‚Üëf : ‚Ñç' ‚Üí ‚ÑÇ))
  (transf : f ‚àà weakly_modular_submodule k Œì)
  (infinity : ‚àÄ (A : SL(2,‚Ñ§)), is_bound_at_infty (f ‚à£[k, A]))

/-- A function `f : ‚Ñç ‚Üí ‚ÑÇ` is a cusp form of weight `k ‚àà ‚Ñ§` and of level `Œì` if it is holomorphic,
 weakly modular, and zero at infinity -/
structure is_cusp_form_of_weight_and_level (k : ‚Ñ§) (Œì : subgroup SL(2,‚Ñ§)) (f : ‚Ñç ‚Üí ‚ÑÇ) : Prop :=
  (hol : mdifferentiable ùìò(‚ÑÇ) ùìò(‚ÑÇ) (‚Üëf : ‚Ñç' ‚Üí ‚ÑÇ))
  (transf : f ‚àà weakly_modular_submodule k Œì)
  (infinity : ‚àÄ (A : SL(2,‚Ñ§)), is_zero_at_infty (f ‚à£[k, A]))

/-- The zero modular form is a cusp form-/
lemma zero_cusp_form : is_cusp_form_of_weight_and_level k Œì 0 :=
{ hol := by {apply mdifferentiable_zero,},
  transf := (weakly_modular_submodule k Œì).zero_mem',
  infinity := by { intro A,
    rw slash_action.mul_zero,
    apply zero_at_infty_submodule.zero_mem, } }

lemma is_modular_form_of_weight_and_level_of_is_cusp_form_of_weight_and_level {f : ‚Ñç ‚Üí ‚ÑÇ}
  (h : is_cusp_form_of_weight_and_level k Œì f) : is_modular_form_of_weight_and_level k Œì f :=
{ hol := h.1,
  transf := h.2,
  infinity := Œª (A : SL(2,‚Ñ§)), by {apply filter.zero_at_filter_is_bounded_at_filter _ _ (h.3 A)} }

 /-- The zero modular form is a modular form-/
lemma zero_mod_form : is_modular_form_of_weight_and_level k Œì 0 :=
begin
  apply_rules [is_modular_form_of_weight_and_level_of_is_cusp_form_of_weight_and_level,
    zero_cusp_form],
end

/-- This is the space of modular forms of weight `k` and level `Œì`-/
def space_of_mod_forms_of_weight_and_level (k : ‚Ñ§) (Œì : subgroup SL(2,‚Ñ§)) : submodule ‚ÑÇ (‚Ñç ‚Üí ‚ÑÇ) :=
{ carrier := { f : ‚Ñç ‚Üí ‚ÑÇ | is_modular_form_of_weight_and_level k Œì f},
  zero_mem':= by { simp only [set.mem_set_of_eq], apply zero_mod_form, },
  add_mem' := by { intros a b ha hb,
    split,
    exact mdifferentiable_add ha.hol hb.hol,
    exact (weakly_modular_submodule k Œì).add_mem' ha.transf hb.transf,
    intro A,
    rw slash_action.add_action,
    exact (bounded_at_infty_submodule.add_mem' (ha.infinity A) (hb.infinity A)) },
  smul_mem' := by { intros c f hf,
    split,
    exact mdifferentiable_smul _ hf.hol,
    exact (weakly_modular_submodule k Œì).smul_mem' _ hf.transf,
    intro A,
    rw slash_action.smul_action,
    apply (bounded_at_infty_submodule.smul_mem' c (hf.infinity A)), }, }

localized "notation `M`:= space_of_mod_forms_of_weight_and_level " in modular_forms

/-- This is the space of cuspforms of weigth `k` and level `Œì` -/
def space_of_cusp_forms_of_weight_and_level (k : ‚Ñ§) (Œì : subgroup SL(2,‚Ñ§)) : submodule ‚ÑÇ (‚Ñç ‚Üí ‚ÑÇ) :=
{ carrier := is_cusp_form_of_weight_and_level k Œì,
  zero_mem' := by apply zero_cusp_form,
  add_mem' := by { intros a b ha hb,
    split,
    exact mdifferentiable_add ha.hol hb.hol,
    exact (weakly_modular_submodule k Œì).add_mem' ha.transf hb.transf,
    intro A,
    rw slash_action.add_action,
    apply (zero_at_infty_submodule.add_mem' (ha.infinity A) (hb.infinity A)) },
  smul_mem' := by { intros c f hf, split,
    exact mdifferentiable_smul _ hf.hol,
    exact (weakly_modular_submodule k Œì).smul_mem' _ hf.transf,
    intro A,
    rw slash_action.smul_action,
    apply zero_at_infty_submodule.smul_mem' c (hf.infinity A), }, }

localized "notation `S`:= space_of_cusp_forms_of_weight_and_level" in modular_forms

/--The product of two modular forms is a modular form whose weight is the sum of the weights-/
lemma mul_modform (k_1 k_2 : ‚Ñ§) (Œì : subgroup SL(2,‚Ñ§)) (f g : ‚Ñç ‚Üí ‚ÑÇ)
  (hf : f ‚àà M k_1 Œì) (hg : g ‚àà M k_2 Œì) : f * g ‚àà (M (k_1 + k_2) Œì) :=
begin
  refine ‚ü®mdifferentiable_mul hf.1 hg.1, mul_modular _ _ _ _ _ hf.2 hg.2, _‚ü©,
  intro A,
  rw [slash_mul_SL2 k_1 k_2 A f g],
  exact prod_of_bound_is_bound (hf.infinity A) (hg.infinity A),
end

/-! Constant functions are modular forms of weight 0 -/
section const_mod_form

/--A modular form of weight zero-/
def const_one_form : ‚Ñç ‚Üí ‚ÑÇ := 1

/-- The constant function is bounded at infinity -/
lemma const_one_form_is_bound : is_bound_at_infty const_one_form :=
  @asymptotics.is_O_const_const _ _ ‚ÑÇ _ _ 1 _ one_ne_zero _

/-- The constant function 1 is invariant under any subgroup of SL2Z -/
lemma const_one_form_is_invar (A : SL(2,‚Ñ§)) : const_one_form ‚à£[(0 : ‚Ñ§), A] = const_one_form :=
begin
  rw [slash_action_eq_slash', slash, const_one_form],
  dsimp only,
  have : (((‚Üë‚Çò(A : GL(2,‚Ñù)‚Å∫)).det) : ‚Ñù) = 1,
  { simp only [coe_coe,
      matrix.special_linear_group.coe_GL_pos_coe_GL_coe_matrix,
      matrix.special_linear_group.det_coe], },
  rw [zero_sub, this],
  simp only [pi.one_apply, of_real_one, one_zpow, mul_one, neg_zero', zpow_zero],
  refl,
end

/-- The constant function 1 is modular of weight 0 -/
lemma const_mod_form : const_one_form ‚àà M 0 Œì :=
{ hol := by { simp_rw const_one_form, apply mdifferentiable_one, },
  transf := by { intro Œ≥, apply const_one_form_is_invar, },
  infinity := by { intro A, rw const_one_form_is_invar A, exact const_one_form_is_bound,} }

end const_mod_form

end modular_forms
